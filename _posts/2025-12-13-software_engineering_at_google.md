---
layout: post
full-width: true
title: Software Engineering at Google
subtitle: Lessons Learned from Programming Over Time
cover-img: /assets/images/software_engineering_at_google.jpg
thumbnail-img: /assets/images/software_engineering_at_google.jpg
share-img: /assets/images/software_engineering_at_google.jpg
tags: [کتاب, برنامه_نویسی, مهندسی]
---

## توضیحات


## نظر


## نظر
 - `امتیاز` : 00/10
 - `به دیگران توصیه می‌کنم` : 
 - `دوباره می‌خوانم` : 
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : Tom Manshreck, Hyrum Wright, Titus Winters
 - `انتشارات` : O'Reilly

## بخش‌هایی از کتاب

## برنامه فصل ۱ (What Is Software Engineering?)

فصل ۱ محورش تفاوت «برنامه‌نویسی» و «مهندسی نرم‌افزار» است؛ سه محور اصلی: زمان، مقیاس، و تصمیم‌گیری/تریدآف‌ها. برای این فصل، این تقسیم را پیشنهاد می‌کنم:

1. بخش ۱: تعریف مهندسی نرم‌افزار و سه مزیت/تفاوت اصلی (زمان، مقیاس، تریدآف‌ها).
2. بخش ۲: محور «زمان و تغییر» و مفهوم طول عمر کد، پروژه‌های کوتاه‌عمر vs بلندمدت، و شروع درد ارتقا.
3. بخش 3: پایداری (sustainability) و این‌که چه زمانی یک پروژه مجبور می‌شود به تغییرات محیط واکنش نشان دهد.
4. بخش ۴: «قانون هایروم» (Hyrum’s Law) و اثراتش روی طراحی API و تغییرات.
5. بخش ۵: جمع‌بندی فصل ۱ و چند سؤال تفکری (متمرکز روی تجربه خودت در پروژه‌های دات‌نت).

## بخش ۱ فصل ۱ – تعریف مهندسی نرم‌افزار

### ایده‌ی مرکزی فصل

کتاب در ابتدای فصل ۱ می‌گوید چیزی که مهندسی نرم‌افزار را از «صرفاً برنامه‌نویسی» جدا می‌کند سه چیز است: زمان، مقیاس، و نوع تصمیم‌هایی که باید بگیری. در یک تمرین دانشگاهی یا اسکریپت یک‌بار مصرف، فقط کافی است «الآن» کار کند، اما در مهندسی نرم‌افزار واقعی باید فکر کنی این سیستم در طول سال‌ها چه تغییری می‌کند، چند نفر روی آن کار خواهند کرد و هر تصمیم امروز چه هزینه‌ای در آینده ایجاد می‌کند.

برای توضیح این تفاوت، نویسنده‌ها از یک جمله درون گوگل استفاده می‌کنند: «مهندسی نرم‌افزار یعنی برنامه‌نویسی که روی محور زمان انتگرال گرفته شده است»؛ یعنی برنامه‌نویسی فقط لحظه تولید نرم‌افزار است، اما مهندسی نرم‌افزار شامل توسعه اولیه، تغییرات بعدی، نگه‌داری، ارتقا و زندگی طولانی‌مدت سیستم است.

### محور «زمان»

یکی از اولین سؤال‌هایی که مطرح می‌شود این است: «طول عمر مورد انتظار کد تو چقدر است؟».
- بعضی کدها چند دقیقه یا چند ساعت عمر دارند (مثلاً یک اسکریپت یک‌باره).
- بعضی کدها باید دهه‌ها زندگی کنند (مثلاً گوگل سرچ، هسته لینوکس، سرورهای مهم).

برای کد کوتاه‌عمر، تغییرات محیط (ورژن زبان، سیستم‌عامل، کتابخانه‌ها) تأثیر چندانی ندارد؛ چون قبل از این‌که آن تغییر برسد، کد دیگر استفاده نمی‌شود. اما هرچه طول عمر نرم‌افزار بیشتر می‌شود، احتمال تغییر وابستگی‌ها، نیازهای کسب‌وکار، معماری و زیرساخت بیشتر می‌شود، و همین جاست که مهندسی نرم‌افزار از برنامه‌نویسی جدا می‌شود.

نویسنده این را به یک مثال هندسی تشبیه می‌کند: همان‌طور که یک مکعب با فشرده شدن در یک بعد به مربع تبدیل می‌شود، یک سیستم نرم‌افزاری که بُعد «زمان» برایش نادیده گرفته شود، در حد یک مسئله‌ی ساده برنامه‌نویسی باقی می‌ماند.

### محور «مقیاس»

محور دوم، مقیاس است: چند نفر درگیرند، چقدر کد وجود دارد و چقدر طول می‌کشد تا از توسعه اولیه فراتر بروی. در یک کار چندروزه انفرادی، بیشتر با مسائل فردی سر و کار داری؛ اما در یک سازمان بزرگ، توسعه نرم‌افزار به یک کار چندنفره، چندنسخه‌ای و بلندمدت تبدیل می‌شود.

کتاب به یک تعریف قدیمی از مهندسی نرم‌افزار اشاره می‌کند: «توسعه چندنفره‌ی برنامه‌های چندنسخه‌ای»؛ یعنی از همان ابتدا مفهوم تیم و نسخه‌نسخه تکامل کد، جزئی از تعریف است. این‌جا عواملی مثل ساختار تیم، سیاست‌های کنترل نسخه، استراتژی تست، فرایند کدریویو و هزینه ارتباطات بین آدم‌ها روی پیچیدگی کار اثر می‌گذارند و با بزرگ‌تر شدن سازمان باید مراقب باشی «هزینه تولید نرم‌افزار» همراه با اندازه سازمان، منفجر نشود.

### محور «تریدآف‌ها و تصمیم‌گیری»

محور سوم، نوع تصمیم‌هایی است که در مقیاس مهندسی نرم‌افزار باید بگیری. در این سطح، معمولاً چند گزینه مختلف پیش رو داری که هرکدام هزینه‌ها و ریسک‌های متفاوت دارند و داده‌هایت هم همیشه کامل یا دقیق نیست؛ باید بین «سرعت»، «کیفیت»، «هزینه»، و «آینده‌پذیری» تعادل برقرار کنی.

نویسنده روی مفهوم «پایداری» تأکید می‌کند: شغل مهندس نرم‌افزار و رهبر فنی این است که سازمان، محصول و فرایند توسعه را طوری مدیریت کنند که در طول زمان بتوانند به تغییرات مهم پاسخ دهند، بدون این‌که سیستم فلج شود. گاهی آگاهانه تصمیم می‌گیری یک بدهی فنی را فعلاً نپردازی یا یک سیاست غیرمقیاس‌پذیر را موقتاً بپذیری، اما باید بدانی بعداً باید به این تصمیم برگردی و هزینه‌اش را بدهی.

### نتیجه بخش ۱ – تفاوت «کد زدن» و «مهندسی»

جمع‌بندی این بخش این است که «مهندسی نرم‌افزار» یعنی:

- فکر کردن به طول عمر کد و امکان تغییر آن در طول سال‌ها، نه فقط لحظه تحویل.
- کار در مقیاس تیم‌ها، سازمان‌ها و سیستم‌های چندنسخه‌ای، نه فقط پروژه فردی.
- تصمیم‌گیری با در نظر گرفتن تریدآف‌ها، پایداری و هزینه‌های آینده، نه فقط رسیدن به خروجی امروز.

از دید کتاب، خیلی از تمرین‌های دانشگاهی، بوت‌کمپ‌ها و حتی بعضی استارتاپ‌ها بیشتر «برنامه‌نویسی» تمرین می‌کنند، در حالی که برای ساخت سیستم‌های ماندگار، باید این سه بُعد (زمان، مقیاس، تریدآف‌ها) را در مرکز کار قرار بدهی.

---

## بخش ۲ فصل ۱ – زمان و تغییر (Time and Change)

### مقدمه: چرا زمان اهمیت دارد؟

یکی از تفاوت‌های بنیادی بین «برنامه‌نویسی» و «مهندسی نرم‌افزار» این است که برنامه‌نویسی لحظه‌ای است، اما مهندسی نرم‌افزار درباره **طول زمان** است. بخش ۲ فصل ۱ تمام بحث را دور این محور می‌چرخاند: اگر کد تو باید ۱۰ سال عمر کند، نه فقط ۱۰ روز، همه چیز تغییر می‌کند.

### سطح ابتدایی: کجا از کجا درست شروع کنیم؟

برای شروع، کتاب از این سؤال شروع می‌کند: **«طول عمر مورد انتظار کد تو چقدر است؟»**

جواب این سؤال می‌تواند چیزی از چند دقیقه تا چند دهه باشد. نویسنده‌ها می‌گویند این تفاوت حدود **۱۰۰,۰۰۰ برابر** است! یعنی:

- **کد کوتاه‌عمر:** یک اسکریپت تک‌بار مصرف، یک ابزار برای یک جلسه، یک آزمایش ریاضی.
- **کد بلندمدت:** سیستم‌های اصلی گوگل (مثل Google Search)، هسته لینوکس، زیرساخت‌های کریتیکل.

**اینجا کلید است:** برای کد کوتاه‌عمر (مثل یک اسکریپت ۲ ساعتی)، توجه نکردن به تغییرات محیط (ورژن پایتون، سیستم‌عامل) ریسک نیست چون **قبل از این که آن تغییر برسد، کد هم‌چنان استفاده نمی‌شود.** اما برای کد بلندمدت، گذشت زمان معنی‌ش این است که **تقریباً همه وابستگی‌ها (dependency) تغییر خواهند کرد.**

### مثال عملی: کتابخانه‌ها و سیستم‌عامل‌ها

فرض کن دات‌نت پروژه‌ای نوشتی که از کتابخانه‌ی `X` استفاده می‌کند و آن کتابخانه برای ۶ ماه آینده کافی است. خوب است، مشکلی نیست.

اما اگر این پروژه باید ۵ سال زندگی کند؟ در این ۵ سال:

- کتابخانه‌ی `X` ۵ یا ۶ بار نسخه اپدیت می‌شود.
- مایکروسافت شاید `.NET` رو از `.NET 6` به `.NET 12` و `.NET 15` ارتقا دهد.
- سیستم‌عامل‌های محیط اجرایی (Windows Server) تغییر می‌کند.
- احتمالاً یک patch امنیتی عمومی (مثل Heartbleed در OpenSSL) اتفاق می‌افتد و **باید آپدیت کنی.**

هرچه مدت زمان بیشتر‌تر باشد، احتمال تغییر **نمایی** بالا می‌رود، نه خطی.

### درک نقطه‌ی اول: تفاوت «کار می‌کند» و «قابل نگهداری است»

این یکی از بخش‌های مهم‌تر است.

شاید کد تو الآن «کار می‌کند»: تست‌ها پاس می‌کنند، فیچر‌ها کار می‌کنند، یوزر‌ها خوشحال‌اند. اما **آیا این کد زمانی که نسخه جدید کتابخانه‌ی `X` منتشر شود، هنوز هم قابل نگهداری است؟** اینجا است که مسئله دوم شروع می‌شود: تفاوت بین **«همین‌الان کار می‌کند» (works now)** و **«برای سال‌ها می‌توانم تغییرش بدم» (is maintainable).**

برای کد **کوتاه‌عمر،** این تفاوت مهم نیست. برای کد **بلندمدت،** بسیار مهم است.

### مثال: انتقال از نسخه‌ای موقتی و غیرمستقیم

اگر پروژه‌ات کوتاه‌عمر است و کد پر از ترفندها است (مثلاً نوشتن چند خط hack کوتاه‌مدت)، **شاید خوب است.** سریع و کار می‌کند.

اما اگر همین کد بعد از ۳ سال هنوز در production است و دیگر تیم‌ها هم وابسته‌اند؟ حالا **هر ترفند می‌تواند یک بمب وقت‌گذار شود.** کسی برای fix کردن‌اش، باید تمام context را دوباره یاد بگیرد.

### پایداری (Sustainability): کلید مهندسی نرم‌افزار

نویسنده‌ها یک تعریف کلیدی می‌دهند:

> **پروژه‌ی شما پایدار است اگر برای طول عمر مورد انتظار نرم‌افزارتان، شما توانایی واکنش به تغییرات ارزشمند را داشته باشید، چه بخاطر دلایل فنی یا کسب‌وکاری.**

توجه کن: این **توانایی** است، نه **اجبار.** ممکن است تصمیم بگیری که یک upgrade را نکنی چون ارزش ندارد. اما بدانی **توانایی** آن را داری.

اگر **نتوانی** upgrade کنی یا تغییر بدهی؟ آن‌وقت **ریسک بالا** می‌گیری: که امیدواری می‌کنی هیچ چیز critical تغییر نشود. برای پروژه‌های کوتاه‌عمر این bet ایمن است، اما برای دهه‌ها؟ نه.

### نمودار: طول عمر و اهمیت upgrade

کتاب یک نمودار دارد (Figure 1-1) که نشان می‌دهد:

- **کد کوتاه‌عمر:** upgrade ضروری نیست
- **کد بلندمدت:** upgrade کریتیکال است

بین این دو، **انتقال** اتفاق می‌افتد. تقریباً **بین ۵ تا ۱۰ سال** است که یک پروژه باید شروع به واکنش به تغییرات کند.

### مسئله‌ی «اولین upgrade»: اینجا درد است

اگر پروژه‌ای از ابتدا برای upgrade ریخته نشده باشد، **اولین upgrade خیلی درد‌ناک است** و سه دلیل دارد:

۱. **Task جدید است:** تا الآن هیچ کسی upgrade نکرده. فرض‌های زیادی در کد مخفی شده‌اند.

۲. **Experience کم:** مهندس‌های فعلی شاید هیچ‌گاه upgrade نکرده‌اند و نمی‌دانند چکار باید کنند.

۳. **Size بزرگ:** نه یک سال upgrade، بلکه **۵ سال upgrade یک‌باره** (چون ۵ سال missed کردی!).

### نتیجه‌ی درد‌ناک: «دوباره نه»

بعد از یک upgrade دردناک، مهندسان اغلب **تصمیم می‌گیرند «دوباره هرگز نه»** و یا **تصمیم می‌گیرند تمام چیز را دوباره بنویسند.** ولی این تصمیمات **مشکل را بزرگ‌تر می‌کند،** نه کوچک‌تر.

حل درست این است: **سرمایه‌گذاری کن که upgrade را سهل‌تر کنی.** اگر ۱ سال یک‌بار ۱۰ روز upgrade می‌کند (چه منطقی‌تر است)، **درد نیست. رویتین است.**

### تجربه‌ی Google: Compiler Upgrade ۲۰۰۶

کتاب یک مثال واقعی می‌دهد. Google برای سال‌های زیادی compiler خود را upgrade نکرده بود. وقتی **ناچار شدند** (چون compiler قدیمی شد)، اول‌اش **خیلی درد‌ناک بود:**

- هزاران مهندس
- میلیون‌ها خط کد
- هیچ کسی experience نداشت
- Hyrum's Law (که بعداً می‌رسیم) تمام فرض‌های مخفی را غافل‌گیر کرد

### خلاصه‌ی بخش ۲

**محور `زمان`** کل تفاوت بین برنامه‌نویسی و مهندسی نرم‌افزار است. اگر کد طولانی‌مدت نیست، شاید ترفندها خوب است. اما اگر طولانی‌مدت است، **باید تفکر کنی درباره‌ی پایداری (sustainability):** آیا می‌توانم این کد را بعد از ۵ سال upgrade کنم؟ اگر جواب «نه» است، **اینجا مشکل است.**

کلید این است: **اولین upgrade سخت است، اما اگر منظم برنامه‌ریزی کنی، هر upgrade بعدی آسان‌تر می‌شود.**

---

## بخش ۳ فصل ۱ – قانون هایروم (Hyrum's Law)

### مقدمه: از «کار می‌کند» تا «قابل نگهداری است»

شاید تا حالا فکر می‌کردی که اگر کد تو مطابق API contract باشد، همه چیز خوب است. **اینجا به رسمیت شناخته می‌شود که این فرض غلط است.** قانون هایروم یک عمل ساده اما قدرتمند است که به خصوص برای پروژه‌های طولانی‌مدت حیاتی است.

### تعریف رسمی: قانون هایروم

> **اگر یک API تعداد کافی از کاربران داشته باشد، مهم نیست که چه چیز وعده می‌دهی در contract: تمام رفتارهای observable سیستم تو، توسط کسی وابسته خواهند شد.**

یعنی؟ یعنی این که **حتی رفتارهایی که قصد نداشتی expose کنی، یا حتی رفتارهایی که ناقص یا undefined هستند، کسی در project خود وابسته‌اش می‌کند.** وقتی بخواهی آن رفتار را تغییر بدهی (چه خیلی منطقی باشد)، **breaking change است و کل ecosystem تو صدمه می‌خوره.**

### ربط به پایداری و زمان

نویسنده‌ها این قانون را با **Entropy** مقایسه می‌کنند. همان‌طور که آنتروپی هرگز کاهش نمی‌یابد (ترمودینامیک)، Hyrum's Law هم هرگز نمی‌شود "حل شود." فقط می‌توانی آن را کاهش بدهی، نه حذف.

اینجا **اهمیت زمان** دوباره ظاهر می‌شود:
- اگر کد **کوتاه‌عمر** باشد، اهمیتش کم است.
- اگر کد **بلندمدت** باشد، هر رفتار observable (حتی تصادفی) احتمال‌اً کسی وابسته‌اش می‌شود.

### مثال عملی: Hash Ordering

کتاب یک مثال خیلی خوب می‌دهد: **ترتیب‌دهی Hash Table.**

تصور کن: اگر ۵ عنصر را در یک `set` قرار بدهی، به چه ترتیبی بیرون می‌آید؟

```python
for i in {"apple", "banana", "carrot", "durian", "eggplant"}: 
    print(i)
# Output:
# durian
# carrot  
# apple
# eggplant
# banana
```

حالا، هر programmer می‌داند که hash table ترتیب خاصی ندارد. اما **در عمل چه اتفاق می‌افتد؟**

اگر کد تو **۱۰ سال** عمر بکند:
- یک programmer، کدی می‌نویسد که **وابسته این ترتیب است** (شاید بدون دانستن!).
- یک programmer دیگر، از library تو استفاده می‌کند و نتایج را serialize می‌کند (مثلاً برای RPC response).
- Client آن RPC، حالا **وابسته ترتیب موجود است** (چه اینکه documented نبوده!).

### مثال واقعی: چرا این اتفاق می‌افتد؟

نویسنده‌ها ۳ دلیل می‌دهند که چرا hash ordering می‌تواند **تغییر کند:**

۱. **Hash Flooding attacks:** اگر کسی بخواهد سیستم تو را attack کند، ترتیب deterministic hash خطرناک است.

۲. **بهبود الگوریتم:** محققان الگوریتم‌های بهتر hash می‌یابند; اگر بخواهی آن‌ها استفاده کنی، ترتیب تغییر می‌کند.

۳. **Hyrum's Law:** اگر اسلحه‌ی جنگی hash ordering را ببینی، **حتماً کسی براش استفاده خواهد کرد.**

### سطح تحلیل: «درست است» در مقابل «کار می‌کند»

اینجا **فرق عمیق** آمد:

- برای **کد کوتاه‌عمر:** وابستگی بر ترتیب hash problem نیست; هر دو چیز (کد تو و hash implementation) با هم زندگی می‌کنند و می‌میرند.

- برای **کد بلندمدت:** وابستگی بر ترتیب **risk است.** اگر ۵ سال بعد قصد کنی hash implementation تغییر بدهی:
  - باید **تمام کد dependent** را پیدا کنی (شاید dozens یا hundreds جا).
  - هر کدام **broken است** و باید fix شود.
  - هر کدام **تست نیاز دارد** تا مطمئن شوی خراب نشده.

### تفاوت بین «hacky» و «clean»

نویسنده‌ها این تفاوت را خوب خلاصه می‌کنند:

> **«It's programming if 'clever' is a compliment, but it's software engineering if 'clever' is an accusation.»**

یعنی:

- **برنامه‌نویسی کوتاه‌عمر:** «clever» = خوب! "جالب، حسابی کاملاً بهینه است!"

- **مهندسی نرم‌افزار بلندمدت:** «clever» = بدی! "این کد خیلی پر ترفند است؛ کسی بعداً نمی‌خواهد با این کار کند."

### راه‌حل: آیا می‌تونیم چیزها را «ثابت» کنیم؟

سؤال منطقی: **آیا می‌تونیم یک API بسازیم که هیچ چیز تغییر نکند؟**

جواب: **برای بیشتر پروژه‌ها، نه.**

چرا؟

۱. **مسائل امنیتی:** Heartbleed، Meltdown، Spectre - حتی اگر کد خوب بنویسی، dependencies تو vulnerability داشتند. **باید patch کنی.**

۲. **بهبود عملکرد:** الگوریتم‌های CPU از دهه ۱۹۹۰ تغییر کردند. Linked-list یا Binary search tree هنوز کار می‌کنند، اما **خیلی slow هستند** برای hardware امروز.

۳. **تکامل ناشناخته:** حتی اگر **اشتباه نشده باشی**، گذشت زمان و تکامل technology واپس‌ایی "ترجیح بهتر" را می‌آورد.

### خلاصه بخش ۳: Hyrum's Law و عملیات

Hyrum's Law یعنی:

1. **تمام رفتارهای observable** توسط کسی وابسته‌اند، نه فقط documented ones.

2. **هرچه کد طولانی‌تر زندگی کند، احتمال وابستگی بیشتر است.**

3. **نمی‌توانی این را حذف کنی، فقط می‌توانی آن را بدتر یا بهتر مدیریت کنی.**

4. **در «برنامه‌نویسی»:** ترفند و clever خوب است.  
   **در «مهندسی نرم‌افزار»:** ترفند یک بمب وقت‌گذار است.

---

## بخش ۴ فصل ۱ – مقیاس و کارایی (Scale and Efficiency)

### مقدمه: محور دوم مهندسی نرم‌افزار

تا اینجا درباره‌ی محور **«زمان»** صحبت کردیم. حالا به محور دوم می‌رسیم: **«مقیاس»** (Scale). اگر فقط یک نفر است، بسیاری از مسائل شاید خودبخود حل شوند. اما وقتی سازمان بزرگ شود و صدها یا هزاران مهندس وارد شوند، **هزینه‌های پنهان بزرگ می‌شود** و باید کار را متفاوت انجام دهی.

### سوال بنیادی: مقیاس‌پذیری

سوال اساسی این است:

> **«آیا سازمان تو هرچه بزرگ‌تر شود، هم‌زمان در تولید نرم‌افزار کارآمدتر می‌شود؟ یا هزینه‌ها به همان نسبت بالا می‌روند؟»**

یعنی اگر فقط ۱۰ مهندس داری، شاید برای یک فرایند ۵ ساعت لازم است. اگر ۱۰۰ مهندس داری، آیا ۵۰ ساعت لازم است (linear scale)؟ یا ۵۰۰ ساعت (superlinear، بدتر از خطی)؟ یا شاید ۲۵ ساعت (بهتر شده، sublinear)؟

**مقیاس‌پذیری مثبت** یعنی این که هزینه را بر اساس تعداد نمی‌شمارند؛ بلکه **هم‌چنان ثابت** می‌مانند یا حتی **کاهش می‌یابند.**

### سه منبع موارد نیاز برای مقیاس

کتاب سه حوزه را نام می‌برد که باید مقیاس‌پذیر باشند:

**۱. هزینه‌های انسانی (Human Costs)**

اگر هر بار سازمان تو ۲ برابر شود، آیا تمام کارهایی که تکرار می‌شود (مثل code review، testing، refactoring) هم ۲ برابر می‌شود؟ **این مشکل است.**

مثال: اگر تو **۱۰۰ مهندس** داری و **۱۰۰۰ مهندس** شوی، آیا هزینه code review ۱۰ برابر می‌شود؟ اگر جواب بله است، این **superlinear scaling problem** است و نمی‌تونی اینطور ادامه بدهی.

**۲. منابع محاسباتی (Computational Resources)**

Build time، test time، version control operations - اگر اینها هر دفعه سازمان بزرگ‌تر شود superlinearly بالا بروند، **مشکل است.**

**۳. اصول کدبیس (The Codebase Itself)**

اگر build time، git clone time، یا هزینه upgrade language version **superlinear بالا رود**، در نهایت **به نقطه‌ای می‌رسی که نمی‌تونی حرکت کنی** (boiled frog problem).

### مثال ۱: Deprecation – سیاستی که مقیاس ندارد

کتاب یک مثال واضح می‌دهد: **deprecation کردن یک Widget.**

**رویکرد ساده (small team):**
- تصمیم: "Widget قدیمی را می‌حذفیم در ۱۵ اگست"
- نتیجه: هر تیم خود‌بخود کار را انجام می‌دهد و migration می‌کند.
- مشکل: نسبتاً خوب کار می‌کند.

**با رشد سازمان:**
- حالا **صدها Widget وجود دارد** و **هزاران وابستگی**
- هر تیم باید تمام Widgets خود را migrate کند (superlinear work)
- **۱ error شامل ۲۰% تیم‌های سازمان می‌شود**
- **کل فرایند broken است** و نمقیاس‌پذیر است.

**حل Google: Churn Rule**

بجای اینکه مسئولیت را به teams push کنی، infrastructure team خود این کار را انجام می‌دهد (یا backward-compatible می‌کند):

✅ **مقیاس‌پذیر است** چون:
- فقط تیم infrastructure با artifact سر و کار دارد
- Dependent projects بدون کار بیشتری می‌روند
- Expertise در یک جا concentrated است

> **نتیجه: Expertise و centralization scale بیشتری دارد تا decentralized work distribution.**

### مثال ۲: Development Branches – سیاستی که مقیاس ندارد

**رویکرد ساده:**
- ۵ تا ۱۰ development branch داری.
- هر branch merge شدن expensive work می‌شود (resyncing و testing).
- برای small team: OK است.

**با رشد:**
- حالا **۱۰۰ branch یا بیشتر** داری
- هر merge بالقوه **۹۹ branch دیگر** را تحت تأثیر می‌گذارد
- سربار merge **exponentially بالا می‌رود**

**حل: Monorepo + Trunk-Based Development** (فصل بعدی در کتاب)

### مثال عملی: Compiler Upgrade - تجربه Google ۲۰۰۶

کتاب یک مثال تاریخی خیلی معنادار می‌دهد: **اولین compiler upgrade بزرگ Google.**

**وضعیت:**
- **صدها تیم**
- **millions خط کد**
- **۵ سال بدون compiler update**
- **اکثر engineers هیچ compiler change نکرده بودند**

**نتیجه:**
- **Extremely painful**
- **Hyrum's Law** تمام implicit dependencies آشکار کرد
- **۳ دلیل برای درد:**
  - Task جدید بود
  - Experience نبود
  - Size بزرگ (۵ سال upgrade یکباره)

**حل Google: تغییر سیاست و فرایند**

بعد از درس سخت، Google روی ۵ عامل کار کرد:

| عامل | توضیح |
|------|--------|
| **Expertise** | اول compiler upgrade difficult است؛ ۱۰۰ها بار انجام دادن آن را routine می‌کند |
| **Stability** | اگر هر ۱ هفته compiler update کنی (بجای ۵ سال)، delta کوچک است |
| **Conformity** | زمانی که کد regularly upgrade می‌شود، brittle behavior کم می‌شود |
| **Familiarity** | با تکرار، شاید فرایند را بتوانی automate کنی |
| **Policy** | مثل "Beyoncé Rule" (اگر CI test نگذاشتی، infrastructure fault نیست) |

**نتیجه:**
- از **۱۰۰+ engineers volunteer** به **constant engineers** برای perform کردن task
- حتی هر sizebase grow کند، human effort **constant باقی ماند** (linear scaling!)

### Beyoncé Rule: سیاستی که مقیاس‌پذیر است

> **«If you liked it, you should have put a CI test on it»**

**معنی:**
- اگر infrastructure change باعث bug شد اما CI test آن را گرفت نشد، **infrastructure fault نیست.**
- This protects infrastructure teams از **tracking down every bespoke test دیگر تیم‌ها.**

**چرا scale می‌کند؟**
- بدون این rule: infrastructure engineer باید هر تیم رو پیدا کند و آنها رو test کند (impossible)
- با این rule: فقط tests داخل CI count می‌شود (centralized، scalable)

**نتیجه:**
- ✅ Infrastructure teams می‌توانند upgrade انجام دهند **بدون دسترسی به تمام bespoke tests**
- ✅ Dependent teams مسئول هستند که tests خود را **در CI قرار دهند** (accountability shift)

### Shifting Left: سیاست درست انجام کار

نویسنده‌ها یک اصل کلی معرفی می‌کنند:

> **مشکلات را هرچه بیشتر به سمت «چپ» (early) developer workflow حرکت دهند، **هزینه کم‌تری دارد.**

**Timeline developer:**
- Design → Implementation → Code Review → Testing → Commit → Canary → Production

**Shifting Left:**
- مسائل را **در Design phase** catch کنید: Cheapest
- **Code review سریع:** Cheap
- **در Production:** Expensive

**چرا؟** چون developer هنوز کد در mind دارد، تغییرش سریع است. اگر ۶ ماه منتظر شوی، دیگر هیچ کسی نمی‌دانند code چکار می‌کند.

### خلاصه بخش ۴

**محور مقیاس:**

۱. **Superlinear costs are death:** اگر هر دفعه سازمان ۱۰ برابر شود، کار تو ۱۰۰ برابر می‌شود، **پایدار نیست.**

۲. **Centralize expertise:** بجای اینکه ۱۰۰ تیم individually کار کنند، centralize expertise و **economies of scale** از آن بگیر.

۳. **Policy > Procedure:** درست سیاست‌های کارآمد می‌کند (Beyoncé Rule) تا هر فرایند اضافی نیز مقیاس ندارد.

۴. **Shifting left:** Catch مشکلات زودتر = کارایی بیشتر.

---

