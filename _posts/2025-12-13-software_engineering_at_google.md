---
layout: post
full-width: true
title: Software Engineering at Google
subtitle: Lessons Learned from Programming Over Time
cover-img: /assets/images/software_engineering_at_google.jpg
thumbnail-img: /assets/images/software_engineering_at_google.jpg
share-img: /assets/images/software_engineering_at_google.jpg
tags: [کتاب, برنامه_نویسی, مهندسی]
---

## توضیحات


## نظر


## نظر
 - `امتیاز` : 00/10
 - `به دیگران توصیه می‌کنم` : 
 - `دوباره می‌خوانم` : 
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : Tom Manshreck, Hyrum Wright, Titus Winters
 - `انتشارات` : O'Reilly

## بخش‌هایی از کتاب

## برنامه فصل ۱ (What Is Software Engineering?)

فصل ۱ محورش تفاوت «برنامه‌نویسی» و «مهندسی نرم‌افزار» است؛ سه محور اصلی: زمان، مقیاس، و تصمیم‌گیری/تریدآف‌ها. برای این فصل، این تقسیم را پیشنهاد می‌کنم:

1. بخش ۱: تعریف مهندسی نرم‌افزار و سه مزیت/تفاوت اصلی (زمان، مقیاس، تریدآف‌ها).
2. بخش ۲: محور «زمان و تغییر» و مفهوم طول عمر کد، پروژه‌های کوتاه‌عمر vs بلندمدت، و شروع درد ارتقا.
3. بخش 3: پایداری (sustainability) و این‌که چه زمانی یک پروژه مجبور می‌شود به تغییرات محیط واکنش نشان دهد.
4. بخش ۴: «قانون هایروم» (Hyrum’s Law) و اثراتش روی طراحی API و تغییرات.
5. بخش ۵: جمع‌بندی فصل ۱ و چند سؤال تفکری (متمرکز روی تجربه خودت در پروژه‌های دات‌نت).

در این پیام، فقط «بخش ۱» را برای مطالعه می‌فرستم؛ اگر اوکی بود، در پیام بعدی می‌رویم سراغ بخش ۲.

## بخش ۱ فصل ۱ – تعریف مهندسی نرم‌افزار

### ایده‌ی مرکزی فصل

کتاب در ابتدای فصل ۱ می‌گوید چیزی که مهندسی نرم‌افزار را از «صرفاً برنامه‌نویسی» جدا می‌کند سه چیز است: زمان، مقیاس، و نوع تصمیم‌هایی که باید بگیری. در یک تمرین دانشگاهی یا اسکریپت یک‌بار مصرف، فقط کافی است «الآن» کار کند، اما در مهندسی نرم‌افزار واقعی باید فکر کنی این سیستم در طول سال‌ها چه تغییری می‌کند، چند نفر روی آن کار خواهند کرد و هر تصمیم امروز چه هزینه‌ای در آینده ایجاد می‌کند.

برای توضیح این تفاوت، نویسنده‌ها از یک جمله درون گوگل استفاده می‌کنند: «مهندسی نرم‌افزار یعنی برنامه‌نویسی که روی محور زمان انتگرال گرفته شده است»؛ یعنی برنامه‌نویسی فقط لحظه تولید نرم‌افزار است، اما مهندسی نرم‌افزار شامل توسعه اولیه، تغییرات بعدی، نگه‌داری، ارتقا و زندگی طولانی‌مدت سیستم است.

### محور «زمان»

یکی از اولین سؤال‌هایی که مطرح می‌شود این است: «طول عمر مورد انتظار کد تو چقدر است؟».
- بعضی کدها چند دقیقه یا چند ساعت عمر دارند (مثلاً یک اسکریپت یک‌باره).
- بعضی کدها باید دهه‌ها زندگی کنند (مثلاً گوگل سرچ، هسته لینوکس، سرورهای مهم).

برای کد کوتاه‌عمر، تغییرات محیط (ورژن زبان، سیستم‌عامل، کتابخانه‌ها) تأثیر چندانی ندارد؛ چون قبل از این‌که آن تغییر برسد، کد دیگر استفاده نمی‌شود. اما هرچه طول عمر نرم‌افزار بیشتر می‌شود، احتمال تغییر وابستگی‌ها، نیازهای کسب‌وکار، معماری و زیرساخت بیشتر می‌شود، و همین جاست که مهندسی نرم‌افزار از برنامه‌نویسی جدا می‌شود.

نویسنده این را به یک مثال هندسی تشبیه می‌کند: همان‌طور که یک مکعب با فشرده شدن در یک بعد به مربع تبدیل می‌شود، یک سیستم نرم‌افزاری که بُعد «زمان» برایش نادیده گرفته شود، در حد یک مسئله‌ی ساده برنامه‌نویسی باقی می‌ماند.

### محور «مقیاس»

محور دوم، مقیاس است: چند نفر درگیرند، چقدر کد وجود دارد و چقدر طول می‌کشد تا از توسعه اولیه فراتر بروی. در یک کار چندروزه انفرادی، بیشتر با مسائل فردی سر و کار داری؛ اما در یک سازمان بزرگ، توسعه نرم‌افزار به یک کار چندنفره، چندنسخه‌ای و بلندمدت تبدیل می‌شود.

کتاب به یک تعریف قدیمی از مهندسی نرم‌افزار اشاره می‌کند: «توسعه چندنفره‌ی برنامه‌های چندنسخه‌ای»؛ یعنی از همان ابتدا مفهوم تیم و نسخه‌نسخه تکامل کد، جزئی از تعریف است. این‌جا عواملی مثل ساختار تیم، سیاست‌های کنترل نسخه، استراتژی تست، فرایند کدریویو و هزینه ارتباطات بین آدم‌ها روی پیچیدگی کار اثر می‌گذارند و با بزرگ‌تر شدن سازمان باید مراقب باشی «هزینه تولید نرم‌افزار» همراه با اندازه سازمان، منفجر نشود.

### محور «تریدآف‌ها و تصمیم‌گیری»

محور سوم، نوع تصمیم‌هایی است که در مقیاس مهندسی نرم‌افزار باید بگیری. در این سطح، معمولاً چند گزینه مختلف پیش رو داری که هرکدام هزینه‌ها و ریسک‌های متفاوت دارند و داده‌هایت هم همیشه کامل یا دقیق نیست؛ باید بین «سرعت»، «کیفیت»، «هزینه»، و «آینده‌پذیری» تعادل برقرار کنی.

نویسنده روی مفهوم «پایداری» تأکید می‌کند: شغل مهندس نرم‌افزار و رهبر فنی این است که سازمان، محصول و فرایند توسعه را طوری مدیریت کنند که در طول زمان بتوانند به تغییرات مهم پاسخ دهند، بدون این‌که سیستم فلج شود. گاهی آگاهانه تصمیم می‌گیری یک بدهی فنی را فعلاً نپردازی یا یک سیاست غیرمقیاس‌پذیر را موقتاً بپذیری، اما باید بدانی بعداً باید به این تصمیم برگردی و هزینه‌اش را بدهی.

### نتیجه بخش ۱ – تفاوت «کد زدن» و «مهندسی»

جمع‌بندی این بخش این است که «مهندسی نرم‌افزار» یعنی:

- فکر کردن به طول عمر کد و امکان تغییر آن در طول سال‌ها، نه فقط لحظه تحویل.
- کار در مقیاس تیم‌ها، سازمان‌ها و سیستم‌های چندنسخه‌ای، نه فقط پروژه فردی.
- تصمیم‌گیری با در نظر گرفتن تریدآف‌ها، پایداری و هزینه‌های آینده، نه فقط رسیدن به خروجی امروز.

از دید کتاب، خیلی از تمرین‌های دانشگاهی، بوت‌کمپ‌ها و حتی بعضی استارتاپ‌ها بیشتر «برنامه‌نویسی» تمرین می‌کنند، در حالی که برای ساخت سیستم‌های ماندگار، باید این سه بُعد (زمان، مقیاس، تریدآف‌ها) را در مرکز کار قرار بدهی.

---

