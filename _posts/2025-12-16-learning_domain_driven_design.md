---
layout: post
full-width: true
title: Learning Domain Driven Design
subtitle: Aligning Software Architecture and Business Strategy
cover-img: /assets/images/learning_domain_driven_design.jpg
thumbnail-img: /assets/images/learning_domain_driven_design.jpg
share-img: /assets/images/learning_domain_driven_design.jpg
tags: [کتاب, مهندسی, برنامه_نویسی]
---

## توضیحات


## نظر


## نظر
 - `امتیاز` : 00/10
 - `به دیگران توصیه می‌کنم` : 
 - `دوباره می‌خوانم` : 
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : 
 - `انتشارات` : 

## بخش‌هایی از کتاب

# فصل اول: تحلیل حوزه‌های کسب‌وکار

## حوزه کسب‌وکار چیست؟

حوزه کسب‌وکار (Business Domain) حوزه اصلی فعالیت یک شرکت را تعریف می‌کند. به طور کلی، این خدمتی است که شرکت به مشتریان خود ارائه می‌دهد. به عنوان مثال:

- **FedEx** خدمات پست پیشتاز ارائه می‌دهد
- **Starbucks** بیشتر به خاطر قهوه‌اش شناخته می‌شود
- **Walmart** یکی از شناخته‌شده‌ترین فروشگاه‌های خرده‌فروشی است

یک شرکت می‌تواند در چندین حوزه کسب‌وکار فعالیت کند. به عنوان مثال، آمازون هم خدمات خرده‌فروشی و هم خدمات رایانش ابری ارائه می‌دهد. اوبر یک شرکت اشتراک‌گذاری سواری است که همچنین خدمات تحویل غذا و اشتراک‌گذاری دوچرخه را ارائه می‌دهد.

نکته مهم این است که شرکت‌ها ممکن است اغلب حوزه‌های کسب‌وکار خود را تغییر دهند. یک نمونه کلاسیک از این موضوع نوکیا است که در طول سال‌ها در زمینه‌های متنوعی مانند پردازش چوب، تولید لاستیک، مخابرات و ارتباطات تلفن همراه فعالیت کرده است.

## زیردامنه چیست؟

برای دستیابی به اهداف حوزه کسب‌وکار خود، یک شرکت باید در چندین **زیردامنه** (Subdomain) عمل کند. زیردامنه یک حوزه دقیق‌تر از فعالیت کسب‌وکار است. تمام زیردامنه‌های یک شرکت، حوزه کسب‌وکار آن را تشکیل می‌دهند: خدمتی که به مشتریان خود ارائه می‌دهد.

پیاده‌سازی یک زیردامنه واحد برای موفقیت یک شرکت کافی نیست؛ این فقط یک بلوک سازنده در سیستم کلی است. زیردامنه‌ها باید با یکدیگر تعامل کنند تا به اهداف شرکت در حوزه کسب‌وکارش برسند. 

به عنوان مثال، استارباکس ممکن است بیشتر به خاطر قهوه‌اش شناخته شود، اما ساخت یک زنجیره کافی‌شاپ موفق نیازمند بیش از دانستن نحوه تهیه قهوه عالی است. شما همچنین باید املاک را در مکان‌های مؤثر خریداری یا اجاره کنید، پرسنل استخدام کنید، امور مالی را مدیریت کنید و از جمله سایر فعالیت‌ها. هیچ‌یک از این زیردامنه‌ها به تنهایی یک شرکت سودآور نمی‌سازد. همه آن‌ها با هم برای اینکه شرکت بتواند در حوزه(های) کسب‌وکار خود رقابت کند، ضروری هستند.

## انواع زیردامنه‌ها

درست همانطور که یک سیستم نرم‌افزاری از اجزای معماری مختلف تشکیل شده است—پایگاه‌های داده، برنامه‌های فرانت‌اند، سرویس‌های بک‌اند و غیره—زیردامنه‌ها ارزش‌های استراتژیک/کسب‌وکاری متفاوتی دارند. طراحی مبتنی بر دامنه بین سه نوع زیردامنه تمایز قائل می‌شود: **اصلی** (Core)، **عمومی** (Generic) و **پشتیبان** (Supporting). بیایید ببینیم از دیدگاه استراتژی شرکت چگونه با هم متفاوت هستند.

### زیردامنه‌های اصلی (Core Subdomains)

زیردامنه اصلی چیزی است که یک شرکت متفاوت از رقبایش انجام می‌دهد. این ممکن است شامل اختراع محصولات یا خدمات جدید یا کاهش هزینه‌ها از طریق بهینه‌سازی فرآیندهای موجود باشد.

بیایید اوبر را به عنوان مثال در نظر بگیریم. در ابتدا، شرکت شکل جدیدی از حمل‌ونقل ارائه کرد: اشتراک‌گذاری سواری. با اینکه رقبایش به آن رسیدند، اوبر راه‌هایی برای بهینه‌سازی و تکامل کسب‌وکار اصلی خود پیدا کرد: به عنوان مثال، کاهش هزینه‌ها با تطبیق مسافرانی که به سمت یک جهت می‌روند.

زیردامنه‌های اصلی اوبر بر سود خالص آن تأثیر می‌گذارد. اینگونه است که شرکت خود را از رقبایش متمایز می‌کند. این استراتژی شرکت برای ارائه خدمات بهتر به مشتریان و/یا به حداکثر رساندن سودآوری خود است. برای حفظ مزیت رقابتی، زیردامنه‌های اصلی شامل اختراعات، بهینه‌سازی‌های هوشمند، دانش کسب‌وکار یا سایر مالکیت‌های فکری است.

**پیچیدگی**: یک زیردامنه اصلی که پیاده‌سازی آن ساده باشد تنها می‌تواند یک مزیت رقابتی کوتاه‌مدت فراهم کند. بنابراین، زیردامنه‌های اصلی به طور طبیعی پیچیده هستند. برای کسب‌وکار اصلی یک شرکت باید موانع ورود بالایی وجود داشته باشد؛ باید برای رقبا سخت باشد که راه‌حل شرکت را کپی یا تقلید کنند.

**منابع مزیت رقابتی**: مهم است که توجه کنید زیردامنه‌های اصلی لزوماً فنی نیستند. همه مشکلات کسب‌وکار از طریق الگوریتم‌ها یا سایر راه‌حل‌های فنی حل نمی‌شوند. مزیت رقابتی یک شرکت می‌تواند از منابع مختلفی ناشی شود.

### زیردامنه‌های عمومی (Generic Subdomains)

زیردامنه‌های عمومی فعالیت‌های کسب‌وکاری هستند که همه شرکت‌ها به همان روش انجام می‌دهند. مانند زیردامنه‌های اصلی، زیردامنه‌های عمومی به طور کلی پیچیده و سخت برای پیاده‌سازی هستند. با این حال، زیردامنه‌های عمومی هیچ مزیت رقابتی برای شرکت فراهم نمی‌کنند. نیازی به نوآوری یا بهینه‌سازی در اینجا نیست: پیاده‌سازی‌های آزموده‌شده به طور گسترده در دسترس هستند و همه شرکت‌ها از آن‌ها استفاده می‌کنند.

به عنوان مثال، بیشتر سیستم‌ها نیاز به احراز هویت و مجوزدهی کاربران خود دارند. به جای اختراع یک مکانیسم احراز هویت اختصاصی، منطقی‌تر است که از یک راه‌حل موجود استفاده شود. چنین راه‌حلی احتمالاً قابل اعتمادتر و امن‌تر خواهد بود چون قبلاً توسط بسیاری از شرکت‌های دیگر که نیازهای مشابهی دارند آزمایش شده است.

### زیردامنه‌های پشتیبان (Supporting Subdomains)

همانطور که از نام آن پیداست، زیردامنه‌های پشتیبان از کسب‌وکار شرکت پشتیبانی می‌کنند. با این حال، برخلاف زیردامنه‌های اصلی، زیردامنه‌های پشتیبان هیچ مزیت رقابتی ارائه نمی‌دهند.

به عنوان مثال، یک شرکت تبلیغات آنلاین را در نظر بگیرید که زیردامنه‌های اصلی آن شامل تطبیق تبلیغات با بازدیدکنندگان، بهینه‌سازی اثربخشی تبلیغات و به حداقل رساندن هزینه فضای تبلیغاتی است. با این حال، برای موفقیت در این زمینه‌ها، شرکت نیاز به فهرست‌بندی مواد خلاقانه خود دارد. نحوه ذخیره و نمایه‌سازی مواد خلاقانه فیزیکی مانند بنرها و صفحات فرود بر سود شرکت تأثیری ندارد. چیزی برای اختراع یا بهینه‌سازی در آن زمینه وجود ندارد. از طرف دیگر، کاتالوگ خلاقانه برای پیاده‌سازی سیستم‌های مدیریت تبلیغات و ارائه شرکت ضروری است. این امر راه‌حل فهرست‌بندی محتوا را به یکی از زیردامنه‌های پشتیبان شرکت تبدیل می‌کند.

ویژگی متمایز زیردامنه‌های پشتیبان، پیچیدگی منطق کسب‌وکار راه‌حل است. زیردامنه‌های پشتیبان ساده هستند. منطق کسب‌وکار آن‌ها عمدتاً شبیه به صفحات ورود داده و عملیات ETL (استخراج، تبدیل، بارگذاری) است؛ یعنی رابط‌های به اصطلاح CRUD (ایجاد، خواندن، به‌روزرسانی و حذف). این حوزه‌های فعالیت هیچ مزیت رقابتی برای شرکت فراهم نمی‌کنند و بنابراین نیازی به موانع ورود بالا ندارند.

## مقایسه زیردامنه‌ها

اکنون که درک بیشتری از سه نوع زیردامنه کسب‌وکار داریم، بیایید تفاوت‌های آن‌ها را از زوایای اضافی بررسی کنیم و ببینیم چگونه بر تصمیمات طراحی استراتژیک نرم‌افزار تأثیر می‌گذارند.

| **نوع زیردامنه** | **مزیت رقابتی** | **پیچیدگی** | **تغییرپذیری** | **پیاده‌سازی** | **مسئله** |
|---|---|---|---|---|---|
| اصلی (Core) | بله | بالا | بالا | داخلی | جالب |
| عمومی (Generic) | خیر | بالا | پایین | خرید/اتخاذ | حل‌شده |
| پشتیبان (Supporting) | خیر | پایین | پایین | داخلی/برون‌سپاری | واضح |

### مزیت رقابتی

تنها زیردامنه‌های اصلی مزیت رقابتی به شرکت ارائه می‌دهند. زیردامنه‌های اصلی استراتژی شرکت برای متمایز کردن خود از رقبایش هستند.

زیردامنه‌های عمومی، طبق تعریف، نمی‌توانند منبعی برای مزیت رقابتی باشند. اینها راه‌حل‌های عمومی هستند—همان راه‌حل‌هایی که توسط شرکت و رقبایش استفاده می‌شود.

زیردامنه‌های پشتیبان نیز موانع ورود پایینی دارند و نمی‌توانند مزیت رقابتی ارائه دهند. معمولاً یک شرکت برایش مشکلی نیست که رقبایش زیردامنه‌های پشتیبان او را کپی کنند—این موضوع بر رقابت‌پذیری آن در صنعت تأثیری نخواهد گذاشت.

### پیچیدگی

از دیدگاه فنی‌تر، شناسایی زیردامنه‌های سازمان مهم است، زیرا انواع مختلف زیردامنه‌ها دارای سطوح مختلفی از پیچیدگی هستند. هنگام طراحی نرم‌افزار، باید ابزارها و تکنیک‌هایی را انتخاب کنیم که با پیچیدگی الزامات کسب‌وکار سازگار باشند.

**زیردامنه‌های پشتیبان**: منطق کسب‌وکار ساده است. اینها عملیات اساسی ETL و رابط‌های CRUD هستند و منطق کسب‌وکار واضح است. اغلب، فراتر از اعتبارسنجی ورودی‌ها یا تبدیل داده‌ها از یک ساختار به ساختار دیگر نمی‌رود.

**زیردامنه‌های عمومی**: بسیار پیچیده‌تر هستند. باید دلیل خوبی وجود داشته باشد که چرا دیگران قبلاً زمان و تلاش خود را صرف حل این مشکلات کرده‌اند. این راه‌حل‌ها نه ساده و نه بدیهی هستند. به عنوان مثال، الگوریتم‌های رمزنگاری یا مکانیسم‌های احراز هویت را در نظر بگیرید.

**زیردامنه‌های اصلی**: پیچیده هستند. آن‌ها باید تا حد امکان برای رقبا سخت باشند که کپی کنند—سودآوری شرکت به آن بستگی دارد. به همین دلیل است که از نظر استراتژیک، شرکت‌ها به دنبال حل مسائل پیچیده به عنوان زیردامنه‌های اصلی خود هستند.

---

# فصل اول - بخش دوم: شناسایی مرزهای زیردامنه‌ها و تحلیل دامنه

## شناسایی مرزهای زیردامنه‌ها

همانطور که دیدید، شناسایی زیردامنه‌ها و انواع آن‌ها می‌تواند به طور قابل توجهی در اتخاذ تصمیمات مختلف طراحی هنگام ساخت راه‌حل‌های نرم‌افزاری کمک کند. در فصل‌های بعدی، راه‌های بیشتری برای استفاده از زیردامنه‌ها جهت ساده‌سازی فرآیند طراحی نرم‌افزار خواهید آموخت. اما چگونه در واقع زیردامنه‌ها و مرزهای آن‌ها را شناسایی می‌کنیم؟

زیردامنه‌ها و انواع آن‌ها توسط **استراتژی کسب‌وکار شرکت** تعریف می‌شوند: حوزه‌های کسب‌وکار آن و نحوه متمایز شدن برای رقابت با سایر شرکت‌ها در همان زمینه. در اکثریت قریب به اتفاق پروژه‌های نرم‌افزاری، به یک شکل یا شکل دیگر، زیردامنه‌ها "از قبل آنجا هستند". این به این معنا نیست که همیشه شناسایی مرزهای آن‌ها آسان و مستقیم است. اگر از یک مدیرعامل بخواهید فهرستی از زیردامنه‌های شرکتش را به شما بدهد، احتمالاً با نگاهی خالی روبرو خواهید شد. آن‌ها از این مفهوم آگاه نیستند. بنابراین، باید خودتان تحلیل دامنه را انجام دهید تا زیردامنه‌های موجود را شناسایی و دسته‌بندی کنید.

### نقطه شروع خوب: واحدهای سازمانی

یک نقطه شروع خوب، **دپارتمان‌های شرکت و سایر واحدهای سازمانی** است. به عنوان مثال، یک فروشگاه خرده‌فروشی آنلاین ممکن است شامل دپارتمان‌های انبار، خدمات مشتری، انتخاب کالا، حمل‌ونقل، کنترل کیفیت و مدیریت کانال‌ها و از جمله سایر موارد باشد.

با این حال، اینها حوزه‌های نسبتاً درشت‌دانه‌ای از فعالیت هستند. به عنوان مثال، دپارتمان خدمات مشتری را در نظر بگیرید. منطقی است که فرض کنیم این یک زیردامنه پشتیبان یا حتی یک زیردامنه عمومی باشد، زیرا این عملکرد اغلب به فروشندگان شخص ثالث برون‌سپاری می‌شود. اما آیا این اطلاعات برای ما کافی است تا تصمیمات طراحی نرم‌افزاری صحیحی بگیریم؟

### تقطیر زیردامنه‌ها (Distilling Subdomains)

زیردامنه‌های درشت‌دانه یک نقطه شروع خوب هستند، اما **شیطان در جزئیات نهفته است**. ما باید مطمئن شویم که اطلاعات مهمی را که در پیچیدگی‌های عملکرد کسب‌وکار پنهان شده است، از دست نمی‌دهیم.

بیایید به مثال دپارتمان خدمات مشتری برگردیم. اگر عملکرد داخلی آن را بررسی کنیم، خواهیم دید که یک دپارتمان خدمات مشتری معمولی از **اجزای دقیق‌تر** تشکیل شده است، مانند:

- سیستم Help Desk
- مدیریت شیفت و زمان‌بندی
- سیستم تلفنی
- و غیره

زمانی که به عنوان زیردامنه‌های جداگانه نگاه می‌شوند، این فعالیت‌ها می‌توانند از انواع مختلفی باشند:

- **سیستم‌های Help Desk و تلفنی**: زیردامنه‌های عمومی هستند
- **مدیریت شیفت**: یک زیردامنه پشتیبان است
- **الگوریتم مسیریابی**: ممکن است یک شرکت الگوریتم نابغه‌ای برای مسیریابی حوادث به نمایندگانی که با موارد مشابه در گذشته موفق بوده‌اند، توسعه دهد

الگوریتم مسیریابی نیازمند تحلیل موارد ورودی و شناسایی شباهت‌ها در تجربیات گذشته است—هر دوی اینها وظایف غیربدیهی هستند. از آنجا که الگوریتم مسیریابی به شرکت اجازه می‌دهد تجربه مشتری بهتری نسبت به رقبایش ارائه دهد، **الگوریتم مسیریابی یک زیردامنه اصلی است**.

```
دپارتمان خدمات مشتری
├── سیستم Help Desk (عمومی)
├── سیستم تلفنی (عمومی)
├── مدیریت شیفت (پشتیبان)
└── الگوریتم مسیریابی هوشمند (اصلی) ⭐
```

از طرف دیگر، ما نمی‌توانیم به طور نامحدود به دنبال بینش‌ها در سطوح پایین‌تر و پایین‌تر از دانه‌بندی باشیم. چه زمانی باید متوقف شوید؟

### زیردامنه‌ها به عنوان مجموعه‌ای از Use Case های منسجم

از دیدگاه فنی، زیردامنه‌ها شبیه به **مجموعه‌ای از Use Case های مرتبط و منسجم** هستند. چنین مجموعه‌ای از Use Case ها معمولاً شامل موارد زیر می‌شوند:

- همان بازیگر (Actor)
- موجودیت‌های کسب‌وکاری مشابه
- همه آن‌ها یک مجموعه داده نزدیک به هم را دستکاری می‌کنند

#### مثال: دیاگرام Use Case برای درگاه پرداخت کارت اعتباری

Use Case های زیر را در نظر بگیرید که همگی به **زیردامنه پرداخت کارت اعتباری** تعلق دارند:

```
بازیگران:
- مشتری
- سیستم بانکی
- فروشنده

Use Case ها:
├── پردازش پرداخت
├── بررسی اعتبار کارت
├── تأیید تراکنش
├── بازپرداخت
└── گزارش تراکنش‌ها
```

این Use Case ها به شدت توسط داده‌هایی که با آن کار می‌کنند و بازیگران درگیر به هم مرتبط هستند. بنابراین، همه Use Case ها **زیردامنه پرداخت کارت اعتباری** را تشکیل می‌دهند.

### چه زمانی باید تقطیر را متوقف کنیم؟

می‌توانیم از تعریف "زیردامنه‌ها به عنوان مجموعه‌ای از Use Case های منسجم" به عنوان **اصل راهنما** برای زمانی که باید به دنبال زیردامنه‌های دقیق‌تر بگردیم استفاده کنیم. اینها دقیق‌ترین مرزهای زیردامنه‌ها هستند.

#### برای زیردامنه‌های اصلی: تقطیر کامل ضروری است

آیا همیشه باید بکوشید چنین مرزهای زیردامنه‌ای متمرکز را شناسایی کنید؟ برای **زیردامنه‌های اصلی** قطعاً ضروری است. زیردامنه‌های اصلی مهم‌ترین، متغیرترین و پیچیده‌ترین هستند. ضروری است که آن‌ها را تا حد امکان تقطیر کنیم زیرا این امر به ما اجازه می‌دهد همه عملکردهای عمومی و پشتیبان را استخراج کنیم و تلاش را روی عملکردهای بسیار متمرکزتری سرمایه‌گذاری کنیم.

#### برای زیردامنه‌های پشتیبان و عمومی: تقطیر آسان‌تر

تقطیر می‌تواند تا حدودی برای زیردامنه‌های پشتیبان و عمومی **آسان‌تر** باشد. اگر رفتن به عمق بیشتر بینش‌های جدیدی را که می‌تواند به شما کمک کند تصمیمات طراحی نرم‌افزار بگیرید، آشکار نکند، می‌تواند مکان خوبی برای توقف باشد. این می‌تواند، به عنوان مثال، زمانی اتفاق بیفتد که همه زیردامنه‌های دقیق‌تر از همان نوع زیردامنه اصلی باشند.

مثال زیر را در نظر بگیرید:

```
سیستم Help Desk (عمومی)
├── مدیریت تیکت (عمومی)
├── پایگاه دانش (عمومی)
├── گزارش‌گیری (عمومی)
└── مدیریت SLA (عمومی)
```

تقطیر بیشتر زیردامنه سیستم Help Desk کمتر مفید است، زیرا اطلاعات استراتژیک جدیدی را آشکار نمی‌کند و یک ابزار آماده درشت‌دانه به عنوان راه‌حل استفاده خواهد شد.

## تمرکز روی موارد ضروری

زیردامنه‌ها ابزاری هستند که فرآیند اتخاذ تصمیمات طراحی نرم‌افزار را تسهیل می‌کنند. همه سازمان‌ها احتمالاً عملکردهای کسب‌وکاری کاملاً زیادی دارند که مزیت رقابتی آن‌ها را هدایت می‌کنند اما **هیچ ارتباطی با نرم‌افزار ندارند**. سازنده جواهرات که قبلاً در این فصل بحث کردیم تنها یک مثال است.

هنگام جستجوی زیردامنه‌ها، مهم است که:
1. عملکردهای کسب‌وکاری که به نرم‌افزار مرتبط نیستند را شناسایی کنید
2. آن‌ها را به عنوان چنین چیزی تأیید کنید
3. روی جنبه‌های کسب‌وکار که به سیستم نرم‌افزاری که روی آن کار می‌کنید مرتبط هستند، تمرکز کنید

---

# فصل اول - بخش سوم: تحلیل دامنه با مثالهای عملی - Gigmaster و BusVNext

## مثال اول: Gigmaster - شرکت فروش بلیت

### معرفی شرکت

**Gigmaster** یک شرکت فروش و توزیع بلیت است. اپلیکیشن موبایلی آن کتابخانه موسیقی کاربران، حساب‌های سرویس‌های جریانی (مثل Spotify) و پروفایل‌های شبکه‌های اجتماعی را تحلیل می‌کند تا برنامه‌های موسیقی نزدیک را که کاربران علاقه‌مند به حضور در آن‌ها هستند، شناسایی کند.

کاربران Gigmaster نسبت به حریم‌خصوصی آن‌ها توجه زیادی دارند. بنابراین، **تمام اطلاعات شخصی کاربران رمزگذاری می‌شوند**. علاوه بر این، برای اطمینان از اینکه ترجیحات موسیقی "عجیب‌وغریب" کاربران به هیچ شرایطی فاش نشود، **الگوریتم توصیه‌های شرکت منحصراً با داده‌های ناشناس‌شده کار می‌کند**.

یک ماژول جدید اخیراً اضافه شده است که به کاربران امکان می‌دهد برنامه‌های موسیقی را که در گذشته حضور داشته‌اند را ثبت کنند، حتی اگر بلیت‌ها از طریق Gigmaster خریداری نشده باشند.

### تحلیل دامنه

#### **حوزه کسب‌وکار**

حوزه کسب‌وکار Gigmaster **فروش بلیت** است. این خدمتی است که شرکت به مشتریانش ارائه می‌دهد.

#### **زیردامنه‌های اصلی (Core Subdomains)**

**مزیت رقابتی اصلی** Gigmaster **الگوریتم توصیه‌های آن** است. این الگوریتم توانایی شرکت را بر میل و علایق اضافی کاربران تا سطح دقیق دارند:

- **الگوریتم توصیه‌های هوشمند**: این قلب سیستم است و کاربران را به برنامه‌هایی راهنمایی می‌کند که واقعاً علاقه‌مند هستند
- **ناشناس‌سازی داده‌ها**: شرکت بر روی حریم‌خصوصی تأکید زیادی دارد و این عملکرد رقابتی است زیرا کاربران می‌دانند اطلاعات آن‌ها محافظت‌شده است
- **تجربه کاربری موبایل (UX)**: رابط کاربری تمیز و قابل استفاده یک عامل کلیدی در جذب و حفظ کاربران است

**بنابراین، زیردامنه‌های اصلی Gigmaster عبارت‌اند از:**
- الگوریتم توصیه‌ها ⭐
- ناشناس‌سازی داده‌ها ⭐  
- اپلیکیشن موبایل ⭐

#### **زیردامنه‌های عمومی (Generic Subdomains)**

اینها مسائلی هستند که **هر شرکت فروش حل می‌کند** و راه‌حل‌های آماده وجود دارند:

- **رمزنگاری**: برای رمزگذاری تمام داده‌ها
- **حسابداری**: چون شرکت در تجارت فروش است
- **Clearing**: برای شارژ کردن مشتریان
- **احراز هویت و مجوزدهی**: برای شناسایی کاربران

#### **زیردامنه‌های پشتیبان (Supporting Subdomains)**

اینها عملکردهای ساده هستند که به سیستم اصلی کمک می‌کنند اما **هیچ مزیت رقابتی ندارند**:

- **ادغام با سرویس‌های موسیقی جریانی**: درخواست داده‌ها از Spotify، Apple Music و غیره
- **ادغام با شبکه‌های اجتماعی**: خواندن پروفایل‌ها
- **ماژول برنامه‌های حضور یافته**: ذخیره داده‌های تاریخی برنامه‌هایی که کاربر حضور داشته است

### تصمیمات طراحی استراتژیک

از دانستن اینکه کدام زیردامنه‌ها در کدام دسته قرار دارند، می‌توانیم **تصمیمات طراحی استراتژیک** بگیریم:

| **زیردامنه** | **نوع** | **تصمیم طراحی** |
|---|---|---|
| الگوریتم توصیه‌ها | اصلی | باید با تکنیک‌های پیشرفته برنامه‌نویسی توسط تیم در‌خانه پیاده‌سازی شود |
| ناشناس‌سازی | اصلی | باید با دقت بالا در‌خانه پیاده‌سازی شود (حتی ممکن است متخصص امنیت لازم باشد) |
| تجربه موبایل | اصلی | طراحی رابط کاربری باید توسط تیم ماهر انجام شود |
| رمزنگاری، حسابداری، Clearing | عمومی | می‌توان از راه‌حل‌های آماده یا کتابخانه‌های منتشرشده استفاده کرد |
| احراز هویت | عمومی | استفاده از سرویس‌های مثل Auth0 یا OAuth معقول است |
| ادغام با سرویس‌های خارجی | پشتیبان | می‌تواند برون‌سپاری شود |
| ماژول برنامه‌های حضور یافته | پشتیبان | می‌تواند برون‌سپاری شود |

## مثال دوم: BusVNext - شرکت حمل‌ونقل عمومی

### معرفی شرکت

**BusVNext** یک شرکت حمل‌ونقل عمومی است که هدفش ارائه سفر‌های اتوبوس مراتب است که آن‌قدر راحت و مطلوب باشد که تجربه‌ای مشابه با تاکسی داشته باشد. شرکت ناوگان اتوبوس‌هایی را در شهرهای بزرگ مدیریت می‌کند.

**مشتری BusVNext** می‌تواند از طریق اپلیکیشن موبایل یک سفر سفارش دهد. در زمان حضور برنامه‌ریزی‌شده، **مسیر یک اتوبوس نزدیک به صورت لحظه‌ای تنظیم می‌شود** تا مسافر را در زمان تعیین‌شده برداشت کند.

**چالش اصلی** BusVNext پیاده‌سازی **الگوریتم مسیریابی** بود. الزامات آن یک گونه از **مسئله فروشنده دوره‌گرد** (Travelling Salesman Problem) است. منطق مسیریابی به طور مستمر تنظیم و بهینه‌سازی می‌شود. مثلاً آمارها نشان می‌دهند **دلیل اصلی لغو سفرها زمان انتظار زیاد برای اتوبوس است**. بنابراین شرکت **الگوریتم مسیریابی را برای اولویت دادن به برداشت سریع تغییر داد**، حتی اگر این معنای تاخیری بیشتر در رسیدن باشد.

### تحلیل دامنه

#### **حوزه کسب‌وکار**

حوزه کسب‌وکار BusVNext **حمل‌ونقل عمومی بهینه‌شده** است.

#### **زیردامنه‌های اصلی (Core Subdomains)**

**مزیت رقابتی اصلی** BusVNext از بین رفتن یا کاهش دادن این مسائل است:

- **الگوریتم مسیریابی هوشمند**: حل یک مسئله پیچیده ریاضی (TSP) با تطبیق به اهداف تجاری متفاوت—کاهش زمان برداشت حتی اگر طول کل سفر افزایش یابد
- **تحلیل داده‌های سفرها**: شرکت **به طور مستمر سفرها را تحلیل می‌کند** تا الگوهای رفتار مسافران را کشف کند و الگوریتم مسیریابی را بهتر بسازد
- **تجربه کاربری اپلیکیشن**: هم برای مسافران و هم برای رانندگان، رابط ساده و واضح ضروری است
- **مدیریت ناوگان**: اتوبوس‌ها می‌توانند مشکلات فنی داشته باشند و نیاز به تعمیر دارند. نادیده گرفتن این موضوع ممکن است به تلفات مالی و کاهش سطح خدمات منجر شود

**بنابراین، زیردامنه‌های اصلی BusVNext عبارت‌اند از:**
- مسیریابی ⭐
- تحلیل داده‌ها ⭐
- تجربه کاربری موبایل ⭐
- مدیریت ناوگان ⭐

#### **زیردامنه‌های عمومی (Generic Subdomains)**

- **داده‌های ترافیک و هشدارهای بلادرنگ**: شرکت **از شرکت‌های شخص ثالث** برای دریافت اطلاعات ترافیکی استفاده می‌کند
- **حسابداری**: مدیریت درآمد‌ها
- **صورتحساب**: ایجاد صورتحسابهایی برای مشتریان
- **احراز هویت و مجوزدهی**

#### **زیردامنه‌های پشتیبان (Supporting Subdomains)**

- **مدیریت تخفیف‌ها و پیش‌نهادهای ویژه**: این ماژول از نظر منطق کسب‌وکار **بسیار ساده است**—فقط **رابط کاربری CRUD برای مدیریت کدهای کوپن فعال**. شرکت این تخفیف‌ها را برای جذب مشتریان جدید و تعدیل تقاضا در اوقات اوج و کم استفاده می‌کند

### تصمیمات طراحی استراتژیک

| **زیردامنه** | **نوع** | **تصمیم طراحی** |
|---|---|---|
| الگوریتم مسیریابی | اصلی | باید با بالاترین سطح تکنیک‌های مهندسی در‌خانه پیاده‌سازی شود |
| تحلیل داده‌ها | اصلی | باید درون‌سازی شود (ممکن است به Machine Learning و Data Science نیاز باشد) |
| مدیریت ناوگان | اصلی | متخصصان و سیستم‌های پیشرفته لازم است |
| تجربه کاربری | اصلی | توسط تیم ماهر طراحی شود |
| داده‌های ترافیک | عمومی | از سرویس‌های شخص ثالث (مثل Google Maps API) استفاده شود |
| حسابداری و صورتحساب | عمومی | از نرم‌افزار حسابداری آماده یا سرویس ابری استفاده شود |
| احراز هویت | عمومی | استفاده از سرویس‌های مثل OAuth یا شرکای احراز هویت |
| مدیریت تخفیف‌ها | پشتیبان | **می‌تواند برون‌سپاری شود** یا توسط تیم درحال‌آموزش پیاده‌سازی شود |
| بررسی ترافیک | عمومی | خریداری از شرکت‌های بیرونی |

## خلاصه تحلیل‌های دو مثال

### اهمیت این تحلیل‌ها

این دو مثال نشان می‌دهند که **چگونه یک تحلیل دامنه صحیح** می‌تواند تصمیمات زیادی را هدایت کند:

1. **بودجه‌بندی و تخصیص منابع**: منابع بیشتر باید به زیردامنه‌های اصلی اختصاص داده شود

2. **تشکیل تیم**: تیم‌های ماهر برای سیستم‌های اصلی، و تیم‌های کم‌تجربه برای سیستم‌های پشتیبان

3. **معماری سیستم**: زیردامنه‌های اصلی نیاز به معماری و طراحی پیچیده‌تری دارند

4. **برون‌سپاری یا توسعه درون‌سازی**: تصمیم واضح درباره آنچه باید درون‌سازی شود و آنچه باید خریداری شود

---

## کارشناسان دامنه چه کسانی هستند؟

کارشناس دامنه یعنی فرد (یا افرادی) که ریزه‌کاری‌های کسب‌وکاریِ «دامنه‌ای که قرار است نرم‌افزارش را بسازیم» را عمیقاً می‌شناسند و مرجع اصلی دانش همان کسب‌وکار هستند.
این افراد نه تحلیلگر نیازمندی‌اند و نه مهندس نرم‌افزار؛ آن‌ها نماینده «کسب‌وکار» هستند و دانشی که تحلیلگران و مهندسان با آن کار می‌کنند، نهایتاً از ذهن و تجربه همین افراد می‌آید.
به بیان دقیق‌تر، تحلیلگرها و مهندسان تلاش می‌کنند مدل ذهنیِ کارشناس دامنه از کسب‌وکار را به نیازمندی‌ها و سپس به کد تبدیل کنند.

## چرا نقششان حیاتی است؟

هدف نرم‌افزار حل مسائل و نیازهای همان کسب‌وکار است، پس اگر منبع دانش درست در فرایند حضور نداشته باشد، تیم فنی ناچار می‌شود بر اساس حدس، برداشت‌های ناقص یا اصطلاحات مبهم تصمیم‌گیری کند.
کتاب تأکید می‌کند که دانش دامنه «منشأ» دارد و آن منشأ، کارشناسان دامنه‌اند؛ بنابراین کیفیت طراحی و پیاده‌سازی به کیفیت ارتباط و انتقال دانش از آن‌ها وابسته است.

## چه کسانی معمولاً کارشناس دامنه‌اند؟

کتاب یک قاعده سرانگشتی می‌دهد: کارشناسان دامنه معمولاً یا همان کسانی‌اند که نیازمندی‌ها را مطرح می‌کنند، یا همان کاربران نهایی سیستم که نرم‌افزار قرار است مشکلاتشان را حل کند.
دامنه تخصص آن‌ها هم می‌تواند متفاوت باشد: بعضی‌ها کل کسب‌وکار را خوب می‌شناسند و بعضی فقط در یک یا چند زیردامنه متخصص‌اند.
مثلاً در یک آژانس تبلیغات آنلاین، نمونه‌هایی از کارشناسان دامنه می‌توانند مدیران کمپین، خریداران رسانه و تحلیلگران کسب‌وکار باشند.

## نکته آموزشی برای شما

از همین‌جا یک پیام عملی برای طراحی نرم‌افزار بیرون می‌آید: وقتی «زیردامنه‌ها» را تشخیص می‌دهید، باید هم‌زمان مشخص کنید برای هر زیردامنه چه کسی «مرجع حقیقت» است (چه کسی واقعاً جواب درست را می‌داند).
در عمل، هرچه زیردامنه به سمت «اصلی/رقابتی» بودن می‌رود، نیاز به دسترسی نزدیک‌تر و دائمی‌تر به کارشناسان دامنه بیشتر می‌شود، چون همان‌جا ابهام و تغییر زیاد است.

---

## تمرین‌های ۱ تا ۳ (چندگزینه‌ای)

### ۱) کدام زیردامنه(ها) هیچ مزیت رقابتی ایجاد نمی‌کنند؟
پاسخ: **عمومی و پشتیبان**.  
منطق: زیردامنهٔ اصلی همان جایی است که شرکت «متفاوت» عمل می‌کند و مزیت رقابتی می‌سازد؛ اما زیردامنهٔ عمومی و پشتیبان قرار نیست شرکت را از رقبا متمایز کنند.

### ۲) برای کدام زیردامنه ممکن است همهٔ رقبا از راه‌حل یکسان استفاده کنند؟
پاسخ: **زیردامنهٔ عمومی**.  
منطق: عمومی یعنی مسئله‌ای حل‌شده و استاندارد که شرکت‌ها معمولاً از راه‌حل‌های آماده/متداول استفاده می‌کنند (مثل احراز هویت یا رمزنگاری).

### ۳) کدام زیردامنه انتظار می‌رود بیشترین تغییر را داشته باشد؟
پاسخ: **زیردامنهٔ اصلی**.  
منطق: چون منبع مزیت رقابتی است، دائماً باید تکامل پیدا کند؛ شرکت‌ها مدام آن را بهینه می‌کنند تا عقب نمانند.

## تمرین‌های ۴ تا ۷ (سناریوی WolfDesk)

کتاب می‌گوید WolfDesk یک شرکت «سیستم مدیریت تیکت‌های هلپ‌دسک» ارائه می‌دهد. برای حل تمرین‌ها، ابتدا یک روش گام‌به‌گام داشته باشید:

1) اول «خدمت اصلی به مشتری» را پیدا کنید ⇒ این می‌شود حوزهٔ کسب‌وکار.  
2) بعد بپرسید «چه چیزی باعث برتری این شرکت نسبت به رقبا می‌شود؟» ⇒ این می‌شود زیردامنهٔ اصلی.  
3) سپس «چه چیزهایی استاندارد و قابل خریدن است؟» ⇒ زیردامنهٔ عمومی.  
4) و در نهایت «چه چیزهایی لازم است ولی مزیت رقابتی نیست و منطق ساده دارد؟» ⇒ زیردامنهٔ پشتیبان.

حالا پاسخ‌ها:

### ۴) حوزهٔ کسب‌وکار WolfDesk چیست؟
به احتمال زیاد: **مدیریت تیکت‌های پشتیبانی/هلپ‌دسک** (Help Desk Ticket Management).  
یعنی ارزش پیشنهادی شرکت: دریافت، پیگیری، اولویت‌بندی و حل درخواست‌های پشتیبانی مشتریان.

### ۵) زیردامنه(های) اصلی WolfDesk چیست؟
این بستگی دارد WolfDesk دقیقاً با چه چیزی رقابت می‌کند، اما معمولاً موارد زیر می‌تواند «اصلی» باشد اگر واقعاً عامل تمایز شرکت باشد:
- الگوریتم/منطق **مسیریابی هوشمند تیکت‌ها** (تخصیص تیکت به بهترین کارشناس بر اساس مهارت/تجربه/موضوع).
- **اتوماسیون گردش‌کار** و قوانین پیچیدهٔ SLA (اگر واقعاً نوآورانه و خاص باشد).
- **تجربهٔ کاربری** بسیار برتر برای اپراتورها و مدیران (اگر مزیت رقابتی اصلی محصول باشد).

نکتهٔ کلیدی: «فقط داشتن صفحهٔ ثبت تیکت» معمولاً مزیت رقابتی نیست؛ مزیت رقابتی در هوشمندی، اتوماسیون، و کیفیت تجربهٔ کاربری یا بینش‌های تحلیلی است.

### ۶) زیردامنه(های) پشتیبان WolfDesk چیست؟
مواردی که لازم‌اند اما معمولاً منطق ساده‌تری دارند و شرکت با آن‌ها متمایز نمی‌شود، مثل:
- **مدیریت کاربران سازمانی/تیم‌ها/شیفت‌ها** (اگر صرفاً CRUD باشد).
- **تنظیمات پروژه‌ها، دسته‌بندی‌ها، برچسب‌ها**.
- **مدیریت قالب‌های پاسخ** و متن‌های آماده (اگر ساده باشد).
اینها معمولاً همان «کارهای ضروری ولی نه استراتژیک» هستند.

### ۷) زیردامنه(های) عمومی WolfDesk چیست؟
موارد استاندارد و قابل خرید/اتخاذ که همه دارند:
- **احراز هویت و مجوزدهی** (SSO، OAuth، SAML و…).
- **ارسال ایمیل/پیامک/نوتیفیکیشن** (اغلب از سرویس‌های عمومی استفاده می‌شود).
- **پرداخت، صورتحساب و حسابداری** (اگر SaaS باشد و فروش اشتراک داشته باشد).
- گاهی **جست‌وجوی متن** یا **گزارش‌گیری عمومی** هم می‌تواند عمومی تلقی شود اگر راه‌حل‌های آمادهٔ قوی وجود داشته باشد.

---
---

# فصل دوم: کشف دانش دامنه - بخش اول: مسائل کسب‌وکاری و اهمیت ارتباط

مقدمهٔ فصل دوم با یک نقل‌قول الهام‌بخش از **Alberto Brandolini** شروع می‌شود:

> «کدی که از سوءفهم توسعه‌دهندگان به‌وجود می‌آید، نه از دانش صحیح کارشناسان دامنه، وارد محیط تولیدی می‌شود.»

این جمله خلاصهٔ کل فصل دوم است: **مشکل اصلی پروژه‌های نرم‌افزاری انتقال دانش است.**

## تاریخچه‌ای از فصل یک

فصل قبل (فصل اول) بر روی **سطح استراتژیک** تمرکز داشت: تحلیل حوزه کسب‌وکار، شناسایی زیردامنه‌ها و انواع آن‌ها.

فصل دوم سطح **عمیق‌تری** را مطالعه می‌کند: درون یک زیردامنه چه اتفاقی رخ می‌دهد؟ منطق کسب‌وکاری و فرآیندهایش چگونه است؟

## مسائل کسب‌وکاری (Business Problems)

اول باید دقیق کنیم: **«مسئلهٔ کسب‌وکار» با «مسئلهٔ ریاضی» متفاوت است.**

یک مسئلهٔ ریاضی چیزی است که می‌توانید **حل کنید و تمام باشد**. اما مسئلهٔ کسب‌وکار چیزی است که **شرکت‌ها مدام با آن دست‌وپنجه‌نرم می‌کنند.**

نمونه‌های مسائل کسب‌وکاری:

- بهینه‌سازی جریان‌های کاری و فرآیندها
- کاهش کار دستی
- مدیریت منابع
- پشتیبانی در تصمیم‌گیری
- مدیریت و نظم‌دهی داده‌ها

این مسائل در **سطح حوزهٔ کسب‌وکار کلان و در سطح زیردامنه‌های خاص** نمایان می‌شوند.

**نمونه ملموس:** شرکت **FedEx** (از فصل یک) برای حل مسئلهٔ کسب‌وکاریِ مشتریانش («نیاز به فرستادن بسته‌ها در زمان محدود») فرآیند حمل‌ونقل را بهینه‌سازی کرد.

## کشف دانش (Knowledge Discovery)

 این بخش هسته‌ی اصلی فصل دوم است:

**برای ساخت راه‌حل نرم‌افزاری موثر، باید حداقل دانش پایه‌ای از حوزهٔ کسب‌وکار داشته باشید.**

اما این دانش از کجا می‌آید؟ **از کارشناسان دامنه (Domain Experts).**

### نکتهٔ حیاتی:

ما (توسعه‌دهندگان و معماران) **نباید** کارشناس دامنه شویم. این غیرعملی است و هدف نیست.

اما **باید** کارشناسان دامنه را درک کنیم و **از همان اصطلاحات کسب‌وکاری که آن‌ها استفاده می‌کنند، استفاده کنیم.**

### دلیل:

**نرم‌افزار باید از همان روش فکری کارشناس دامنه (مدل ذهنی آن‌ها) تبعیت کند.**

اگر ما نفهمیم چرا کسب‌وکار این‌طور کار می‌کند، **راه‌حل‌های غلط یا ناقص**خواهیم ساخت. و نتیجهٔ آن **شکستِ پروژه** است.

---

# فصل دوم - بخش دوم: ارتباط و چالش‌های شکاف دانش

## مسئلهٔ ارتباط در پروژه‌های نرم‌افزاری

پس از فهمیدن اینکه چرا به دانش حوزه نیاز داریم، حالا بیایید واقعیت‌های سخت را ببینیم: **چگونه این دانش از کارشناسان دامنه به توسعه‌دهندگان برسد؟**

تقریباً تمام پروژه‌های نرم‌افزاری نیاز به **همکاری افراد با نقش‌های متفاوت** دارند: کارشناسان دامنه، مالکین محصول، مهندسان نرم‌افزار، طراحان UI/UX، مدیران پروژه و تست‌کنندگان.

**موفقیت پروژه بستگی به این دارد که این گروه‌های مختلف چقدر خوب با هم کار کنند.**

سؤالات اساسی‌ای که باید پاسخ داد:

- آیا همه نفر‌ها درک یکسانی از مسئله‌ای که حل می‌کنند دارند؟
- آیا درباره راه‌حل فرضیات متناقضی دارند؟
- آیا از نیازمندی‌های تابعی و غیرتابعی بر سر یک نظر هستند؟

**توافق و هم‌راستایی درباره تمام موارد مرتبط با پروژه برای موفقیت ضروری است.**

## مشکل: فقدان ارتباط مستقیم

 تحقیقات نشان می‌دهند که **بخش اعظم شکست‌های پروژه‌های نرم‌افزاری از ارتباط ناکافی ناشی می‌شود.**

با این حال، به تعجب خیلی، **ارتباط مؤثر در اکثر پروژه‌های نرم‌افزاری مشاهده نمی‌شود.**

### مسئلهٔ واسطه‌گران

 معمولاً افراد کسب‌وکار و مهندسان **هیچ ارتباط مستقیمی با یکدیگر ندارند.** به جای آن، دانش حوزه از **واسطه‌گران** (میانجیان) منتقل می‌شود:

- تحلیلگران سیستم
- مالکین محصول
- مدیران پروژه

**مشکل این رویکرد:** هرجا که ترجمه‌ای صورت گیرد، **اطلاعات از دست می‌رود.**

دانش حوزه‌ای که برای حل مسائل کسب‌وکاری ضروری است در راه به سراغ مهندسان **کاهش یافته یا تحریف می‌شود.**

### مسئلهٔ چندگانه‌بودن ترجمه‌ها

 این تنها ترجمهٔ یکی نیست. سیکل توسعه نرم‌افزار سنتی **چندین ترجمهٔ متوالی** را شامل می‌شود:

1. **دانش حوزه** → 2. **مدل تحلیل‌شده**
2. **مدل تحلیل‌شده** → 3. **طراحی سیستم**
3. **طراحی سیستم** → 4. **کد پیاده‌سازی‌شده**

مسئلهٔ اضافی اینکه **اسناد و مستندات دیگر سریع از تاریخ می‌افتند** و کود باقی‌مانده منبع اطلاع برای مهندسانی است که بعداً روی پروژه کار می‌کنند.

## بازی تلفن (Telephone Game)

 این فرآیند **دقیقاً مثل بازی کودکانه "تلفن" است**:

- نفر اول پیام‌ای را در سر شخص دوم زمزمه می‌کند
- دوم برای سوم تکرار می‌کند
- و ... تا آخر
- نفر آخر پیام را برای همه اعلام می‌کند
- **پیام نهایی اغلب کاملاً متفاوت از اصلی است**

**نتیجه:** توسعه‌دهندگان به جای حل مسئلهٔ درست، **یا راه‌حل غلط را می‌سازند، یا راه‌حل درستی را برای مسئلهٔ اشتباه پیاده می‌کنند.**

**در هر دو صورت، پروژه ناکام می‌ماند.**

**سؤال کلیدی:** چطور می‌توانیم این ترجمه‌های بی‌پایان و اطلاعات‌گم‌شدهٔ آن را متوقف کنیم؟

**پاسخ:** **زبان یکپارچه (Ubiquitous Language)**

---

# فصل دوم - بخش سوم: زبان یکپارچه (Ubiquitous Language) - راه‌حل DDD

## مشکل و راه‌حل

بعد از بررسی مسائل ارتباطی و بازی تلفنی (ترجمه‌های متوالی)، **حالا راه‌حل DDD را معرفی می‌کنم:**

> «اگر طرف‌های مختلف باید کارآمد ارتباط کنند، به جای اینکه روی ترجمه‌ها تکیه کنند، باید **یک زبان واحد** صحبت کنند.»

## تعریف زبان یکپارچه (Ubiquitous Language)

 زبان یکپارچه یعنی:

**تمام افراد درگیر در پروژه (مهندسان نرم‌افزار، مالکین محصول، کارشناسان دامنه، طراحان UI/UX) باید از یک **زبانِ واحد و مشترک** برای توصیف دامنهٔ کسب‌وکار استفاده کنند.**

### ویژگی کلیدی:

**این زبان باید زبان کسب‌وکار باشد، نه زبان فنی.**

مثال‌های **درست** (زبان کسب‌وکار):

- «یک کمپین تبلیغاتی می‌تواند مواد خلاقانهٔ مختلف را نمایش دهد.»
- «یک کمپین تنها می‌تواند منتشر شود اگر حداقل یک placement فعال داشته باشد.»
- «کمیسیون‌های فروش پس از تصویب تراکنش‌ها محاسبه می‌شود.»

مثال‌های **نادرست** (زبان فنی):

- «iframe تبلیغات یک فایل HTML را نمایش می‌دهد.»
- «یک کمپین می‌تواند منتشر شود اگر حداقل یک record در جدول `active_placements` داشته باشد.»
- «کمیسیون‌ها بر اساس related records از جداول `transactions` و `approved_sales` محاسبه می‌شود.»

**دلیل:** اگر مهندسان فقط با نسخهٔ فنی آشنایی دارند، **درک عمیق منطق کسب‌وکار را از دست می‌دهند.**

## ویژگی‌های زبان یکپارچه

### ۱. **دقت و سازگاری (Precision & Consistency)**

 هر اصطلاح در زبان یکپارچه **باید یک معنای واحد** داشته باشد.

#### مثال از عدم‌سازگاری:

اگر اصطلاح «policy» در کسب‌وکار دو معنای متفاوت داشته باشد:

- معنی ۱: «قانون نظارتی»
- معنی ۲: «قرارداد بیمه»

**حل:** به جای استفاده از یک اصطلاح مبهم، **دو اصطلاح مختلف** استفاده کنید:
- «regulatory rule»
- «insurance contract»

#### مثال از اصطلاحات مترادف:

اگر برای مفهوم یکسان اصطلاحات متفاوتی استفاده شود:

- «user»
- «visitor»
- «account»

**مشکل:** این اصطلاحات ممکن است **مفاهیم متفاوتی** را نشان دهند. مثلاً:
- «visitor» = کاربرانِ ثبت‌نام‌نشده (فقط برای تحلیل)
- «account» = کاربرانِ ثبت‌نام‌شده (که سیستم را واقعاً استفاده می‌کنند)

**حل:** هر اصطلاح را در **زمینهٔ خاص خود** استفاده کنید و نام‌های مختلف برای مفاهیم مختلف بگذارید.

***

## مدل‌سازی دامنهٔ کسب‌وکار

### یک مدل چیست؟

 **مدل نسخهٔ ساده‌شدهٔ یک چیز یا پدیده‌ای است که اهداف خاصی را در نظر گرفته و سایر جنبه‌ها را نادیده می‌گیرد.**

**مثال: نقشه‌ها**

نقشه‌های مختلف (نقشهٔ جاده‌ای، نقشهٔ زمان، نقشهٔ زیرزمینی) **هیچ‌یک دقیقِ همهٔ جزئیات زمین را نشان نمی‌دهند.** اما **هر یک برای مقصودِ خود مناسب است.**

### مدل‌سازی موثر

 یک مدل موثر:

- **فقط جزئیات مورد نیاز برای حل مسئلهٔ خاص را شامل می‌شود**
- **سایر جزئیات غیرضروری را کنار می‌گذارد**
- **هدف آن حل مسئله است، نه کپی دقیق از دنیای واقعی**

### زبان یکپارچه = مدل دامنه

 زمانی که یک زبان یکپارچه را تعریف می‌کنید، **شما در حقیقت یک مدل از دامنهٔ کسب‌وکار می‌سازید.**

این مدل باید:

- **ذهن‌های کارشناسان دامنه را منعکس کند**
- **موجودیت‌های کسب‌وکاری و رفتار آن‌ها را شامل شود**
- **روابط علت‌ومعلول را نشان دهد**
- **محدودیت‌های کسب‌وکاری (invariants) را تعریف کند**

**اما:** مدل شما **نباید هر جزئیهٔ دامنه را شامل شود**؛ فقط **آنقدر جزئیات شامل کنید که برای حل مسئلهٔ خاص کافی باشد.**

## کوشش مستمر

 **تشکیل یک زبان یکپارچه یک فرآیند جاری است، نه یک‌باره:**

- **فقط تعامل با کارشناسان دامنه** می‌تواند **عدم‌دقت‌ها، فرض‌های غلط، یا سوءفهم‌های کلی** را فاش کند
- **تمام تیم باید مستمراً** از این زبان در تمام ارتباطات پروژه استفاده کنند: گفت‌وگو، اسناد، تست‌ها، کد
- **همیشه باید اعتبارسنجی و تکامل داده شود:** وقتی درک عمیق‌تری از دامنه حاصل شود، زبان باید با آن تطبیق یابد

---

# فصل ۳: مدیریت پیچیدگی دامین (Managing Domain Complexity) - بخش اول

## چالش مدل‌های ناسازگار (Inconsistent Models)

فصل با یادآوری اهمیت «زبان مشترک» (Ubiquitous Language) آغاز می‌شود. هدف ما این است که مدلی بسازیم که دقیقاً بازتاب‌دهنده‌ی مدل ذهنی متخصصان کسب‌وک‌کار (Domain Experts) باشد. اما یک مشکل بزرگ وجود دارد: **ذهنیت متخصصان کسب‌وکار همیشه یکپارچه نیست.**

نویسنده برای توضیح این مشکل، مثال شرکت «بازاریابی تلفنی» (Telemarketing) را که در فصل‌های قبل مطرح شده بود، دوباره باز می‌کند. در این شرکت دو دپارتمان اصلی وجود دارد:
1.  **دپارتمان مارکتینگ (Marketing):** مسئول تولید سرنخ (Lead) از طریق تبلیغات آنلاین.
2.  **دپارتمان فروش (Sales):** مسئول تماس با این سرنخ‌ها و تبدیل آن‌ها به مشتری.

نکته‌ی کلیدی و ظریف اینجاست که واژه‌ی **Lead (سرنخ)** در این دو دپارتمان معنای کاملاً متفاوتی دارد:

*   **از دید مارکتینگ:** یک `Lead` صرفاً یک «رویداد» یا نوتیفیکیشن است که می‌گوید "یک نفر علاقه نشان داده است". همین که اطلاعات تماس فرد را داشته باشند، کافی است.
*   **از دید فروش:** یک `Lead` یک موجودیت پیچیده و بلندمدت است. دارای چرخه حیات است (تماس گرفته شد، علاقه‌مند بود، جلسه ست شد، و غیره). برای آن‌ها `Lead` یک فرآیند است، نه فقط یک رخداد ساده.

### دوراهی طراحی (The Design Dilemma)

چگونه باید یک «زبان مشترک» برای این سیستم ساخت؟
*   اگر مدل پیچیده‌ی فروش را به مارکتینگ تحمیل کنیم، سیستم مارکتینگ را با جزئیاتی که نیازی به آن‌ها ندارد (مثل وضعیت مذاکره) پیچیده و سربار کرده‌ایم (Over-engineered).
*   اگر مدل ساده‌ی مارکتینگ را مبنا قرار دهیم، نیازهای دپارتمان فروش برای مدیریت فرآیند فروش برآورده نمی‌شود (Under-engineered).

در روش‌های سنتی، معمولاً سعی می‌شد یک **مدل واحد و بزرگ** (Single Model) برای کل سازمان ساخته شود (مثلاً نمودارهای ERD عظیم که تمام دیوارهای اتاق را می‌پوشاند). نویسنده تأکید می‌کند که این مدل‌ها مصداق بارز ضرب‌المثل "همه کاره و هیچ کاره" هستند. آن‌ها آنقدر شلوغ و پیچیده می‌شوند که نگهداری آن‌ها کابوس است و هیچکس دقیقاً نمی‌داند چه خبر است.

## راهکار: الگوی Bounded Context

راه‌حل Domain-Driven Design برای این مشکل ساده اما انقلابی است: **به جای تلاش برای ساختن یک مدل بزرگ و کامل، زبان مشترک را به چندین زبان کوچکتر تقسیم کنید و هر کدام را به یک «کانتکست» (Context) مشخص اختصاص دهید.**

به این الگو، **Bounded Context** گفته می‌شود.

در مثال بالا، ما باید دو کانتکست جداگانه داشته باشیم:
1.  **کانتکست مارکتینگ:** در اینجا `Lead` معنای ساده‌ی خودش را دارد.
2.  **کانتکست فروش:** در اینجا `Lead` معنای پیچیده و فرآیند-محور خودش را دارد.

تا زمانی که واژه‌ی `Lead` در داخل مرزهای هر کانتکست معنای واحد و مشخصی داشته باشد، ابهامی وجود نخواهد داشت. در DDD، ما این تضادها را پنهان نمی‌کنیم، بلکه آن‌ها را به عنوان بخش صریحی از طراحی مدل می‌پذیریم.

### مرزهای مدل (Model Boundaries)

نویسنده یک جمله‌ی بسیار عمیق در این بخش دارد:
> "یک مدل نمی‌تواند بدون مرز (Boundary) وجود داشته باشد؛ در غیر این صورت گسترش می‌یابد تا به کپیِ خودِ دنیای واقعی تبدیل شود."

همانطور که نقشه‌های جغرافیایی انواع مختلفی دارند (نقشه مترو، نقشه ناهمواری‌ها، نقشه سیاسی) و هر کدام فقط در کانتکست خودشان مفید هستند، مدل‌های نرم‌افزاری هم باید مرز مشخص داشته باشند. یک مدل در کانتکست مارکتینگ ممکن است برای کانتکست فروش کاملاً بی‌فایده یا گمراه‌کننده باشد.

بنابراین، **Bounded Context یعنی مرزِ اعمال‌شدنِ یک مدل خاص.**

## تعریف دقیق‌تر زبان مشترک (Ubiquitous Language Refined)

با معرفی Bounded Context، تعریف ما از «زبان مشترک» کامل‌تر می‌شود.
زبان مشترک به این معنی نیست که یک اصطلاح در **کل سازمان** یک معنی داشته باشد (که عملاً غیرممکن است). بلکه به این معنی است که آن اصطلاح در **داخل مرزهای Bounded Context خودش**، معنایی واحد، شفاف و بدون ابهام داشته باشد.

### محدوده یا اسکوپ (Scope)

اندازه‌ی یک Bounded Context چقدر باید باشد؟
این یک تصمیم استراتژیک در طراحی است. مرزها می‌توانند وسیع باشند (شامل چندین زیرمجموعه کاری) یا باریک و متمرکز.
*   **مزیت مرزهای وسیع:** یکپارچگی بیشتر بین اجزای داخلی.
*   **مزیت مرزهای باریک (کوچک):** مدیریت راحت‌تر مدل‌ها و امکان توسعه مستقل.

اما نویسنده هشدار می‌دهد که نباید در کوچک کردن کانتکست‌ها زیاده‌روی کرد. اگر یک عملکرد منسجم (Coherent Functionality) را بی‌دلیل به چند کانتکست خرد کنید، سربار یکپارچه‌سازی (Integration Overhead) افزایش می‌یابد.

---

# فصل ۳: مدیریت پیچیدگی دامین - بخش دوم

## Bounded Context در مقابل Subdomain

این قسمت از فصل به یک سوال مهم می‌پردازد: آیا **Bounded Context** و **Subdomain** یکی هستند؟

در فصل‌های قبل درباره‌ی Subdomain (core، generic، supporting) خواندیم. الآن باید متوجه شویم که این دو مفهوم کاملاً متفاوت هستند، اگرچه اغلب اوقات با هم اشتباه گرفته می‌شوند.

### Subdomain چیست؟

**Subdomain** یک **عنصر تجاری** است که در سازمان **کشف می‌شود**. یعنی زمانی که شما درباره‌ی کسب‌وکار تحقیق می‌کنید و فهمیدید که شرکت‌تان در کدام فعالیت‌های مختلف دست دارد، آن فعالیت‌ها را Subdomain می‌نامیم. 

برای مثال:
- در بانک، «پردازش وام» و «مدیریت حساب بانکی» دو Subdomain هستند.
- در Uber، «مطابقت سرایندگی با مسافر» و «پردازش پرداخت» دو Subdomain متفاوت‌اند.

**نکته مهم:** Subdomain‌ها بر اساس **استراتژی کسب‌وکار** شرکت تعریف می‌شوند، نه بر اساس تصمیمات فنی ما.

### Bounded Context چیست؟

**Bounded Context** برعکس، یک عنصر **نرم‌افزاری** و **طراحی‌شده** است. ما (تیم نرم‌افزار) تصمیم می‌گیریم که سیستم را به چه بخش‌هایی تقسیم کنیم، چگونه مدل‌ها را سازمان‌دهیم، و کدام اجزا مستقل‌اند.

**نکته مهم:** Bounded Context‌ها از جانب **مهندسان نرم‌افزار** طراحی می‌شوند، نه اینکه توسط کسب‌وکار تعریف شوند.

### فاصله بین این دو

اگرچه Subdomain و Bounded Context مفاهیم متفاوتی هستند، اما می‌توانند با هم ارتباط داشته باشند. نویسنده سناریوهای مختلفی را نشان می‌دهد:

#### سناریو ۱: یک Bounded Context بزرگ برای کل سیستم
![سیستم یکپارچه]
اگر سیستم کوچک است، ممکن است یک Bounded Context واحد برای کل سیستم کافی باشد، حتی اگر چندین Subdomain داخل آن وجود داشته باشد.

#### سناریو ۲: Bounded Context‌ها براساس تضاد در مدل‌ها
![Bounded Contexts متعدد]
زمانی که متخصصان کسب‌وکار مدل‌های متفاوتی از یک مفهوم دارند (مثل مثال Lead)، ما Bounded Context‌های جداگانه می‌سازیم.

#### سناریو ۳: Bounded Context‌ها همسو با Subdomain‌ها
![Aligned Boundaries]
در بسیاری از موارد عملی، هر Subdomain در یک Bounded Context جداگانه پیاده‌سازی می‌شود.

**نکته حیاتی:** نیست که یک Bounded Context باید دقیقاً با یک Subdomain تطابق داشته باشد. ما می‌توانیم:
- یک Subdomain را در چند Bounded Context مختلف مدل‌سازی کنیم (اگر نیاز به حل‌های مختلفی برای مسائل مختلف داشته باشیم).
- چندین Subdomain را در یک Bounded Context ادغام کنیم (اگر آن‌ها منسجم و بسیار تنگاتنگ باشند).

## مرزها: فیزیکی و مالکانه (Physical and Ownership Boundaries)

تا الآن فقط در مورد Bounded Context به‌عنوان یک مرز **مفهومی** (برای سازمان‌دهی مدل) صحبت کردیم. اما Bounded Context‌ها دارای ابعاد فیزیکی و سازمانی نیز هستند.

### مرزهای فیزیکی (Physical Boundaries)

**فیزیکی** به این معنی است که هر Bounded Context باید به‌عنوان یک **موجودیت مستقل و قابل استقلال** پیاده‌سازی شود. به‌عبارت دیگر:

- هر Bounded Context یک **پروژه جداگانه** است.
- هر Bounded Context می‌تواند با **Stack فنی متفاوت** پیاده‌سازی شود (اگر نیاز داشته باشد).
- هر Bounded Context **مستقل از دیگری نسخه‌ برداری می‌شود** (versioning).
- هر Bounded Context **جداگانه Deploy می‌شود**.

این استقلال فیزیکی در عمل بسیار اهمیت دارد، زیرا به تیم‌های مختلف این امکان را می‌دهد که در سرعت‌های متفاوت کار کنند و با فناوری‌های متفاوت.

### مرزهای مالکانه (Ownership Boundaries)

نویسنده یک قول معروف را نقل می‌کند: "Good fences do indeed make good neighbors" (نرده‌های خوب واقعاً همسایگان خوب می‌سازند).

در تیم‌های نرم‌افزار نیز همین اصل صدق می‌کند:

**قانون طلایی:** هر Bounded Context تنها **توسط یک تیم** می‌تواند مدیریت و توسعه داده شود. نه کمتر، نه بیشتر.

**نکته مهم:** یک تیم می‌تواند **چندین** Bounded Context را مدیریت کند، اما یک Bounded Context نمی‌تواند توسط دو تیم مختلف مدیریت شود.

#### چرا این قانون مهم است؟

1. **جلوگیری از فروپاشی ارتباط:** اگر دو تیم روی یک Bounded Context کار کنند، هر تیم فرضیات خود را در مورد مدل می‌کند و این فرضیات اغلب غلط و متناقض هستند.
2. **مسئولیت واضح:** هر کسی می‌داند کیست مسئول هر بخش.
3. **تصمیم‌گیری سریع:** یک تیم می‌تواند تصمیمات مرتبط با مدل خود را بدون بحث بی‌انتها بگیرد.
4. **طراحی API مشخص:** هر تیم باید API خود را به‌عنوان یک **قرارداد واضح** برای تیم‌های دیگر تعریف کند.

## Bounded Context در دنیای واقعی

نویسنده یک داستان بسیار جالب از یکی از شاگردانش در کلاس DDD نقل می‌کند:

> "شما گفتید DDD درباره‌ی تطابق طراحی نرم‌افزار با دامین‌های تجاری است. اما Bounded Context در دنیای واقعی کجا‌ند؟ در دنیای تجاری، Bounded Context وجود ندارد!"

پاسخ نویسنده جالب است: **Bounded Context‌ها در دنیای واقعی وجود دارند**، اما آن‌ها تا جایی که مدل‌های ذهنی متخصصان کسب‌وکار وجود دارند.

برای توضیح این مفهوم، نویسنده سه مثال غیرعادی از دنیای واقعی می‌آورد:

### مثال ۱: دامین‌های معنایی (Semantic Domains) - گوجه‌فرنگی

این مثال بسیار جالب است و نشان می‌دهد که Bounded Context فقط در نرم‌افزار نیست، بلکه در طبیعت و جامعه‌ی انسانی هم رایج است.

کلمه‌ی **گوجه‌فرنگی** معنای مختلفی در کانتکست‌های مختلف دارد:

#### کانتکست تحقیقات گیاهی (Botany):
- تعریف رسمی: یک **میوه** است (زیرا از گل گیاه رشد می‌کند و حداقل یک دانه دارد).
- سبزی: هر بخش دیگر از گیاه (ریشه، ساقه، برگ).
- **نتیجه:** گوجه‌فرنگی یک **میوه** است.

#### کانتکست آشپزی (Culinary Arts):
- تعریف: میوه‌ها نرم، شیرین یا ترش و خام قابل خوردن هستند.
- سبزی‌ها: بافت سخت‌تر، طعم خنثی، نیازمند پختن.
- **نتیجه:** گوجه‌فرنگی یک **سبزی** است.

#### کانتکست مالیاتی (Taxation):
- در سال ۱۸۸۳، ایالات متحده مالیات ۱۰٪ بر واردات سبزی‌ها وضع کرد، اما نه میوه‌ها.
- برای جلوگیری از اینکه تاجران گوجه‌فرنگی را میوه اعلام کنند و مالیات نپردازند، **قدیم‌ترین ستم‌اینی در تاریخ!**
- **نتیجه:** گوجه‌فرنگی یک **سبزی** است (براساس تصمیم دادگاه عالی سال ۱۸۹۳).

#### کانتکست تئاتر:
- همانطور که یک دوست نویسنده می‌گفت، در تئاتر گوجه‌فرنگی یک **مکانیزم بازخورد** است (وقتی بازیگر بد است، تماشاچیان گوجه‌فرنگی می‌اندازند!).

**درس:** یک موجودیت واقعی می‌تواند معنای کاملاً متفاوتی در کانتکست‌های مختلف داشته باشد. و این **نه تناقض** است، بلکه **طبیعی و منطقی** است.

### مثال ۲: فیزیک و نسبیت (Science)

نویسنده یک نقل‌قول از تاریخ‌دان معروف یوول نوح هاراری را می‌آورد:

> "دانشمندان عموماً موافقند که هیچ نظریه‌ی ۱۰۰ درصد صحیح نیست. بنابراین آزمون واقعی علم نه **حقیقت** است، بلکه **مفید بودن** است."

دو مثال:

**فیزیک نیوتنی:**
- فضا و زمان **مطلق** هستند (مانند یک صحنه‌ی تئاتر ثابت).
- بسیار دقیق برای حرکت اجسام روزمره.

**نظریه‌ی نسبیت اینشتین:**
- فضا و زمان **نسبی** هستند (متفاوت برای ناظران مختلف).
- برای سرعت‌های بسیار بالا و میدان‌های گرانشی قوی ضروری است.

آیا این دو نظریه **متناقض** هستند؟ بله. آیا هردو **مفید** هستند؟ بله، در کانتکست‌های متفاوت.

### مثال ۳: خریدن یخچال (Buying a Refrigerator)

یکی از مثال‌های عملی و جالب که نویسنده می‌آورد، تجربه‌ی خودش در خریدن یخچال است:

آپارتمان نویسنده درب ورودی استاندارد به آشپزخانه ندارد. او نمی‌دانست یخچال جدیدی که می‌خواست بخرد (Siemens KG86NAI31L) از درب آشپزخانه عبور کند یا نه.

**مدل اول - کاردبُرد:**
نویسنده یک تکه کاغذ را دقیقاً به ابعاد عرض و عمق یخچال بریده و آن را در درب آشپزخانه امتحان کرد.

*   آیا این کاغذ شبیه یخچال واقعی است؟ **نه، اصلاً نه!** بدون درب، بدون رنگ، بدون شکل اصلی.
*   آیا مفید بود؟ **بسیار مفید!**
*   چرا مفید است؟ **زیرا مشکل خاصی را حل می‌کند:** بررسی اینکه آیا یخچال عمود سطح زمین من از درب عبور می‌کند.

**مدل دوم - متر نوار:**
بعد از بررسی عمق، نویسنده نگران قد یخچال بود. آیا خیلی بلند است؟

کاغذ برای این مشکل کار نمی‌کرد. نویسنده برای **بررسی قد**، یک **متر نوار** استفاده کرد. این مدل دوم **ساده‌تر و راحت‌تر** بود.

**درس:**
این دقیقاً همان‌طور است که در DDD Bounded Context‌ها را طراحی می‌کنیم:
- ما می‌توانیم **چندین مدل متفاوت** از یک موجودیت داشته باشیم.
- هر مدل برای **حل یک مشکل خاص** طراحی می‌شود.
- یک مدل پیچیده‌تر (مثل ساخت یک مدل سه‌بعدی دقیق) بیشتر مفید نیست، بلکه **اضافی است** (Over-engineering).

## نتیجه‌گیری بخش دوم

سه درس کلیدی:

1. **Subdomain‌ها کشف می‌شوند؛ Bounded Context‌ها طراحی می‌شوند.** Subdomain‌ها از تحلیل کسب‌وکار بیرون می‌آیند. Bounded Context‌ها توسط مهندسان نرم‌افزار تصمیم‌گیری می‌شوند.

2. **هیچ قاعده‌ای برای نسبت یک‌به‌یک بین آن‌ها نیست.** یک Subdomain می‌تواند در چندین Bounded Context جدا مدل‌سازی شود. چندین Subdomain می‌تواند در یک Bounded Context ادغام شود.

3. **Bounded Context‌ها مرزهای مالکانه و فیزیکی دارند.** هر Bounded Context یک پروژه و تیم جداگانه است. این استقلال باعث می‌شود که تیم‌ها مستقل کار کنند و سریع‌تر تصمیم بگیرند.

---