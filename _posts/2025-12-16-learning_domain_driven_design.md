---
layout: post
full-width: true
title: Learning Domain Driven Design
subtitle: Aligning Software Architecture and Business Strategy
cover-img: /assets/images/learning_domain_driven_design.jpg
thumbnail-img: /assets/images/learning_domain_driven_design.jpg
share-img: /assets/images/learning_domain_driven_design.jpg
tags: [کتاب, مهندسی, برنامه_نویسی]
---

## توضیحات


## نظر


## نظر
 - `امتیاز` : 00/10
 - `به دیگران توصیه می‌کنم` : 
 - `دوباره می‌خوانم` : 
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : 
 - `انتشارات` : 

## بخش‌هایی از کتاب

# فصل اول: تحلیل حوزه‌های کسب‌وکار

## حوزه کسب‌وکار چیست؟

حوزه کسب‌وکار (Business Domain) حوزه اصلی فعالیت یک شرکت را تعریف می‌کند. به طور کلی، این خدمتی است که شرکت به مشتریان خود ارائه می‌دهد. به عنوان مثال:

- **FedEx** خدمات پست پیشتاز ارائه می‌دهد
- **Starbucks** بیشتر به خاطر قهوه‌اش شناخته می‌شود
- **Walmart** یکی از شناخته‌شده‌ترین فروشگاه‌های خرده‌فروشی است

یک شرکت می‌تواند در چندین حوزه کسب‌وکار فعالیت کند. به عنوان مثال، آمازون هم خدمات خرده‌فروشی و هم خدمات رایانش ابری ارائه می‌دهد. اوبر یک شرکت اشتراک‌گذاری سواری است که همچنین خدمات تحویل غذا و اشتراک‌گذاری دوچرخه را ارائه می‌دهد.

نکته مهم این است که شرکت‌ها ممکن است اغلب حوزه‌های کسب‌وکار خود را تغییر دهند. یک نمونه کلاسیک از این موضوع نوکیا است که در طول سال‌ها در زمینه‌های متنوعی مانند پردازش چوب، تولید لاستیک، مخابرات و ارتباطات تلفن همراه فعالیت کرده است.

## زیردامنه چیست؟

برای دستیابی به اهداف حوزه کسب‌وکار خود، یک شرکت باید در چندین **زیردامنه** (Subdomain) عمل کند. زیردامنه یک حوزه دقیق‌تر از فعالیت کسب‌وکار است. تمام زیردامنه‌های یک شرکت، حوزه کسب‌وکار آن را تشکیل می‌دهند: خدمتی که به مشتریان خود ارائه می‌دهد.

پیاده‌سازی یک زیردامنه واحد برای موفقیت یک شرکت کافی نیست؛ این فقط یک بلوک سازنده در سیستم کلی است. زیردامنه‌ها باید با یکدیگر تعامل کنند تا به اهداف شرکت در حوزه کسب‌وکارش برسند. 

به عنوان مثال، استارباکس ممکن است بیشتر به خاطر قهوه‌اش شناخته شود، اما ساخت یک زنجیره کافی‌شاپ موفق نیازمند بیش از دانستن نحوه تهیه قهوه عالی است. شما همچنین باید املاک را در مکان‌های مؤثر خریداری یا اجاره کنید، پرسنل استخدام کنید، امور مالی را مدیریت کنید و از جمله سایر فعالیت‌ها. هیچ‌یک از این زیردامنه‌ها به تنهایی یک شرکت سودآور نمی‌سازد. همه آن‌ها با هم برای اینکه شرکت بتواند در حوزه(های) کسب‌وکار خود رقابت کند، ضروری هستند.

## انواع زیردامنه‌ها

درست همانطور که یک سیستم نرم‌افزاری از اجزای معماری مختلف تشکیل شده است—پایگاه‌های داده، برنامه‌های فرانت‌اند، سرویس‌های بک‌اند و غیره—زیردامنه‌ها ارزش‌های استراتژیک/کسب‌وکاری متفاوتی دارند. طراحی مبتنی بر دامنه بین سه نوع زیردامنه تمایز قائل می‌شود: **اصلی** (Core)، **عمومی** (Generic) و **پشتیبان** (Supporting). بیایید ببینیم از دیدگاه استراتژی شرکت چگونه با هم متفاوت هستند.

### زیردامنه‌های اصلی (Core Subdomains)

زیردامنه اصلی چیزی است که یک شرکت متفاوت از رقبایش انجام می‌دهد. این ممکن است شامل اختراع محصولات یا خدمات جدید یا کاهش هزینه‌ها از طریق بهینه‌سازی فرآیندهای موجود باشد.

بیایید اوبر را به عنوان مثال در نظر بگیریم. در ابتدا، شرکت شکل جدیدی از حمل‌ونقل ارائه کرد: اشتراک‌گذاری سواری. با اینکه رقبایش به آن رسیدند، اوبر راه‌هایی برای بهینه‌سازی و تکامل کسب‌وکار اصلی خود پیدا کرد: به عنوان مثال، کاهش هزینه‌ها با تطبیق مسافرانی که به سمت یک جهت می‌روند.

زیردامنه‌های اصلی اوبر بر سود خالص آن تأثیر می‌گذارد. اینگونه است که شرکت خود را از رقبایش متمایز می‌کند. این استراتژی شرکت برای ارائه خدمات بهتر به مشتریان و/یا به حداکثر رساندن سودآوری خود است. برای حفظ مزیت رقابتی، زیردامنه‌های اصلی شامل اختراعات، بهینه‌سازی‌های هوشمند، دانش کسب‌وکار یا سایر مالکیت‌های فکری است.

**پیچیدگی**: یک زیردامنه اصلی که پیاده‌سازی آن ساده باشد تنها می‌تواند یک مزیت رقابتی کوتاه‌مدت فراهم کند. بنابراین، زیردامنه‌های اصلی به طور طبیعی پیچیده هستند. برای کسب‌وکار اصلی یک شرکت باید موانع ورود بالایی وجود داشته باشد؛ باید برای رقبا سخت باشد که راه‌حل شرکت را کپی یا تقلید کنند.

**منابع مزیت رقابتی**: مهم است که توجه کنید زیردامنه‌های اصلی لزوماً فنی نیستند. همه مشکلات کسب‌وکار از طریق الگوریتم‌ها یا سایر راه‌حل‌های فنی حل نمی‌شوند. مزیت رقابتی یک شرکت می‌تواند از منابع مختلفی ناشی شود.

### زیردامنه‌های عمومی (Generic Subdomains)

زیردامنه‌های عمومی فعالیت‌های کسب‌وکاری هستند که همه شرکت‌ها به همان روش انجام می‌دهند. مانند زیردامنه‌های اصلی، زیردامنه‌های عمومی به طور کلی پیچیده و سخت برای پیاده‌سازی هستند. با این حال، زیردامنه‌های عمومی هیچ مزیت رقابتی برای شرکت فراهم نمی‌کنند. نیازی به نوآوری یا بهینه‌سازی در اینجا نیست: پیاده‌سازی‌های آزموده‌شده به طور گسترده در دسترس هستند و همه شرکت‌ها از آن‌ها استفاده می‌کنند.

به عنوان مثال، بیشتر سیستم‌ها نیاز به احراز هویت و مجوزدهی کاربران خود دارند. به جای اختراع یک مکانیسم احراز هویت اختصاصی، منطقی‌تر است که از یک راه‌حل موجود استفاده شود. چنین راه‌حلی احتمالاً قابل اعتمادتر و امن‌تر خواهد بود چون قبلاً توسط بسیاری از شرکت‌های دیگر که نیازهای مشابهی دارند آزمایش شده است.

### زیردامنه‌های پشتیبان (Supporting Subdomains)

همانطور که از نام آن پیداست، زیردامنه‌های پشتیبان از کسب‌وکار شرکت پشتیبانی می‌کنند. با این حال، برخلاف زیردامنه‌های اصلی، زیردامنه‌های پشتیبان هیچ مزیت رقابتی ارائه نمی‌دهند.

به عنوان مثال، یک شرکت تبلیغات آنلاین را در نظر بگیرید که زیردامنه‌های اصلی آن شامل تطبیق تبلیغات با بازدیدکنندگان، بهینه‌سازی اثربخشی تبلیغات و به حداقل رساندن هزینه فضای تبلیغاتی است. با این حال، برای موفقیت در این زمینه‌ها، شرکت نیاز به فهرست‌بندی مواد خلاقانه خود دارد. نحوه ذخیره و نمایه‌سازی مواد خلاقانه فیزیکی مانند بنرها و صفحات فرود بر سود شرکت تأثیری ندارد. چیزی برای اختراع یا بهینه‌سازی در آن زمینه وجود ندارد. از طرف دیگر، کاتالوگ خلاقانه برای پیاده‌سازی سیستم‌های مدیریت تبلیغات و ارائه شرکت ضروری است. این امر راه‌حل فهرست‌بندی محتوا را به یکی از زیردامنه‌های پشتیبان شرکت تبدیل می‌کند.

ویژگی متمایز زیردامنه‌های پشتیبان، پیچیدگی منطق کسب‌وکار راه‌حل است. زیردامنه‌های پشتیبان ساده هستند. منطق کسب‌وکار آن‌ها عمدتاً شبیه به صفحات ورود داده و عملیات ETL (استخراج، تبدیل، بارگذاری) است؛ یعنی رابط‌های به اصطلاح CRUD (ایجاد، خواندن، به‌روزرسانی و حذف). این حوزه‌های فعالیت هیچ مزیت رقابتی برای شرکت فراهم نمی‌کنند و بنابراین نیازی به موانع ورود بالا ندارند.

## مقایسه زیردامنه‌ها

اکنون که درک بیشتری از سه نوع زیردامنه کسب‌وکار داریم، بیایید تفاوت‌های آن‌ها را از زوایای اضافی بررسی کنیم و ببینیم چگونه بر تصمیمات طراحی استراتژیک نرم‌افزار تأثیر می‌گذارند.

| **نوع زیردامنه** | **مزیت رقابتی** | **پیچیدگی** | **تغییرپذیری** | **پیاده‌سازی** | **مسئله** |
|---|---|---|---|---|---|
| اصلی (Core) | بله | بالا | بالا | داخلی | جالب |
| عمومی (Generic) | خیر | بالا | پایین | خرید/اتخاذ | حل‌شده |
| پشتیبان (Supporting) | خیر | پایین | پایین | داخلی/برون‌سپاری | واضح |

### مزیت رقابتی

تنها زیردامنه‌های اصلی مزیت رقابتی به شرکت ارائه می‌دهند. زیردامنه‌های اصلی استراتژی شرکت برای متمایز کردن خود از رقبایش هستند.

زیردامنه‌های عمومی، طبق تعریف، نمی‌توانند منبعی برای مزیت رقابتی باشند. اینها راه‌حل‌های عمومی هستند—همان راه‌حل‌هایی که توسط شرکت و رقبایش استفاده می‌شود.

زیردامنه‌های پشتیبان نیز موانع ورود پایینی دارند و نمی‌توانند مزیت رقابتی ارائه دهند. معمولاً یک شرکت برایش مشکلی نیست که رقبایش زیردامنه‌های پشتیبان او را کپی کنند—این موضوع بر رقابت‌پذیری آن در صنعت تأثیری نخواهد گذاشت.

### پیچیدگی

از دیدگاه فنی‌تر، شناسایی زیردامنه‌های سازمان مهم است، زیرا انواع مختلف زیردامنه‌ها دارای سطوح مختلفی از پیچیدگی هستند. هنگام طراحی نرم‌افزار، باید ابزارها و تکنیک‌هایی را انتخاب کنیم که با پیچیدگی الزامات کسب‌وکار سازگار باشند.

**زیردامنه‌های پشتیبان**: منطق کسب‌وکار ساده است. اینها عملیات اساسی ETL و رابط‌های CRUD هستند و منطق کسب‌وکار واضح است. اغلب، فراتر از اعتبارسنجی ورودی‌ها یا تبدیل داده‌ها از یک ساختار به ساختار دیگر نمی‌رود.

**زیردامنه‌های عمومی**: بسیار پیچیده‌تر هستند. باید دلیل خوبی وجود داشته باشد که چرا دیگران قبلاً زمان و تلاش خود را صرف حل این مشکلات کرده‌اند. این راه‌حل‌ها نه ساده و نه بدیهی هستند. به عنوان مثال، الگوریتم‌های رمزنگاری یا مکانیسم‌های احراز هویت را در نظر بگیرید.

**زیردامنه‌های اصلی**: پیچیده هستند. آن‌ها باید تا حد امکان برای رقبا سخت باشند که کپی کنند—سودآوری شرکت به آن بستگی دارد. به همین دلیل است که از نظر استراتژیک، شرکت‌ها به دنبال حل مسائل پیچیده به عنوان زیردامنه‌های اصلی خود هستند.

---

# فصل اول - بخش دوم: شناسایی مرزهای زیردامنه‌ها و تحلیل دامنه

## شناسایی مرزهای زیردامنه‌ها

همانطور که دیدید، شناسایی زیردامنه‌ها و انواع آن‌ها می‌تواند به طور قابل توجهی در اتخاذ تصمیمات مختلف طراحی هنگام ساخت راه‌حل‌های نرم‌افزاری کمک کند. در فصل‌های بعدی، راه‌های بیشتری برای استفاده از زیردامنه‌ها جهت ساده‌سازی فرآیند طراحی نرم‌افزار خواهید آموخت. اما چگونه در واقع زیردامنه‌ها و مرزهای آن‌ها را شناسایی می‌کنیم؟

زیردامنه‌ها و انواع آن‌ها توسط **استراتژی کسب‌وکار شرکت** تعریف می‌شوند: حوزه‌های کسب‌وکار آن و نحوه متمایز شدن برای رقابت با سایر شرکت‌ها در همان زمینه. در اکثریت قریب به اتفاق پروژه‌های نرم‌افزاری، به یک شکل یا شکل دیگر، زیردامنه‌ها "از قبل آنجا هستند". این به این معنا نیست که همیشه شناسایی مرزهای آن‌ها آسان و مستقیم است. اگر از یک مدیرعامل بخواهید فهرستی از زیردامنه‌های شرکتش را به شما بدهد، احتمالاً با نگاهی خالی روبرو خواهید شد. آن‌ها از این مفهوم آگاه نیستند. بنابراین، باید خودتان تحلیل دامنه را انجام دهید تا زیردامنه‌های موجود را شناسایی و دسته‌بندی کنید.

### نقطه شروع خوب: واحدهای سازمانی

یک نقطه شروع خوب، **دپارتمان‌های شرکت و سایر واحدهای سازمانی** است. به عنوان مثال، یک فروشگاه خرده‌فروشی آنلاین ممکن است شامل دپارتمان‌های انبار، خدمات مشتری، انتخاب کالا، حمل‌ونقل، کنترل کیفیت و مدیریت کانال‌ها و از جمله سایر موارد باشد.

با این حال، اینها حوزه‌های نسبتاً درشت‌دانه‌ای از فعالیت هستند. به عنوان مثال، دپارتمان خدمات مشتری را در نظر بگیرید. منطقی است که فرض کنیم این یک زیردامنه پشتیبان یا حتی یک زیردامنه عمومی باشد، زیرا این عملکرد اغلب به فروشندگان شخص ثالث برون‌سپاری می‌شود. اما آیا این اطلاعات برای ما کافی است تا تصمیمات طراحی نرم‌افزاری صحیحی بگیریم؟

### تقطیر زیردامنه‌ها (Distilling Subdomains)

زیردامنه‌های درشت‌دانه یک نقطه شروع خوب هستند، اما **شیطان در جزئیات نهفته است**. ما باید مطمئن شویم که اطلاعات مهمی را که در پیچیدگی‌های عملکرد کسب‌وکار پنهان شده است، از دست نمی‌دهیم.

بیایید به مثال دپارتمان خدمات مشتری برگردیم. اگر عملکرد داخلی آن را بررسی کنیم، خواهیم دید که یک دپارتمان خدمات مشتری معمولی از **اجزای دقیق‌تر** تشکیل شده است، مانند:

- سیستم Help Desk
- مدیریت شیفت و زمان‌بندی
- سیستم تلفنی
- و غیره

زمانی که به عنوان زیردامنه‌های جداگانه نگاه می‌شوند، این فعالیت‌ها می‌توانند از انواع مختلفی باشند:

- **سیستم‌های Help Desk و تلفنی**: زیردامنه‌های عمومی هستند
- **مدیریت شیفت**: یک زیردامنه پشتیبان است
- **الگوریتم مسیریابی**: ممکن است یک شرکت الگوریتم نابغه‌ای برای مسیریابی حوادث به نمایندگانی که با موارد مشابه در گذشته موفق بوده‌اند، توسعه دهد

الگوریتم مسیریابی نیازمند تحلیل موارد ورودی و شناسایی شباهت‌ها در تجربیات گذشته است—هر دوی اینها وظایف غیربدیهی هستند. از آنجا که الگوریتم مسیریابی به شرکت اجازه می‌دهد تجربه مشتری بهتری نسبت به رقبایش ارائه دهد، **الگوریتم مسیریابی یک زیردامنه اصلی است**.

```
دپارتمان خدمات مشتری
├── سیستم Help Desk (عمومی)
├── سیستم تلفنی (عمومی)
├── مدیریت شیفت (پشتیبان)
└── الگوریتم مسیریابی هوشمند (اصلی) ⭐
```

از طرف دیگر، ما نمی‌توانیم به طور نامحدود به دنبال بینش‌ها در سطوح پایین‌تر و پایین‌تر از دانه‌بندی باشیم. چه زمانی باید متوقف شوید؟

### زیردامنه‌ها به عنوان مجموعه‌ای از Use Case های منسجم

از دیدگاه فنی، زیردامنه‌ها شبیه به **مجموعه‌ای از Use Case های مرتبط و منسجم** هستند. چنین مجموعه‌ای از Use Case ها معمولاً شامل موارد زیر می‌شوند:

- همان بازیگر (Actor)
- موجودیت‌های کسب‌وکاری مشابه
- همه آن‌ها یک مجموعه داده نزدیک به هم را دستکاری می‌کنند

#### مثال: دیاگرام Use Case برای درگاه پرداخت کارت اعتباری

Use Case های زیر را در نظر بگیرید که همگی به **زیردامنه پرداخت کارت اعتباری** تعلق دارند:

```
بازیگران:
- مشتری
- سیستم بانکی
- فروشنده

Use Case ها:
├── پردازش پرداخت
├── بررسی اعتبار کارت
├── تأیید تراکنش
├── بازپرداخت
└── گزارش تراکنش‌ها
```

این Use Case ها به شدت توسط داده‌هایی که با آن کار می‌کنند و بازیگران درگیر به هم مرتبط هستند. بنابراین، همه Use Case ها **زیردامنه پرداخت کارت اعتباری** را تشکیل می‌دهند.

### چه زمانی باید تقطیر را متوقف کنیم؟

می‌توانیم از تعریف "زیردامنه‌ها به عنوان مجموعه‌ای از Use Case های منسجم" به عنوان **اصل راهنما** برای زمانی که باید به دنبال زیردامنه‌های دقیق‌تر بگردیم استفاده کنیم. اینها دقیق‌ترین مرزهای زیردامنه‌ها هستند.

#### برای زیردامنه‌های اصلی: تقطیر کامل ضروری است

آیا همیشه باید بکوشید چنین مرزهای زیردامنه‌ای متمرکز را شناسایی کنید؟ برای **زیردامنه‌های اصلی** قطعاً ضروری است. زیردامنه‌های اصلی مهم‌ترین، متغیرترین و پیچیده‌ترین هستند. ضروری است که آن‌ها را تا حد امکان تقطیر کنیم زیرا این امر به ما اجازه می‌دهد همه عملکردهای عمومی و پشتیبان را استخراج کنیم و تلاش را روی عملکردهای بسیار متمرکزتری سرمایه‌گذاری کنیم.

#### برای زیردامنه‌های پشتیبان و عمومی: تقطیر آسان‌تر

تقطیر می‌تواند تا حدودی برای زیردامنه‌های پشتیبان و عمومی **آسان‌تر** باشد. اگر رفتن به عمق بیشتر بینش‌های جدیدی را که می‌تواند به شما کمک کند تصمیمات طراحی نرم‌افزار بگیرید، آشکار نکند، می‌تواند مکان خوبی برای توقف باشد. این می‌تواند، به عنوان مثال، زمانی اتفاق بیفتد که همه زیردامنه‌های دقیق‌تر از همان نوع زیردامنه اصلی باشند.

مثال زیر را در نظر بگیرید:

```
سیستم Help Desk (عمومی)
├── مدیریت تیکت (عمومی)
├── پایگاه دانش (عمومی)
├── گزارش‌گیری (عمومی)
└── مدیریت SLA (عمومی)
```

تقطیر بیشتر زیردامنه سیستم Help Desk کمتر مفید است، زیرا اطلاعات استراتژیک جدیدی را آشکار نمی‌کند و یک ابزار آماده درشت‌دانه به عنوان راه‌حل استفاده خواهد شد.

## تمرکز روی موارد ضروری

زیردامنه‌ها ابزاری هستند که فرآیند اتخاذ تصمیمات طراحی نرم‌افزار را تسهیل می‌کنند. همه سازمان‌ها احتمالاً عملکردهای کسب‌وکاری کاملاً زیادی دارند که مزیت رقابتی آن‌ها را هدایت می‌کنند اما **هیچ ارتباطی با نرم‌افزار ندارند**. سازنده جواهرات که قبلاً در این فصل بحث کردیم تنها یک مثال است.

هنگام جستجوی زیردامنه‌ها، مهم است که:
1. عملکردهای کسب‌وکاری که به نرم‌افزار مرتبط نیستند را شناسایی کنید
2. آن‌ها را به عنوان چنین چیزی تأیید کنید
3. روی جنبه‌های کسب‌وکار که به سیستم نرم‌افزاری که روی آن کار می‌کنید مرتبط هستند، تمرکز کنید

---

# فصل اول - بخش سوم: تحلیل دامنه با مثالهای عملی - Gigmaster و BusVNext

## مثال اول: Gigmaster - شرکت فروش بلیت

### معرفی شرکت

**Gigmaster** یک شرکت فروش و توزیع بلیت است. اپلیکیشن موبایلی آن کتابخانه موسیقی کاربران، حساب‌های سرویس‌های جریانی (مثل Spotify) و پروفایل‌های شبکه‌های اجتماعی را تحلیل می‌کند تا برنامه‌های موسیقی نزدیک را که کاربران علاقه‌مند به حضور در آن‌ها هستند، شناسایی کند.

کاربران Gigmaster نسبت به حریم‌خصوصی آن‌ها توجه زیادی دارند. بنابراین، **تمام اطلاعات شخصی کاربران رمزگذاری می‌شوند**. علاوه بر این، برای اطمینان از اینکه ترجیحات موسیقی "عجیب‌وغریب" کاربران به هیچ شرایطی فاش نشود، **الگوریتم توصیه‌های شرکت منحصراً با داده‌های ناشناس‌شده کار می‌کند**.

یک ماژول جدید اخیراً اضافه شده است که به کاربران امکان می‌دهد برنامه‌های موسیقی را که در گذشته حضور داشته‌اند را ثبت کنند، حتی اگر بلیت‌ها از طریق Gigmaster خریداری نشده باشند.

### تحلیل دامنه

#### **حوزه کسب‌وکار**

حوزه کسب‌وکار Gigmaster **فروش بلیت** است. این خدمتی است که شرکت به مشتریانش ارائه می‌دهد.

#### **زیردامنه‌های اصلی (Core Subdomains)**

**مزیت رقابتی اصلی** Gigmaster **الگوریتم توصیه‌های آن** است. این الگوریتم توانایی شرکت را بر میل و علایق اضافی کاربران تا سطح دقیق دارند:

- **الگوریتم توصیه‌های هوشمند**: این قلب سیستم است و کاربران را به برنامه‌هایی راهنمایی می‌کند که واقعاً علاقه‌مند هستند
- **ناشناس‌سازی داده‌ها**: شرکت بر روی حریم‌خصوصی تأکید زیادی دارد و این عملکرد رقابتی است زیرا کاربران می‌دانند اطلاعات آن‌ها محافظت‌شده است
- **تجربه کاربری موبایل (UX)**: رابط کاربری تمیز و قابل استفاده یک عامل کلیدی در جذب و حفظ کاربران است

**بنابراین، زیردامنه‌های اصلی Gigmaster عبارت‌اند از:**
- الگوریتم توصیه‌ها ⭐
- ناشناس‌سازی داده‌ها ⭐  
- اپلیکیشن موبایل ⭐

#### **زیردامنه‌های عمومی (Generic Subdomains)**

اینها مسائلی هستند که **هر شرکت فروش حل می‌کند** و راه‌حل‌های آماده وجود دارند:

- **رمزنگاری**: برای رمزگذاری تمام داده‌ها
- **حسابداری**: چون شرکت در تجارت فروش است
- **Clearing**: برای شارژ کردن مشتریان
- **احراز هویت و مجوزدهی**: برای شناسایی کاربران

#### **زیردامنه‌های پشتیبان (Supporting Subdomains)**

اینها عملکردهای ساده هستند که به سیستم اصلی کمک می‌کنند اما **هیچ مزیت رقابتی ندارند**:

- **ادغام با سرویس‌های موسیقی جریانی**: درخواست داده‌ها از Spotify، Apple Music و غیره
- **ادغام با شبکه‌های اجتماعی**: خواندن پروفایل‌ها
- **ماژول برنامه‌های حضور یافته**: ذخیره داده‌های تاریخی برنامه‌هایی که کاربر حضور داشته است

### تصمیمات طراحی استراتژیک

از دانستن اینکه کدام زیردامنه‌ها در کدام دسته قرار دارند، می‌توانیم **تصمیمات طراحی استراتژیک** بگیریم:

| **زیردامنه** | **نوع** | **تصمیم طراحی** |
|---|---|---|
| الگوریتم توصیه‌ها | اصلی | باید با تکنیک‌های پیشرفته برنامه‌نویسی توسط تیم در‌خانه پیاده‌سازی شود |
| ناشناس‌سازی | اصلی | باید با دقت بالا در‌خانه پیاده‌سازی شود (حتی ممکن است متخصص امنیت لازم باشد) |
| تجربه موبایل | اصلی | طراحی رابط کاربری باید توسط تیم ماهر انجام شود |
| رمزنگاری، حسابداری، Clearing | عمومی | می‌توان از راه‌حل‌های آماده یا کتابخانه‌های منتشرشده استفاده کرد |
| احراز هویت | عمومی | استفاده از سرویس‌های مثل Auth0 یا OAuth معقول است |
| ادغام با سرویس‌های خارجی | پشتیبان | می‌تواند برون‌سپاری شود |
| ماژول برنامه‌های حضور یافته | پشتیبان | می‌تواند برون‌سپاری شود |

## مثال دوم: BusVNext - شرکت حمل‌ونقل عمومی

### معرفی شرکت

**BusVNext** یک شرکت حمل‌ونقل عمومی است که هدفش ارائه سفر‌های اتوبوس مراتب است که آن‌قدر راحت و مطلوب باشد که تجربه‌ای مشابه با تاکسی داشته باشد. شرکت ناوگان اتوبوس‌هایی را در شهرهای بزرگ مدیریت می‌کند.

**مشتری BusVNext** می‌تواند از طریق اپلیکیشن موبایل یک سفر سفارش دهد. در زمان حضور برنامه‌ریزی‌شده، **مسیر یک اتوبوس نزدیک به صورت لحظه‌ای تنظیم می‌شود** تا مسافر را در زمان تعیین‌شده برداشت کند.

**چالش اصلی** BusVNext پیاده‌سازی **الگوریتم مسیریابی** بود. الزامات آن یک گونه از **مسئله فروشنده دوره‌گرد** (Travelling Salesman Problem) است. منطق مسیریابی به طور مستمر تنظیم و بهینه‌سازی می‌شود. مثلاً آمارها نشان می‌دهند **دلیل اصلی لغو سفرها زمان انتظار زیاد برای اتوبوس است**. بنابراین شرکت **الگوریتم مسیریابی را برای اولویت دادن به برداشت سریع تغییر داد**، حتی اگر این معنای تاخیری بیشتر در رسیدن باشد.

### تحلیل دامنه

#### **حوزه کسب‌وکار**

حوزه کسب‌وکار BusVNext **حمل‌ونقل عمومی بهینه‌شده** است.

#### **زیردامنه‌های اصلی (Core Subdomains)**

**مزیت رقابتی اصلی** BusVNext از بین رفتن یا کاهش دادن این مسائل است:

- **الگوریتم مسیریابی هوشمند**: حل یک مسئله پیچیده ریاضی (TSP) با تطبیق به اهداف تجاری متفاوت—کاهش زمان برداشت حتی اگر طول کل سفر افزایش یابد
- **تحلیل داده‌های سفرها**: شرکت **به طور مستمر سفرها را تحلیل می‌کند** تا الگوهای رفتار مسافران را کشف کند و الگوریتم مسیریابی را بهتر بسازد
- **تجربه کاربری اپلیکیشن**: هم برای مسافران و هم برای رانندگان، رابط ساده و واضح ضروری است
- **مدیریت ناوگان**: اتوبوس‌ها می‌توانند مشکلات فنی داشته باشند و نیاز به تعمیر دارند. نادیده گرفتن این موضوع ممکن است به تلفات مالی و کاهش سطح خدمات منجر شود

**بنابراین، زیردامنه‌های اصلی BusVNext عبارت‌اند از:**
- مسیریابی ⭐
- تحلیل داده‌ها ⭐
- تجربه کاربری موبایل ⭐
- مدیریت ناوگان ⭐

#### **زیردامنه‌های عمومی (Generic Subdomains)**

- **داده‌های ترافیک و هشدارهای بلادرنگ**: شرکت **از شرکت‌های شخص ثالث** برای دریافت اطلاعات ترافیکی استفاده می‌کند
- **حسابداری**: مدیریت درآمد‌ها
- **صورتحساب**: ایجاد صورتحسابهایی برای مشتریان
- **احراز هویت و مجوزدهی**

#### **زیردامنه‌های پشتیبان (Supporting Subdomains)**

- **مدیریت تخفیف‌ها و پیش‌نهادهای ویژه**: این ماژول از نظر منطق کسب‌وکار **بسیار ساده است**—فقط **رابط کاربری CRUD برای مدیریت کدهای کوپن فعال**. شرکت این تخفیف‌ها را برای جذب مشتریان جدید و تعدیل تقاضا در اوقات اوج و کم استفاده می‌کند

### تصمیمات طراحی استراتژیک

| **زیردامنه** | **نوع** | **تصمیم طراحی** |
|---|---|---|
| الگوریتم مسیریابی | اصلی | باید با بالاترین سطح تکنیک‌های مهندسی در‌خانه پیاده‌سازی شود |
| تحلیل داده‌ها | اصلی | باید درون‌سازی شود (ممکن است به Machine Learning و Data Science نیاز باشد) |
| مدیریت ناوگان | اصلی | متخصصان و سیستم‌های پیشرفته لازم است |
| تجربه کاربری | اصلی | توسط تیم ماهر طراحی شود |
| داده‌های ترافیک | عمومی | از سرویس‌های شخص ثالث (مثل Google Maps API) استفاده شود |
| حسابداری و صورتحساب | عمومی | از نرم‌افزار حسابداری آماده یا سرویس ابری استفاده شود |
| احراز هویت | عمومی | استفاده از سرویس‌های مثل OAuth یا شرکای احراز هویت |
| مدیریت تخفیف‌ها | پشتیبان | **می‌تواند برون‌سپاری شود** یا توسط تیم درحال‌آموزش پیاده‌سازی شود |
| بررسی ترافیک | عمومی | خریداری از شرکت‌های بیرونی |

## خلاصه تحلیل‌های دو مثال

### اهمیت این تحلیل‌ها

این دو مثال نشان می‌دهند که **چگونه یک تحلیل دامنه صحیح** می‌تواند تصمیمات زیادی را هدایت کند:

1. **بودجه‌بندی و تخصیص منابع**: منابع بیشتر باید به زیردامنه‌های اصلی اختصاص داده شود

2. **تشکیل تیم**: تیم‌های ماهر برای سیستم‌های اصلی، و تیم‌های کم‌تجربه برای سیستم‌های پشتیبان

3. **معماری سیستم**: زیردامنه‌های اصلی نیاز به معماری و طراحی پیچیده‌تری دارند

4. **برون‌سپاری یا توسعه درون‌سازی**: تصمیم واضح درباره آنچه باید درون‌سازی شود و آنچه باید خریداری شود

---

## کارشناسان دامنه چه کسانی هستند؟

کارشناس دامنه یعنی فرد (یا افرادی) که ریزه‌کاری‌های کسب‌وکاریِ «دامنه‌ای که قرار است نرم‌افزارش را بسازیم» را عمیقاً می‌شناسند و مرجع اصلی دانش همان کسب‌وکار هستند.
این افراد نه تحلیلگر نیازمندی‌اند و نه مهندس نرم‌افزار؛ آن‌ها نماینده «کسب‌وکار» هستند و دانشی که تحلیلگران و مهندسان با آن کار می‌کنند، نهایتاً از ذهن و تجربه همین افراد می‌آید.
به بیان دقیق‌تر، تحلیلگرها و مهندسان تلاش می‌کنند مدل ذهنیِ کارشناس دامنه از کسب‌وکار را به نیازمندی‌ها و سپس به کد تبدیل کنند.

## چرا نقششان حیاتی است؟

هدف نرم‌افزار حل مسائل و نیازهای همان کسب‌وکار است، پس اگر منبع دانش درست در فرایند حضور نداشته باشد، تیم فنی ناچار می‌شود بر اساس حدس، برداشت‌های ناقص یا اصطلاحات مبهم تصمیم‌گیری کند.
کتاب تأکید می‌کند که دانش دامنه «منشأ» دارد و آن منشأ، کارشناسان دامنه‌اند؛ بنابراین کیفیت طراحی و پیاده‌سازی به کیفیت ارتباط و انتقال دانش از آن‌ها وابسته است.

## چه کسانی معمولاً کارشناس دامنه‌اند؟

کتاب یک قاعده سرانگشتی می‌دهد: کارشناسان دامنه معمولاً یا همان کسانی‌اند که نیازمندی‌ها را مطرح می‌کنند، یا همان کاربران نهایی سیستم که نرم‌افزار قرار است مشکلاتشان را حل کند.
دامنه تخصص آن‌ها هم می‌تواند متفاوت باشد: بعضی‌ها کل کسب‌وکار را خوب می‌شناسند و بعضی فقط در یک یا چند زیردامنه متخصص‌اند.
مثلاً در یک آژانس تبلیغات آنلاین، نمونه‌هایی از کارشناسان دامنه می‌توانند مدیران کمپین، خریداران رسانه و تحلیلگران کسب‌وکار باشند.

## نکته آموزشی برای شما

از همین‌جا یک پیام عملی برای طراحی نرم‌افزار بیرون می‌آید: وقتی «زیردامنه‌ها» را تشخیص می‌دهید، باید هم‌زمان مشخص کنید برای هر زیردامنه چه کسی «مرجع حقیقت» است (چه کسی واقعاً جواب درست را می‌داند).
در عمل، هرچه زیردامنه به سمت «اصلی/رقابتی» بودن می‌رود، نیاز به دسترسی نزدیک‌تر و دائمی‌تر به کارشناسان دامنه بیشتر می‌شود، چون همان‌جا ابهام و تغییر زیاد است.

---

## تمرین‌های ۱ تا ۳ (چندگزینه‌ای)

### ۱) کدام زیردامنه(ها) هیچ مزیت رقابتی ایجاد نمی‌کنند؟
پاسخ: **عمومی و پشتیبان**.  
منطق: زیردامنهٔ اصلی همان جایی است که شرکت «متفاوت» عمل می‌کند و مزیت رقابتی می‌سازد؛ اما زیردامنهٔ عمومی و پشتیبان قرار نیست شرکت را از رقبا متمایز کنند.

### ۲) برای کدام زیردامنه ممکن است همهٔ رقبا از راه‌حل یکسان استفاده کنند؟
پاسخ: **زیردامنهٔ عمومی**.  
منطق: عمومی یعنی مسئله‌ای حل‌شده و استاندارد که شرکت‌ها معمولاً از راه‌حل‌های آماده/متداول استفاده می‌کنند (مثل احراز هویت یا رمزنگاری).

### ۳) کدام زیردامنه انتظار می‌رود بیشترین تغییر را داشته باشد؟
پاسخ: **زیردامنهٔ اصلی**.  
منطق: چون منبع مزیت رقابتی است، دائماً باید تکامل پیدا کند؛ شرکت‌ها مدام آن را بهینه می‌کنند تا عقب نمانند.

## تمرین‌های ۴ تا ۷ (سناریوی WolfDesk)

کتاب می‌گوید WolfDesk یک شرکت «سیستم مدیریت تیکت‌های هلپ‌دسک» ارائه می‌دهد. برای حل تمرین‌ها، ابتدا یک روش گام‌به‌گام داشته باشید:

1) اول «خدمت اصلی به مشتری» را پیدا کنید ⇒ این می‌شود حوزهٔ کسب‌وکار.  
2) بعد بپرسید «چه چیزی باعث برتری این شرکت نسبت به رقبا می‌شود؟» ⇒ این می‌شود زیردامنهٔ اصلی.  
3) سپس «چه چیزهایی استاندارد و قابل خریدن است؟» ⇒ زیردامنهٔ عمومی.  
4) و در نهایت «چه چیزهایی لازم است ولی مزیت رقابتی نیست و منطق ساده دارد؟» ⇒ زیردامنهٔ پشتیبان.

حالا پاسخ‌ها:

### ۴) حوزهٔ کسب‌وکار WolfDesk چیست؟
به احتمال زیاد: **مدیریت تیکت‌های پشتیبانی/هلپ‌دسک** (Help Desk Ticket Management).  
یعنی ارزش پیشنهادی شرکت: دریافت، پیگیری، اولویت‌بندی و حل درخواست‌های پشتیبانی مشتریان.

### ۵) زیردامنه(های) اصلی WolfDesk چیست؟
این بستگی دارد WolfDesk دقیقاً با چه چیزی رقابت می‌کند، اما معمولاً موارد زیر می‌تواند «اصلی» باشد اگر واقعاً عامل تمایز شرکت باشد:
- الگوریتم/منطق **مسیریابی هوشمند تیکت‌ها** (تخصیص تیکت به بهترین کارشناس بر اساس مهارت/تجربه/موضوع).
- **اتوماسیون گردش‌کار** و قوانین پیچیدهٔ SLA (اگر واقعاً نوآورانه و خاص باشد).
- **تجربهٔ کاربری** بسیار برتر برای اپراتورها و مدیران (اگر مزیت رقابتی اصلی محصول باشد).

نکتهٔ کلیدی: «فقط داشتن صفحهٔ ثبت تیکت» معمولاً مزیت رقابتی نیست؛ مزیت رقابتی در هوشمندی، اتوماسیون، و کیفیت تجربهٔ کاربری یا بینش‌های تحلیلی است.

### ۶) زیردامنه(های) پشتیبان WolfDesk چیست؟
مواردی که لازم‌اند اما معمولاً منطق ساده‌تری دارند و شرکت با آن‌ها متمایز نمی‌شود، مثل:
- **مدیریت کاربران سازمانی/تیم‌ها/شیفت‌ها** (اگر صرفاً CRUD باشد).
- **تنظیمات پروژه‌ها، دسته‌بندی‌ها، برچسب‌ها**.
- **مدیریت قالب‌های پاسخ** و متن‌های آماده (اگر ساده باشد).
اینها معمولاً همان «کارهای ضروری ولی نه استراتژیک» هستند.

### ۷) زیردامنه(های) عمومی WolfDesk چیست؟
موارد استاندارد و قابل خرید/اتخاذ که همه دارند:
- **احراز هویت و مجوزدهی** (SSO، OAuth، SAML و…).
- **ارسال ایمیل/پیامک/نوتیفیکیشن** (اغلب از سرویس‌های عمومی استفاده می‌شود).
- **پرداخت، صورتحساب و حسابداری** (اگر SaaS باشد و فروش اشتراک داشته باشد).
- گاهی **جست‌وجوی متن** یا **گزارش‌گیری عمومی** هم می‌تواند عمومی تلقی شود اگر راه‌حل‌های آمادهٔ قوی وجود داشته باشد.

---
---

# فصل دوم: کشف دانش دامنه - بخش اول: مسائل کسب‌وکاری و اهمیت ارتباط

مقدمهٔ فصل دوم با یک نقل‌قول الهام‌بخش از **Alberto Brandolini** شروع می‌شود:

> «کدی که از سوءفهم توسعه‌دهندگان به‌وجود می‌آید، نه از دانش صحیح کارشناسان دامنه، وارد محیط تولیدی می‌شود.»

این جمله خلاصهٔ کل فصل دوم است: **مشکل اصلی پروژه‌های نرم‌افزاری انتقال دانش است.**

## تاریخچه‌ای از فصل یک

فصل قبل (فصل اول) بر روی **سطح استراتژیک** تمرکز داشت: تحلیل حوزه کسب‌وکار، شناسایی زیردامنه‌ها و انواع آن‌ها.

فصل دوم سطح **عمیق‌تری** را مطالعه می‌کند: درون یک زیردامنه چه اتفاقی رخ می‌دهد؟ منطق کسب‌وکاری و فرآیندهایش چگونه است؟

## مسائل کسب‌وکاری (Business Problems)

اول باید دقیق کنیم: **«مسئلهٔ کسب‌وکار» با «مسئلهٔ ریاضی» متفاوت است.**

یک مسئلهٔ ریاضی چیزی است که می‌توانید **حل کنید و تمام باشد**. اما مسئلهٔ کسب‌وکار چیزی است که **شرکت‌ها مدام با آن دست‌وپنجه‌نرم می‌کنند.**

نمونه‌های مسائل کسب‌وکاری:

- بهینه‌سازی جریان‌های کاری و فرآیندها
- کاهش کار دستی
- مدیریت منابع
- پشتیبانی در تصمیم‌گیری
- مدیریت و نظم‌دهی داده‌ها

این مسائل در **سطح حوزهٔ کسب‌وکار کلان و در سطح زیردامنه‌های خاص** نمایان می‌شوند.

**نمونه ملموس:** شرکت **FedEx** (از فصل یک) برای حل مسئلهٔ کسب‌وکاریِ مشتریانش («نیاز به فرستادن بسته‌ها در زمان محدود») فرآیند حمل‌ونقل را بهینه‌سازی کرد.

## کشف دانش (Knowledge Discovery)

 این بخش هسته‌ی اصلی فصل دوم است:

**برای ساخت راه‌حل نرم‌افزاری موثر، باید حداقل دانش پایه‌ای از حوزهٔ کسب‌وکار داشته باشید.**

اما این دانش از کجا می‌آید؟ **از کارشناسان دامنه (Domain Experts).**

### نکتهٔ حیاتی:

ما (توسعه‌دهندگان و معماران) **نباید** کارشناس دامنه شویم. این غیرعملی است و هدف نیست.

اما **باید** کارشناسان دامنه را درک کنیم و **از همان اصطلاحات کسب‌وکاری که آن‌ها استفاده می‌کنند، استفاده کنیم.**

### دلیل:

**نرم‌افزار باید از همان روش فکری کارشناس دامنه (مدل ذهنی آن‌ها) تبعیت کند.**

اگر ما نفهمیم چرا کسب‌وکار این‌طور کار می‌کند، **راه‌حل‌های غلط یا ناقص**خواهیم ساخت. و نتیجهٔ آن **شکستِ پروژه** است.

---

# فصل دوم - بخش دوم: ارتباط و چالش‌های شکاف دانش

## مسئلهٔ ارتباط در پروژه‌های نرم‌افزاری

پس از فهمیدن اینکه چرا به دانش حوزه نیاز داریم، حالا بیایید واقعیت‌های سخت را ببینیم: **چگونه این دانش از کارشناسان دامنه به توسعه‌دهندگان برسد؟**

تقریباً تمام پروژه‌های نرم‌افزاری نیاز به **همکاری افراد با نقش‌های متفاوت** دارند: کارشناسان دامنه، مالکین محصول، مهندسان نرم‌افزار، طراحان UI/UX، مدیران پروژه و تست‌کنندگان.

**موفقیت پروژه بستگی به این دارد که این گروه‌های مختلف چقدر خوب با هم کار کنند.**

سؤالات اساسی‌ای که باید پاسخ داد:

- آیا همه نفر‌ها درک یکسانی از مسئله‌ای که حل می‌کنند دارند؟
- آیا درباره راه‌حل فرضیات متناقضی دارند؟
- آیا از نیازمندی‌های تابعی و غیرتابعی بر سر یک نظر هستند؟

**توافق و هم‌راستایی درباره تمام موارد مرتبط با پروژه برای موفقیت ضروری است.**

## مشکل: فقدان ارتباط مستقیم

 تحقیقات نشان می‌دهند که **بخش اعظم شکست‌های پروژه‌های نرم‌افزاری از ارتباط ناکافی ناشی می‌شود.**

با این حال، به تعجب خیلی، **ارتباط مؤثر در اکثر پروژه‌های نرم‌افزاری مشاهده نمی‌شود.**

### مسئلهٔ واسطه‌گران

 معمولاً افراد کسب‌وکار و مهندسان **هیچ ارتباط مستقیمی با یکدیگر ندارند.** به جای آن، دانش حوزه از **واسطه‌گران** (میانجیان) منتقل می‌شود:

- تحلیلگران سیستم
- مالکین محصول
- مدیران پروژه

**مشکل این رویکرد:** هرجا که ترجمه‌ای صورت گیرد، **اطلاعات از دست می‌رود.**

دانش حوزه‌ای که برای حل مسائل کسب‌وکاری ضروری است در راه به سراغ مهندسان **کاهش یافته یا تحریف می‌شود.**

### مسئلهٔ چندگانه‌بودن ترجمه‌ها

 این تنها ترجمهٔ یکی نیست. سیکل توسعه نرم‌افزار سنتی **چندین ترجمهٔ متوالی** را شامل می‌شود:

1. **دانش حوزه** → 2. **مدل تحلیل‌شده**
2. **مدل تحلیل‌شده** → 3. **طراحی سیستم**
3. **طراحی سیستم** → 4. **کد پیاده‌سازی‌شده**

مسئلهٔ اضافی اینکه **اسناد و مستندات دیگر سریع از تاریخ می‌افتند** و کود باقی‌مانده منبع اطلاع برای مهندسانی است که بعداً روی پروژه کار می‌کنند.

## بازی تلفن (Telephone Game)

 این فرآیند **دقیقاً مثل بازی کودکانه "تلفن" است**:

- نفر اول پیام‌ای را در سر شخص دوم زمزمه می‌کند
- دوم برای سوم تکرار می‌کند
- و ... تا آخر
- نفر آخر پیام را برای همه اعلام می‌کند
- **پیام نهایی اغلب کاملاً متفاوت از اصلی است**

**نتیجه:** توسعه‌دهندگان به جای حل مسئلهٔ درست، **یا راه‌حل غلط را می‌سازند، یا راه‌حل درستی را برای مسئلهٔ اشتباه پیاده می‌کنند.**

**در هر دو صورت، پروژه ناکام می‌ماند.**

**سؤال کلیدی:** چطور می‌توانیم این ترجمه‌های بی‌پایان و اطلاعات‌گم‌شدهٔ آن را متوقف کنیم؟

**پاسخ:** **زبان یکپارچه (Ubiquitous Language)**

---

# فصل دوم - بخش سوم: زبان یکپارچه (Ubiquitous Language) - راه‌حل DDD

## مشکل و راه‌حل

بعد از بررسی مسائل ارتباطی و بازی تلفنی (ترجمه‌های متوالی)، **حالا راه‌حل DDD را معرفی می‌کنم:**

> «اگر طرف‌های مختلف باید کارآمد ارتباط کنند، به جای اینکه روی ترجمه‌ها تکیه کنند، باید **یک زبان واحد** صحبت کنند.»

## تعریف زبان یکپارچه (Ubiquitous Language)

 زبان یکپارچه یعنی:

**تمام افراد درگیر در پروژه (مهندسان نرم‌افزار، مالکین محصول، کارشناسان دامنه، طراحان UI/UX) باید از یک **زبانِ واحد و مشترک** برای توصیف دامنهٔ کسب‌وکار استفاده کنند.**

### ویژگی کلیدی:

**این زبان باید زبان کسب‌وکار باشد، نه زبان فنی.**

مثال‌های **درست** (زبان کسب‌وکار):

- «یک کمپین تبلیغاتی می‌تواند مواد خلاقانهٔ مختلف را نمایش دهد.»
- «یک کمپین تنها می‌تواند منتشر شود اگر حداقل یک placement فعال داشته باشد.»
- «کمیسیون‌های فروش پس از تصویب تراکنش‌ها محاسبه می‌شود.»

مثال‌های **نادرست** (زبان فنی):

- «iframe تبلیغات یک فایل HTML را نمایش می‌دهد.»
- «یک کمپین می‌تواند منتشر شود اگر حداقل یک record در جدول `active_placements` داشته باشد.»
- «کمیسیون‌ها بر اساس related records از جداول `transactions` و `approved_sales` محاسبه می‌شود.»

**دلیل:** اگر مهندسان فقط با نسخهٔ فنی آشنایی دارند، **درک عمیق منطق کسب‌وکار را از دست می‌دهند.**

## ویژگی‌های زبان یکپارچه

### ۱. **دقت و سازگاری (Precision & Consistency)**

 هر اصطلاح در زبان یکپارچه **باید یک معنای واحد** داشته باشد.

#### مثال از عدم‌سازگاری:

اگر اصطلاح «policy» در کسب‌وکار دو معنای متفاوت داشته باشد:

- معنی ۱: «قانون نظارتی»
- معنی ۲: «قرارداد بیمه»

**حل:** به جای استفاده از یک اصطلاح مبهم، **دو اصطلاح مختلف** استفاده کنید:
- «regulatory rule»
- «insurance contract»

#### مثال از اصطلاحات مترادف:

اگر برای مفهوم یکسان اصطلاحات متفاوتی استفاده شود:

- «user»
- «visitor»
- «account»

**مشکل:** این اصطلاحات ممکن است **مفاهیم متفاوتی** را نشان دهند. مثلاً:
- «visitor» = کاربرانِ ثبت‌نام‌نشده (فقط برای تحلیل)
- «account» = کاربرانِ ثبت‌نام‌شده (که سیستم را واقعاً استفاده می‌کنند)

**حل:** هر اصطلاح را در **زمینهٔ خاص خود** استفاده کنید و نام‌های مختلف برای مفاهیم مختلف بگذارید.

## مدل‌سازی دامنهٔ کسب‌وکار

### یک مدل چیست؟

 **مدل نسخهٔ ساده‌شدهٔ یک چیز یا پدیده‌ای است که اهداف خاصی را در نظر گرفته و سایر جنبه‌ها را نادیده می‌گیرد.**

**مثال: نقشه‌ها**

نقشه‌های مختلف (نقشهٔ جاده‌ای، نقشهٔ زمان، نقشهٔ زیرزمینی) **هیچ‌یک دقیقِ همهٔ جزئیات زمین را نشان نمی‌دهند.** اما **هر یک برای مقصودِ خود مناسب است.**

### مدل‌سازی موثر

 یک مدل موثر:

- **فقط جزئیات مورد نیاز برای حل مسئلهٔ خاص را شامل می‌شود**
- **سایر جزئیات غیرضروری را کنار می‌گذارد**
- **هدف آن حل مسئله است، نه کپی دقیق از دنیای واقعی**

### زبان یکپارچه = مدل دامنه

 زمانی که یک زبان یکپارچه را تعریف می‌کنید، **شما در حقیقت یک مدل از دامنهٔ کسب‌وکار می‌سازید.**

این مدل باید:

- **ذهن‌های کارشناسان دامنه را منعکس کند**
- **موجودیت‌های کسب‌وکاری و رفتار آن‌ها را شامل شود**
- **روابط علت‌ومعلول را نشان دهد**
- **محدودیت‌های کسب‌وکاری (invariants) را تعریف کند**

**اما:** مدل شما **نباید هر جزئیهٔ دامنه را شامل شود**؛ فقط **آنقدر جزئیات شامل کنید که برای حل مسئلهٔ خاص کافی باشد.**

## کوشش مستمر

 **تشکیل یک زبان یکپارچه یک فرآیند جاری است، نه یک‌باره:**

- **فقط تعامل با کارشناسان دامنه** می‌تواند **عدم‌دقت‌ها، فرض‌های غلط، یا سوءفهم‌های کلی** را فاش کند
- **تمام تیم باید مستمراً** از این زبان در تمام ارتباطات پروژه استفاده کنند: گفت‌وگو، اسناد، تست‌ها، کد
- **همیشه باید اعتبارسنجی و تکامل داده شود:** وقتی درک عمیق‌تری از دامنه حاصل شود، زبان باید با آن تطبیق یابد

---

# فصل ۳: مدیریت پیچیدگی دامین (Managing Domain Complexity) - بخش اول

## چالش مدل‌های ناسازگار (Inconsistent Models)

فصل با یادآوری اهمیت «زبان مشترک» (Ubiquitous Language) آغاز می‌شود. هدف ما این است که مدلی بسازیم که دقیقاً بازتاب‌دهنده‌ی مدل ذهنی متخصصان کسب‌وک‌کار (Domain Experts) باشد. اما یک مشکل بزرگ وجود دارد: **ذهنیت متخصصان کسب‌وکار همیشه یکپارچه نیست.**

نویسنده برای توضیح این مشکل، مثال شرکت «بازاریابی تلفنی» (Telemarketing) را که در فصل‌های قبل مطرح شده بود، دوباره باز می‌کند. در این شرکت دو دپارتمان اصلی وجود دارد:
1.  **دپارتمان مارکتینگ (Marketing):** مسئول تولید سرنخ (Lead) از طریق تبلیغات آنلاین.
2.  **دپارتمان فروش (Sales):** مسئول تماس با این سرنخ‌ها و تبدیل آن‌ها به مشتری.

نکته‌ی کلیدی و ظریف اینجاست که واژه‌ی **Lead (سرنخ)** در این دو دپارتمان معنای کاملاً متفاوتی دارد:

*   **از دید مارکتینگ:** یک `Lead` صرفاً یک «رویداد» یا نوتیفیکیشن است که می‌گوید "یک نفر علاقه نشان داده است". همین که اطلاعات تماس فرد را داشته باشند، کافی است.
*   **از دید فروش:** یک `Lead` یک موجودیت پیچیده و بلندمدت است. دارای چرخه حیات است (تماس گرفته شد، علاقه‌مند بود، جلسه ست شد، و غیره). برای آن‌ها `Lead` یک فرآیند است، نه فقط یک رخداد ساده.

### دوراهی طراحی (The Design Dilemma)

چگونه باید یک «زبان مشترک» برای این سیستم ساخت؟
*   اگر مدل پیچیده‌ی فروش را به مارکتینگ تحمیل کنیم، سیستم مارکتینگ را با جزئیاتی که نیازی به آن‌ها ندارد (مثل وضعیت مذاکره) پیچیده و سربار کرده‌ایم (Over-engineered).
*   اگر مدل ساده‌ی مارکتینگ را مبنا قرار دهیم، نیازهای دپارتمان فروش برای مدیریت فرآیند فروش برآورده نمی‌شود (Under-engineered).

در روش‌های سنتی، معمولاً سعی می‌شد یک **مدل واحد و بزرگ** (Single Model) برای کل سازمان ساخته شود (مثلاً نمودارهای ERD عظیم که تمام دیوارهای اتاق را می‌پوشاند). نویسنده تأکید می‌کند که این مدل‌ها مصداق بارز ضرب‌المثل "همه کاره و هیچ کاره" هستند. آن‌ها آنقدر شلوغ و پیچیده می‌شوند که نگهداری آن‌ها کابوس است و هیچکس دقیقاً نمی‌داند چه خبر است.

## راهکار: الگوی Bounded Context

راه‌حل Domain-Driven Design برای این مشکل ساده اما انقلابی است: **به جای تلاش برای ساختن یک مدل بزرگ و کامل، زبان مشترک را به چندین زبان کوچکتر تقسیم کنید و هر کدام را به یک «کانتکست» (Context) مشخص اختصاص دهید.**

به این الگو، **Bounded Context** گفته می‌شود.

در مثال بالا، ما باید دو کانتکست جداگانه داشته باشیم:
1.  **کانتکست مارکتینگ:** در اینجا `Lead` معنای ساده‌ی خودش را دارد.
2.  **کانتکست فروش:** در اینجا `Lead` معنای پیچیده و فرآیند-محور خودش را دارد.

تا زمانی که واژه‌ی `Lead` در داخل مرزهای هر کانتکست معنای واحد و مشخصی داشته باشد، ابهامی وجود نخواهد داشت. در DDD، ما این تضادها را پنهان نمی‌کنیم، بلکه آن‌ها را به عنوان بخش صریحی از طراحی مدل می‌پذیریم.

### مرزهای مدل (Model Boundaries)

نویسنده یک جمله‌ی بسیار عمیق در این بخش دارد:
> "یک مدل نمی‌تواند بدون مرز (Boundary) وجود داشته باشد؛ در غیر این صورت گسترش می‌یابد تا به کپیِ خودِ دنیای واقعی تبدیل شود."

همانطور که نقشه‌های جغرافیایی انواع مختلفی دارند (نقشه مترو، نقشه ناهمواری‌ها، نقشه سیاسی) و هر کدام فقط در کانتکست خودشان مفید هستند، مدل‌های نرم‌افزاری هم باید مرز مشخص داشته باشند. یک مدل در کانتکست مارکتینگ ممکن است برای کانتکست فروش کاملاً بی‌فایده یا گمراه‌کننده باشد.

بنابراین، **Bounded Context یعنی مرزِ اعمال‌شدنِ یک مدل خاص.**

## تعریف دقیق‌تر زبان مشترک (Ubiquitous Language Refined)

با معرفی Bounded Context، تعریف ما از «زبان مشترک» کامل‌تر می‌شود.
زبان مشترک به این معنی نیست که یک اصطلاح در **کل سازمان** یک معنی داشته باشد (که عملاً غیرممکن است). بلکه به این معنی است که آن اصطلاح در **داخل مرزهای Bounded Context خودش**، معنایی واحد، شفاف و بدون ابهام داشته باشد.

### محدوده یا اسکوپ (Scope)

اندازه‌ی یک Bounded Context چقدر باید باشد؟
این یک تصمیم استراتژیک در طراحی است. مرزها می‌توانند وسیع باشند (شامل چندین زیرمجموعه کاری) یا باریک و متمرکز.
*   **مزیت مرزهای وسیع:** یکپارچگی بیشتر بین اجزای داخلی.
*   **مزیت مرزهای باریک (کوچک):** مدیریت راحت‌تر مدل‌ها و امکان توسعه مستقل.

اما نویسنده هشدار می‌دهد که نباید در کوچک کردن کانتکست‌ها زیاده‌روی کرد. اگر یک عملکرد منسجم (Coherent Functionality) را بی‌دلیل به چند کانتکست خرد کنید، سربار یکپارچه‌سازی (Integration Overhead) افزایش می‌یابد.

---

# فصل ۳: مدیریت پیچیدگی دامین - بخش دوم

## Bounded Context در مقابل Subdomain

این قسمت از فصل به یک سوال مهم می‌پردازد: آیا **Bounded Context** و **Subdomain** یکی هستند؟

در فصل‌های قبل درباره‌ی Subdomain (core، generic، supporting) خواندیم. الآن باید متوجه شویم که این دو مفهوم کاملاً متفاوت هستند، اگرچه اغلب اوقات با هم اشتباه گرفته می‌شوند.

### Subdomain چیست؟

**Subdomain** یک **عنصر تجاری** است که در سازمان **کشف می‌شود**. یعنی زمانی که شما درباره‌ی کسب‌وکار تحقیق می‌کنید و فهمیدید که شرکت‌تان در کدام فعالیت‌های مختلف دست دارد، آن فعالیت‌ها را Subdomain می‌نامیم. 

برای مثال:
- در بانک، «پردازش وام» و «مدیریت حساب بانکی» دو Subdomain هستند.
- در Uber، «مطابقت سرایندگی با مسافر» و «پردازش پرداخت» دو Subdomain متفاوت‌اند.

**نکته مهم:** Subdomain‌ها بر اساس **استراتژی کسب‌وکار** شرکت تعریف می‌شوند، نه بر اساس تصمیمات فنی ما.

### Bounded Context چیست؟

**Bounded Context** برعکس، یک عنصر **نرم‌افزاری** و **طراحی‌شده** است. ما (تیم نرم‌افزار) تصمیم می‌گیریم که سیستم را به چه بخش‌هایی تقسیم کنیم، چگونه مدل‌ها را سازمان‌دهیم، و کدام اجزا مستقل‌اند.

**نکته مهم:** Bounded Context‌ها از جانب **مهندسان نرم‌افزار** طراحی می‌شوند، نه اینکه توسط کسب‌وکار تعریف شوند.

### فاصله بین این دو

اگرچه Subdomain و Bounded Context مفاهیم متفاوتی هستند، اما می‌توانند با هم ارتباط داشته باشند. نویسنده سناریوهای مختلفی را نشان می‌دهد:

#### سناریو ۱: یک Bounded Context بزرگ برای کل سیستم
![سیستم یکپارچه]
اگر سیستم کوچک است، ممکن است یک Bounded Context واحد برای کل سیستم کافی باشد، حتی اگر چندین Subdomain داخل آن وجود داشته باشد.

#### سناریو ۲: Bounded Context‌ها براساس تضاد در مدل‌ها
![Bounded Contexts متعدد]
زمانی که متخصصان کسب‌وکار مدل‌های متفاوتی از یک مفهوم دارند (مثل مثال Lead)، ما Bounded Context‌های جداگانه می‌سازیم.

#### سناریو ۳: Bounded Context‌ها همسو با Subdomain‌ها
![Aligned Boundaries]
در بسیاری از موارد عملی، هر Subdomain در یک Bounded Context جداگانه پیاده‌سازی می‌شود.

**نکته حیاتی:** نیست که یک Bounded Context باید دقیقاً با یک Subdomain تطابق داشته باشد. ما می‌توانیم:
- یک Subdomain را در چند Bounded Context مختلف مدل‌سازی کنیم (اگر نیاز به حل‌های مختلفی برای مسائل مختلف داشته باشیم).
- چندین Subdomain را در یک Bounded Context ادغام کنیم (اگر آن‌ها منسجم و بسیار تنگاتنگ باشند).

## مرزها: فیزیکی و مالکانه (Physical and Ownership Boundaries)

تا الآن فقط در مورد Bounded Context به‌عنوان یک مرز **مفهومی** (برای سازمان‌دهی مدل) صحبت کردیم. اما Bounded Context‌ها دارای ابعاد فیزیکی و سازمانی نیز هستند.

### مرزهای فیزیکی (Physical Boundaries)

**فیزیکی** به این معنی است که هر Bounded Context باید به‌عنوان یک **موجودیت مستقل و قابل استقلال** پیاده‌سازی شود. به‌عبارت دیگر:

- هر Bounded Context یک **پروژه جداگانه** است.
- هر Bounded Context می‌تواند با **Stack فنی متفاوت** پیاده‌سازی شود (اگر نیاز داشته باشد).
- هر Bounded Context **مستقل از دیگری نسخه‌ برداری می‌شود** (versioning).
- هر Bounded Context **جداگانه Deploy می‌شود**.

این استقلال فیزیکی در عمل بسیار اهمیت دارد، زیرا به تیم‌های مختلف این امکان را می‌دهد که در سرعت‌های متفاوت کار کنند و با فناوری‌های متفاوت.

### مرزهای مالکانه (Ownership Boundaries)

نویسنده یک قول معروف را نقل می‌کند: "Good fences do indeed make good neighbors" (نرده‌های خوب واقعاً همسایگان خوب می‌سازند).

در تیم‌های نرم‌افزار نیز همین اصل صدق می‌کند:

**قانون طلایی:** هر Bounded Context تنها **توسط یک تیم** می‌تواند مدیریت و توسعه داده شود. نه کمتر، نه بیشتر.

**نکته مهم:** یک تیم می‌تواند **چندین** Bounded Context را مدیریت کند، اما یک Bounded Context نمی‌تواند توسط دو تیم مختلف مدیریت شود.

#### چرا این قانون مهم است؟

1. **جلوگیری از فروپاشی ارتباط:** اگر دو تیم روی یک Bounded Context کار کنند، هر تیم فرضیات خود را در مورد مدل می‌کند و این فرضیات اغلب غلط و متناقض هستند.
2. **مسئولیت واضح:** هر کسی می‌داند کیست مسئول هر بخش.
3. **تصمیم‌گیری سریع:** یک تیم می‌تواند تصمیمات مرتبط با مدل خود را بدون بحث بی‌انتها بگیرد.
4. **طراحی API مشخص:** هر تیم باید API خود را به‌عنوان یک **قرارداد واضح** برای تیم‌های دیگر تعریف کند.

## Bounded Context در دنیای واقعی

نویسنده یک داستان بسیار جالب از یکی از شاگردانش در کلاس DDD نقل می‌کند:

> "شما گفتید DDD درباره‌ی تطابق طراحی نرم‌افزار با دامین‌های تجاری است. اما Bounded Context در دنیای واقعی کجا‌ند؟ در دنیای تجاری، Bounded Context وجود ندارد!"

پاسخ نویسنده جالب است: **Bounded Context‌ها در دنیای واقعی وجود دارند**، اما آن‌ها تا جایی که مدل‌های ذهنی متخصصان کسب‌وکار وجود دارند.

برای توضیح این مفهوم، نویسنده سه مثال غیرعادی از دنیای واقعی می‌آورد:

### مثال ۱: دامین‌های معنایی (Semantic Domains) - گوجه‌فرنگی

این مثال بسیار جالب است و نشان می‌دهد که Bounded Context فقط در نرم‌افزار نیست، بلکه در طبیعت و جامعه‌ی انسانی هم رایج است.

کلمه‌ی **گوجه‌فرنگی** معنای مختلفی در کانتکست‌های مختلف دارد:

#### کانتکست تحقیقات گیاهی (Botany):
- تعریف رسمی: یک **میوه** است (زیرا از گل گیاه رشد می‌کند و حداقل یک دانه دارد).
- سبزی: هر بخش دیگر از گیاه (ریشه، ساقه، برگ).
- **نتیجه:** گوجه‌فرنگی یک **میوه** است.

#### کانتکست آشپزی (Culinary Arts):
- تعریف: میوه‌ها نرم، شیرین یا ترش و خام قابل خوردن هستند.
- سبزی‌ها: بافت سخت‌تر، طعم خنثی، نیازمند پختن.
- **نتیجه:** گوجه‌فرنگی یک **سبزی** است.

#### کانتکست مالیاتی (Taxation):
- در سال ۱۸۸۳، ایالات متحده مالیات ۱۰٪ بر واردات سبزی‌ها وضع کرد، اما نه میوه‌ها.
- برای جلوگیری از اینکه تاجران گوجه‌فرنگی را میوه اعلام کنند و مالیات نپردازند، **قدیم‌ترین ستم‌اینی در تاریخ!**
- **نتیجه:** گوجه‌فرنگی یک **سبزی** است (براساس تصمیم دادگاه عالی سال ۱۸۹۳).

#### کانتکست تئاتر:
- همانطور که یک دوست نویسنده می‌گفت، در تئاتر گوجه‌فرنگی یک **مکانیزم بازخورد** است (وقتی بازیگر بد است، تماشاچیان گوجه‌فرنگی می‌اندازند!).

**درس:** یک موجودیت واقعی می‌تواند معنای کاملاً متفاوتی در کانتکست‌های مختلف داشته باشد. و این **نه تناقض** است، بلکه **طبیعی و منطقی** است.

### مثال ۲: فیزیک و نسبیت (Science)

نویسنده یک نقل‌قول از تاریخ‌دان معروف یوول نوح هاراری را می‌آورد:

> "دانشمندان عموماً موافقند که هیچ نظریه‌ی ۱۰۰ درصد صحیح نیست. بنابراین آزمون واقعی علم نه **حقیقت** است، بلکه **مفید بودن** است."

دو مثال:

**فیزیک نیوتنی:**
- فضا و زمان **مطلق** هستند (مانند یک صحنه‌ی تئاتر ثابت).
- بسیار دقیق برای حرکت اجسام روزمره.

**نظریه‌ی نسبیت اینشتین:**
- فضا و زمان **نسبی** هستند (متفاوت برای ناظران مختلف).
- برای سرعت‌های بسیار بالا و میدان‌های گرانشی قوی ضروری است.

آیا این دو نظریه **متناقض** هستند؟ بله. آیا هردو **مفید** هستند؟ بله، در کانتکست‌های متفاوت.

### مثال ۳: خریدن یخچال (Buying a Refrigerator)

یکی از مثال‌های عملی و جالب که نویسنده می‌آورد، تجربه‌ی خودش در خریدن یخچال است:

آپارتمان نویسنده درب ورودی استاندارد به آشپزخانه ندارد. او نمی‌دانست یخچال جدیدی که می‌خواست بخرد (Siemens KG86NAI31L) از درب آشپزخانه عبور کند یا نه.

**مدل اول - کاردبُرد:**
نویسنده یک تکه کاغذ را دقیقاً به ابعاد عرض و عمق یخچال بریده و آن را در درب آشپزخانه امتحان کرد.

*   آیا این کاغذ شبیه یخچال واقعی است؟ **نه، اصلاً نه!** بدون درب، بدون رنگ، بدون شکل اصلی.
*   آیا مفید بود؟ **بسیار مفید!**
*   چرا مفید است؟ **زیرا مشکل خاصی را حل می‌کند:** بررسی اینکه آیا یخچال عمود سطح زمین من از درب عبور می‌کند.

**مدل دوم - متر نوار:**
بعد از بررسی عمق، نویسنده نگران قد یخچال بود. آیا خیلی بلند است؟

کاغذ برای این مشکل کار نمی‌کرد. نویسنده برای **بررسی قد**، یک **متر نوار** استفاده کرد. این مدل دوم **ساده‌تر و راحت‌تر** بود.

**درس:**
این دقیقاً همان‌طور است که در DDD Bounded Context‌ها را طراحی می‌کنیم:
- ما می‌توانیم **چندین مدل متفاوت** از یک موجودیت داشته باشیم.
- هر مدل برای **حل یک مشکل خاص** طراحی می‌شود.
- یک مدل پیچیده‌تر (مثل ساخت یک مدل سه‌بعدی دقیق) بیشتر مفید نیست، بلکه **اضافی است** (Over-engineering).

## نتیجه‌گیری بخش دوم

سه درس کلیدی:

1. **Subdomain‌ها کشف می‌شوند؛ Bounded Context‌ها طراحی می‌شوند.** Subdomain‌ها از تحلیل کسب‌وکار بیرون می‌آیند. Bounded Context‌ها توسط مهندسان نرم‌افزار تصمیم‌گیری می‌شوند.

2. **هیچ قاعده‌ای برای نسبت یک‌به‌یک بین آن‌ها نیست.** یک Subdomain می‌تواند در چندین Bounded Context جدا مدل‌سازی شود. چندین Subdomain می‌تواند در یک Bounded Context ادغام شود.

3. **Bounded Context‌ها مرزهای مالکانه و فیزیکی دارند.** هر Bounded Context یک پروژه و تیم جداگانه است. این استقلال باعث می‌شود که تیم‌ها مستقل کار کنند و سریع‌تر تصمیم بگیرند.

---

# فصل ۳: مدیریت پیچیدگی دامین - بخش سوم 

## مرزها: طراحی معماری سیستم

نویسنده این بخش را با یک نقل‌قول از **Ruth Malan** (یک متخصص معماری نرم‌افزار) آغاز می‌کند:

> "طراحی معماری ذاتاً درباره‌ی مرزها است... طراحی معماری، طراحی سیستم است. طراحی سیستم، طراحی متناسب با زمینه‌ی خاص است—ذاتاً درباره‌ی مرزها: چه چیزی درون است، چه چیزی بیرون، چه چیزی گسترده است، چه چیزی میان آن‌ها حرکت می‌کند، و درباره‌ی مصالحه‌ها. این به شکل چیزی که بیرون است تأثیر می‌گذارد، همانطور که شکل چیزی که درون است را تغییر می‌دهد."

این نقل‌قول خلاصه‌ی فلسفه‌ی Bounded Context است. Bounded Context نه تنها یک مرز **مفهومی** نیست، بلکه یک تصمیم **معماری** است که در ساختار فیزیکی سیستم بازتاب می‌یابد.

## مرزهای فیزیکی (Physical Boundaries)

هر Bounded Context باید به‌عنوان یک موجودیت **فیزیکی و مستقل** پیاده‌سازی شود. این بدان معنی است:

### ۱. جداگانگی پروژه
هر Bounded Context یک **پروژه جداگانه** در سیستم کنترل نسخه (Git، SVN و غیره) است. نه‌اینکه یک پوشه درون یک پروژه بزرگ، بلکه واقعاً یک **مخزن (Repository) جداگانه** در سیستم کنترل نسخه.

### ۲. استقلال فناوری
این یکی از بزرگ‌ترین مزایای Bounded Context است. اگر Bounded Context A نیازمند **Node.js** است و Bounded Context B بهتر با **Python** کار می‌کند، هیچ مانعی وجود ندارد! هر تیم می‌تواند **تکنولوژی بهترین** برای نیازهای خود انتخاب کند.

برای مثال:
- Bounded Context برای «پردازش تصاویر» ممکن است از **Go** یا **Rust** استفاده کند (برای سرعت).
- Bounded Context برای «رابط کاربری پیشرفته» از **React** یا **Vue** استفاده کند.
- Bounded Context برای «تحلیل داده‌ها» از **Python** استفاده کند.

نیازی نیست که تمام سیستم از یک تکنولوژی یکسان استفاده کند. این **تنوع** در معماری میکروسرویس‌ها (Microservices) بسیار معمول است.

### ۳. نسخه‌برداری مستقل
هر Bounded Context می‌تواند **نسخه‌ی خود را به‌طور مستقل** مدیریت کند. Bounded Context A می‌تواند در نسخه ۲.۳ باشد، در حالی‌که Bounded Context B در نسخه ۵.۱ است. نیازی نیست که تمام سیستم یک نسخه واحد داشته باشد.

### ۴. استقرار مستقل (Deployment)
یکی از مهم‌ترین مزایا این است که هر Bounded Context می‌تواند **به‌طور مستقل اجرا شود**. اگر تیم B چیزی را تغییر دهد، تیم A نیازی ندارد سیستم خود را دوباره استقرار دهد.

این باعث **افزایش سرعت توسعه** می‌شود و **ریسک** استقرار را کاهش می‌دهد.

## مرزهای مالکانه (Ownership Boundaries)

### قانون طلایی مالکیت

**هر Bounded Context تنها توسط یک تیم می‌تواند مالکانه‌ی آن باشد.**

اگر دو تیم روی یک Bounded Context کار کنند:
- تیم A تصور می‌کند که مدل X باید به این شکل باشد.
- تیم B تصور می‌کند که مدل X باید به آن شکل باشد.
- هر دو تیم فرضیات‌های متفاوتی درباره‌ی رفتار مدل می‌سازند.
- در نتیجه، مدل پراکنده می‌شود و کد به **Spaghetti Code** (کد الگوی مکارونی) تبدیل می‌شود.

### قانون معکوس

**یک تیم می‌تواند چندین Bounded Context را مدیریت کند.**

نویسنده در متن اصلی نمودار ساده‌ای بیان می‌کند:
- تیم ۱: مالک Bounded Context «مارکتینگ» و Bounded Context «بهینه‌سازی تبلیغات»
- تیم ۲: مالک Bounded Context «فروش»

این ترتیب منطقی است، خصوصاً اگر کانتکست‌ها ارتباط تنگاتنگی داشته باشند و تیم آن‌ها بهتر درک کند.

### چرا مالکیت واضح مهم است؟

**۱. جلوگیری از فرضیات ضمنی:**
اگر دو تیم روی یک Bounded Context کار کنند، هر تیم **فرضیات مختلفی** درباره‌ی رفتار مدل می‌سازد. این فرضیات اغلب **متناقض** و **پنهان** هستند. زمانی که این دو مجموعه‌ی فرضیات با هم برخورد می‌کند، مسائل عمیقی رخ می‌دهد.

**۲. مسئولیت واضح و شفاف:**
اگر چیزی در Bounded Context خراب شود، مشخص است کیست مسئول. نیست اینکه «هر دو تیم مسئول هستند» (که در واقع به معنای «هیچ‌کس مسئول نیست» است).

**۳. تصمیم‌گیری سریع:**
مالک Bounded Context می‌تواند **فوری و بدون تأخیر** تصمیمات مهم بگیرد. نیازی ندارد برای موافقت تمام تیم‌ها منتظر باشد یا مذاکره‌های طولانی و پیچیده‌ای انجام دهد.

**۴. طراحی API شفاف و منسجم:**
هر تیم می‌داند **دقیقاً کدام API** را برای تیم‌های دیگر آشکار می‌کند و **کدام جزئیات درونی** خصوصی است. این باعث می‌شود API‌ها طبق اصول بهتر و با منطق یکسان طراحی شوند.

## جنبه‌های منطقی در مقابل فیزیکی

نویسنده یک تمایز دقیق و مهم می‌کند:

### مرز منطقی (Logical Boundary)
اگر یک Bounded Context شامل **چندین Subdomain** باشد، آن‌ها می‌توانند **منطقاً** درون **Namespace‌ها** یا **Modules** یا **Package‌ها** (بسته‌ها) جداگانه سازمان‌دهی شوند.

برای مثال، در یک Bounded Context «فروش»:
```
Sales/
  ├── Orders/
  │   ├── Order.cs
  │   ├── OrderRepository.cs
  ├── Customers/
  │   ├── Customer.cs
  │   ├── CustomerRepository.cs
  ├── Invoicing/
  │   ├── Invoice.cs
  │   ├── InvoiceGenerator.cs
```

این Namespace‌ها مرزهای **منطقی** درون یک Bounded Context هستند.

### مرز فیزیکی (Physical Boundary)
اما تمام این Namespace‌ها درون **یک پروژه/مخزن فیزیکی** قرار دارند:
```
SalesService/  <- Bounded Context فیزیکی
  ├── Orders/  <- مرز منطقی
  ├── Customers/  <- مرز منطقی
  ├── Invoicing/  <- مرز منطقی
  └── ...
```

اگر یک Subdomain بسیار بزرگ و پیچیده بود، ممکن بود آن را به **Bounded Context جداگانه** (مرز فیزیکی) تقسیم کنیم. اما معمولاً اول سعی می‌کنیم از **مرزهای منطقی** استفاده کنیم.

## Bounded Context در دنیای واقعی

### ۱. دامین‌های معنایی (Semantic Domains)

Bounded Context بر اساس ایده‌ای از **زبان‌شناسی** (Linguistics) است که **Semantic Domain** (دامین معنایی) نامیده می‌شود.

**تعریف:** دامین معنایی = «ناحیه‌ای از معنا و کلماتی که برای بحث درباره‌ی آن استفاده می‌شوند.»

**مثال‌های عملی:**

- کلمه **Monitor** (مانیتور):
  - در دامین **نرم‌افزار:** دستگاهی برای نمایش خروجی کامپیوتر
  - در دامین **پزشکی:** دستگاهی برای نظارت بر وضعیت بیمار
  - در دامین **مدیریت:** فردی که برای بررسی کیفیت کار می‌کند

- کلمه **Port** (درگاه):
  - در دامین **شبکه کامپیوتری:** رابط ورودی/خروجی داده در یک کامپیوتر
  - در دامین **دریانوردی:** منطقه‌ای کناری دریا برای لنگرگاه کشتی‌ها

- کلمه **Processor** (پردازنده):
  - در دامین **فناوری:** تراشه مرکزی در کامپیوتر
  - در دامین **تولید:** دستگاهی برای پردازش و تبدیل مواد خام

**درس:** یک واژه می‌تواند معنای **کاملاً متفاوت** در زمینه‌های کاری مختلف داشته باشد. این **تناقض نیست**، بلکه **طبیعی و منطقی** است و Bounded Context‌ها این واقعیت را بیان می‌کنند.

### ۲. گوجه‌فرنگی - مثال جامع

نویسنده این مثال را در چندین Bounded Context مختلف تشریح می‌کند:

#### Bounded Context ۱: تحقیقات گیاهی (Botany)
- **میوه:** چیزی که از گل گیاه رشد می‌کند و حداقل یک دانه دارد
- **سبزی:** بقیه‌ی اجزای خوردنی گیاه (ریشه، ساقه، برگ)
- **نتیجه:** گوجه‌فرنگی = **میوه**

#### Bounded Context ۲: آشپزی (Culinary Arts)
- **میوه:** غذایی با بافت نرم، طعم شیرین یا ترش، و خام خوردنی
- **سبزی:** غذایی با بافت سفت‌تر، طعم بی‌رنگ، و اغلب نیازمند پختن
- **نتیجه:** گوجه‌فرنگی = **سبزی**

#### Bounded Context ۳: مالیات و تجارت (Taxation)
در سال ۱۸۸۳، ایالات متحده ۱۰ درصد مالیات بر سبزی‌های واردشده وضع کرد، اما نه بر میوه‌ها.

تاجران برای اجتناب از مالیات، گوجه‌فرنگی را «میوه» اعلام می‌کردند.

**تصمیم دادگاه عالی ایالات متحده (سال ۱۸۹۳):** برای منظور مالیاتی، گوجه‌فرنگی = **سبزی**

(یکی از جالب‌ترین تصمیمات قانونی در تاریخ!)

#### Bounded Context ۴: تئاتر (Theatre)
همانطور که **Romeu Moura** (دوست نویسنده) می‌گفت، در تئاتر و نمایش‌های تئاتری، گوجه‌فرنگی = **ابزار بازخورد منفی** از تماشاچیان نسبت به بازی! (وقتی بازیگر بدی بازی می‌کند، تماشاچیان گوجه‌فرنگی می‌اندازند!)

**درس:** یک موجودیت فیزیکی واحد (گوجه‌فرنگی) توسط **چهار Bounded Context مختلف** با **معانی و تعاریف مختلف** درک می‌شود. این **تناقض نیست**؛ این **ماهیت و طبیعت مدل‌سازی** است. هر مدل برای **حل یک مشکل خاص** طراحی شده است.

### ۳. فیزیک و علم

نویسنده از **Yuval Noah Harari** (متفکر و مورخ معاصر) نقل می‌کند:

> "دانشمندان عموماً موافقند که هیچ نظریه‌ی علمی ۱۰۰ درصد صحیح نیست. بنابراین آزمون و معیار واقعی دانش نه **حقیقت مطلق** است، بلکه **سودمندی و کاربردی بودن** است."

**مثال: نظریه‌های گرانش**

#### Bounded Context ۱: فیزیک کلاسیک نیوتنی
- فضا و زمان **مطلق** و **یکسان** برای همه هستند (مانند یک صحنه‌ی تئاتر ثابت)
- صحیح برای سرعت‌های عادی و میدان‌های گرانشی ضعیف
- معادله مشهور: F = ma

#### Bounded Context ۲: نسبیت عام اینشتین
- فضا و زمان **نسبی** هستند و برای هر ناظر و شرایط متفاوت
- صحیح برای سرعت‌های بسیار بالا و میدان‌های گرانشی بسیار قوی
- معادله مشهور: E = mc²

**آیا این دو نظریه متناقض هستند؟** بله، کاملاً.
**آیا هردو صحیح هستند؟** نه، نه هردو صحیح هستند.
**آیا هردو **سودمند و کاربردی** هستند؟** **بسیار بله!**

برای **پرتاب موشک** به ماه، فیزیک نیوتنی کاملاً کافی است. برای دقت **سیستم GPS** (Global Positioning System)، **باید** از نسبیت اینشتین استفاده کنی. هر مدل در **کانتکست خود** بسیار سودمند است.

### ۴. خریدن یخچال - مثال عملی واقعی

نویسنده تجربه‌ی شخصی و بسیار عملی خود را تشریح می‌کند:

آپارتمان او درب ورودی **استاندارد** به آشپزخانه ندارد. او می‌خواست یخچال جدیدی بخرد: **Siemens KG86NAI31L**.

**سؤال عملی:** آیا این یخچال از درب عبور می‌کند یا نه؟

#### مدل اول: کاردبُرد (Cardboard Model)

نویسنده به‌جای خریدن و اندازه‌گیری، یک **تکه کاغذ** را دقیقاً به ابعاد **عرض** و **عمق** یخچال برید:

```
تکه کاغذ
├─ عرض: دقیقاً برابر با عرض یخچال
└─ عمق: دقیقاً برابر با عمق یخچال
```

سپس این مدل کاغذی را **در درب آشپزخانه** گذاشت و بررسی کرد آیا عبور می‌کند.

**آیا این مدل شبیه یخچال واقعی است؟** نه، اصلاً نه! بدون درب، بدون رنگ، بدون شکل و ظاهر!

**آیا مفید است؟** **بسیار مفید!** این مدل ساده می‌تواند بپاسخد: «آیا یخچال از لحاظ عرض و عمق، از درب عبور می‌کند؟»

#### مدل دوم: متر نوار (Tape Measure Model)

بعد از تأیید اینکه عرض و عمق مناسب است، نویسنده نگران **قد (ارتفاع)** یخچال شد: آیا خیلی بلند است و از درب عبور نمی‌کند؟

**مدل کاغذی برای این مشکل کار نمی‌کرد!** بنابراین نویسنده **مدل دوم** را استفاده کرد: **متر نوار**

```
متر نوار
├─ قد درب: اندازه‌گیری شده با متر نوار
└─ قد یخچال: اندازه‌گیری شده با متر نوار
```

**مقایسه دو مدل:**

| مشخصه | مدل کاغذی | مدل متر نوار |
|------|---------|---------|
| پیچیدگی | کم | بسیار کم |
| هزینه | تقریباً صفر | بسیار کم |
| سرعت | سریع | سریع |
| سودمندی برای بررسی عرض/عمق | **بسیار سود** | کم سود |
| سودمندی برای بررسی قد | کم سود | **بسیار سود** |

**درس عمیق:**
- یک مدل **پیچیده‌تر** (برای مثال، ساخت یک مدل سه‌بعدی دقیق و واقعی‌ای) **بهتر نیست**، بلکه **اضافی و غیرضروری** است.
- دو مدل **ساده** که هر کدام برای یک مشکل خاص استفاده شود، **بسیار بهتر** از یک مدل پیچیده و جامع است.
- این دقیقاً همان نحوه‌ی طراحی **Bounded Context‌های مختلف** است! برای مسائل مختلف، مدل‌های متفاوت.

#### نکته اضافی: فناوری LiDAR و Augmented Reality

یکی از خوانندگان در پاسخ به توئیت نویسنده نوشت:

> "چرا خود را با کاغذ درگیر می‌کنی؟ می‌توانی از گوشی تلفن خود با اسکن‌نر **LiDAR** و برنامه‌ی **Augmented Reality (AR)** استفاده کنی!"

**تجزیه‌ی این پیشنهاد درون چارچوب DDD:**
- این تکنولوژی **بسیار پیچیده است**. در DDD لغت: این یک **Generic Subdomain** است.
- یعنی **مشکل قبلاً توسط دیگران حل‌شده است** و راه‌حل جاهز در دسترس است.
- **درس DDD:** اگر نیاز داشتی، بهتر است **راه‌حل جاهز و آماده** (Ready-made Solution) را خریداری یا استفاده کنی، تا اینکه خودت از صفر پیادهسازی کنی.

اما در این مورد خاص، استفاده از LiDAR و AR **بیش از حد تک‌کاری** است. **کاغذ ساده، متر نوار ساده** بسیار **سریع‌تر، ارزان‌تر، و عملی‌تر** است.

## خلاصه‌ی بخش سوم

**نکات کلیدی و اساسی:**

۱. **مرزهای فیزیکی Bounded Context‌ها از اهمیت بالایی برخوردارند** زیرا:
   - هر یک می‌تواند **به‌طور مستقل استقرار داده شود**
   - هر یک می‌تواند با **تکنولوژی و ابزار متفاوت** ساخته شود
   - هر یک می‌تواند **نسخه‌برداری مستقل** داشته باشد

۲. **مرزهای مالکیت (Ownership) حیاتی و ضروری‌اند** زیرا:
   - یک تیم = یک Bounded Context (هیچ اشتراک نیست)
   - تصمیم‌گیری‌های **سریع و مؤثر**
   - عدم وجود **فرضیات ضمنی و متناقض** بین تیم‌ها

۳. **Bounded Context‌ها در دنیای واقعی و غیرنرم‌افزاری نیز یافت می‌شوند:**
   - دامین‌های معنایی (گوجه‌فرنگی در متون مختلف)
   - علم و فیزیک (نیوتن در برابر اینشتین)
   - زندگی روزمره (یخچال و درب و سناریوهای عملی)

۴. **مدل‌سازی درباره‌ی **سودمندی** است، نه **صحیح بودن مطلق و ایدئال**.**
   - یک مدل ساده که مشکل خاصی را بخش می‌دهد، **بسیار بهتر** است از یک مدل پیچیده و وسیع.
   - **چندین مدل کوچک و متخصص** بسیار بهتر از **یک مدل بزرگ و جامع** است.

---

# فصل ۳: مدیریت پیچیدگی دامین - بخش چهارم (نهایی)

## نتیجه‌گیری

نویسنده با یک خلاصه‌ی جامع این فصل را پایان می‌دهد. در این بخش پایانی، تمام مفاهیم کلیدی درباره‌ی **Bounded Context** و **مدیریت پیچیدگی دامین** به‌طور خلاصه بیان می‌شود.

### پیام اصلی فصل

**هر زمانی که با یک تضاد یا ناسازگاری درون مدل‌های ذهنی متخصصان کسب‌وکار مواجه شویم، باید دامین را به چندین Bounded Context کوچک‌تر تقسیم کنیم.**

در مثال تلفن‌فروشی که در ابتدای فصل دیدیم، «سرنخ» (Lead) در دپارتمان مارکتینگ و فروش معانی متفاوتی داشت. راه‌حل DDD این بود که هر دپارتمان را به عنوان یک Bounded Context جداگانه درک کنیم.

### ویژگی‌های Bounded Context

**۱. سازگاری زبان مشترک درون مرز:**
زبان مشترک (Ubiquitous Language) در داخل یک Bounded Context باید **کاملاً سازگار و منطقی** باشد. هیچ ابهام، هیچ تناقض، هیچ اصطلاح مترادف. اما **میان** Bounded Context‌ها، واژه‌های یکسانی می‌توانند معنای **کاملاً متفاوت** داشته باشند.

**۲. مرز مدل (Model Boundary):**
Bounded Context تنها دامن‌ی نیست که یک مدل درون آن معتبر است. حدود کاربرد یک مدل مشخص است. هر مدل برای حل یک مشکل خاص طراحی شده است.

**۳. مرز دوره‌ی زندگی (Lifecycle Boundary):**
هر Bounded Context می‌تواند بر اساس **سرعت تغییر خود** توسعه داده شود. اگر Bounded Context A نیاز به تغییرات مکرر دارد اما Bounded Context B ثابت است، این مشکلی نیست. هر کدام **مستقل تکامل می‌یابد**.

**۴. مرز مالکیت (Ownership Boundary):**
یک Bounded Context باید تنها توسط یک تیم مدیریت شود. این **وضوح مسئولیت** را ایجاد می‌کند و از تضادهای میان‌تیمی جلوگیری می‌کند.

## تفاوت بین Subdomain و Bounded Context

این تمایز بسیار اهمیت‌آفرین است و نویسنده یکی دیگر از نکات مهم را تأکید می‌کند:

**Subdomain‌ها کشف می‌شوند. Bounded Context‌ها طراحی می‌شوند.**

### Subdomain
- **منشأ:** از تحلیل کسب‌وکار ناشی می‌شود
- **تعیین‌کننده:** استراتژی و ساختار تجاری شرکت
- **نقش:** نمایندگی **واقعیت تجاری** سازمان

### Bounded Context
- **منشأ:** از تصمیمات طراحی معماری نرم‌افزار ناشی می‌شود
- **تعیین‌کننده:** نیازهای فنی، سازمانی، و فناوری
- **نقش:** نمایندگی **راه‌حل نرم‌افزاری** برای مسائل تجاری

### رابطه بین آن‌ها

**آنها لزوماً یک‌به‌یک نیستند:**

**سناریو اول: یک Bounded Context برای کل سیستم**
اگر سیستم کوچک است، ممکن است یک Bounded Context برای کل دامین کافی باشد، حتی اگر چندین Subdomain وجود داشته باشد.

**سناریو دوم: Bounded Context‌های متعدد براساس مدل‌های متناقض**
اگر متخصصان کسب‌وکار مدل‌های متناقضی درباره‌ی یک مفهوم دارند، ما Bounded Context‌های جداگانه می‌سازیم.

**سناریو سوم: Bounded Context برای هر Subdomain**
در بسیاری از موارد، هر Subdomain در یک Bounded Context جداگانه پیاده‌سازی می‌شود. این یک انتخاب طراحی معمول است.

**سناریو چهارم: چندین مدل از یک Subdomain**
می‌تواند چندین Bounded Context وجود داشته باشد که **یک Subdomain واحد** را مدل‌سازی می‌کنند، هر کدام برای حل‌کردن یک مشکل متفاوت.

## نکات نهایی و عملی

### ۱. Bounded Context نه Subdomain است

یکی از اشتباهاتی که اغلب در پروژه‌ها دیده می‌شود این است که تیم‌ها تصور می‌کنند Bounded Context و Subdomain یکی هستند. اینطور نیست. برای درک بهتر:

- **Subdomain:** «ما در کسب‌وکار درباره‌ی فروش کار می‌کنیم»
- **Bounded Context:** «ما نرم‌افزار را برای مدیریت فروش به این ترتیب طراحی کرده‌ایم»

### ۲. Bounded Context نیاز به سرزمین‌شناسی فنی دارد

برای تعیین مرزهای Bounded Context، نیاز داریم تا:
- **درباره‌ی کسب‌وکار بسیار بدانیم** (Subdomain‌ها را شناسایی کنیم)
- **درباره‌ی نیازهای فنی و سازمانی فکر کنیم** (نیازهای توسعه‌ی مستقل، نیازهای مختلف فناوری و غیره)
- **محدودیت‌های سازمانی را درنظر بگیریم** (تعداد تیم‌ها، مهارت‌های موجود و غیره)

### ۳. مالکیت واضح است

نویسنده یک بار دیگر تأکید می‌کند که **مالکیت واضح** یکی از مهم‌ترین عوامل موفقیت Bounded Context است. اگر مالکیت مشخص نیست، تمام مزایای Bounded Context از دست می‌رود.

## خلاصه‌ی مختصر

Bounded Context یک **الگوی استراتژیک** در Domain-Driven Design است که:

**۱. مسئله را حل می‌کند:**
زمانی که متخصصان کسب‌وکار مدل‌های متناقضی درباره‌ی یک مفهوم دارند، Bounded Context این ناسازگاری را **تبدیل به فرصت** می‌کند. هر مدل در کانتکست خود معتبر و منطقی است.

**۲. توسعه‌ی مستقل را امکان‌پذیر می‌کند:**
هر Bounded Context می‌تواند مستقل:
- توسعه داده شود
- استقرار داده شود
- نسخه‌برداری شود
- فناوری خود را انتخاب کند

**۳. تیم‌ها را منظم می‌کند:**
با تخصیص واضح مالکیت Bounded Context‌ها به تیم‌ها، ما:
- مسئولیت را روشن می‌کنیم
- تصمیم‌گیری را سریع می‌کنیم
- فرضیات ضمنی را از بین می‌بریم

**۴. معماری را بهبود می‌بخشد:**
Bounded Context‌ها **مرزهای معماری واضح** را تعریف می‌کنند که سیستم را **ماژولار و قابل نگهداری** می‌سازد.

## تمرین‌ها (Exercises)

نویسنده در پایان فصل چند تمرین برای تقویت درک مطالب ارائه می‌دهد:

### تمرین ۱
**سؤال:** تفاوت میان Subdomain و Bounded Context کدام است؟
- (الف) Subdomain‌ها طراحی می‌شوند، Bounded Context‌ها کشف می‌شوند.
- (ب) Bounded Context‌ها طراحی می‌شوند، Subdomain‌ها کشف می‌شوند.
- (ج) Bounded Context و Subdomain اساساً یکی هستند.
- (د) هیچ یک از موارد بالا صحیح نیست.

**پاسخ صحیح:** (ب)

### تمرین ۲
**سؤال:** Bounded Context کدام یک از موارد زیر است؟
- (الف) مرز یک مدل
- (ب) مرز دورة‌ زندگی (Lifecycle)
- (ج) مرز مالکیت
- (د) تمام موارد بالا

**پاسخ صحیح:** (د)

### تمرین ۳
**سؤال:** کدام یک از گزاره‌های زیر درباره‌ی اندازه‌ی Bounded Context درست است؟
- (الف) هرچه Bounded Context کوچک‌تر باشد، سیستم انعطاف‌پذیرتر است.
- (ب) Bounded Context‌ها باید همیشه با مرزهای Subdomain‌ها همسو باشند.
- (ج) هرچه Bounded Context بزرگ‌تر باشد، بهتر است.
- (د) این بستگی دارد (It depends).

**پاسخ صحیح:** (د)

**توضیح:** اندازه‌ی Bounded Context باید متناسب با نیازهای خاص پروژه باشد. نه هرچه کوچک‌تر بهتر است (چون سربار یکپارچه‌سازی زیاد می‌شود) و نه هرچه بزرگ‌تر بهتر است (چون مدل پیچیده می‌شود).

### تمرین ۴
**سؤال:** کدام مورد درباره‌ی مالکیت Bounded Context درست است؟
- (الف) چندین تیم می‌توانند روی یک Bounded Context کار کنند.
- (ب) یک تیم می‌تواند چندین Bounded Context را مدیریت کند.
- (ج) هر Bounded Context باید تنها توسط یک تیم مدیریت شود.
- (د) (ب) و (ج) هردو درست هستند.

**پاسخ صحیح:** (د)

### تمرین ۵
**سؤال:** درباره‌ی کمپانی WolfDesk (شرکتی که در مقدمه‌ی کتاب معرفی شده است)، کدام عملکردهای سیستم ممکن است نیاز به مدل‌های متفاوتی از یک موجودیت مثل «تیکت پشتیبانی» داشته باشند؟

**پاسخ:** شاگرد باید تفکر کند و مثال‌هایی برآورد کند. مثلاً:
- مدل تیکت برای «تخصیص به کارمند پشتیبانی» (به تفصیل ترتیبات زمان‌بندی و مهارت‌های مورد نیاز)
- مدل تیکت برای «پیگیری رضایت مشتری» (به تفصیل بازخوردها و نمرات)
- مدل تیکت برای «تجزیه‌و‌تحلیل روند» (به تفصیل آمار و مدت‌زمان حل)

### تمرین ۶
**سؤال:** درباره‌ی یک پروژه‌ی نرم‌افزاری که در حال حاضر کار می‌کنی (یا کار کرده‌ای)، کدام عملکردهایی می‌تواند به عنوان Bounded Context‌های جداگانه در نظر گرفته شود؟ چرا؟

**پاسخ:** این تمرین شاگرد را ترغیب می‌کند تا به صورت عملی درباره‌ی سیستمی واقعی فکر کند و Bounded Context‌های آن را شناسایی کند.

## پیوند با فصل بعدی

نویسنده در پایان اشاره می‌کند که اگرچه Bounded Context‌ها فائدهمند و ضروری هستند، اما **تنهایی نیستند**. یک سیستم معمولاً شامل چندین Bounded Context است که باید **یکدیگر را یکپارچه کنند**.

در **فصل ۴** (Integrating Bounded Contexts)، خواهیم دید که چگونی Bounded Context‌های مختلف می‌توانند به‌طور مؤثر با هم ارتباط برقرار کنند و داده را تبادل کنند. این یکی از مهم‌ترین چالش‌های معماری است.

## پایان فصل ۳

**خلاصه‌ی کلی فصل ۳:**

| موضوع | نکات کلیدی |
|------|-----------|
| **مسئله** | متخصصان کسب‌وکار مدل‌های متناقضی از یک مفهوم دارند |
| **راه‌حل** | Bounded Context: تقسیم دامین به مدل‌های کوچک‌تر و متسازگار |
| **مزایا** | توسعه‌ی مستقل، مدل‌های روشن، تیم‌های منظم |
| **مالکیت** | یک Bounded Context = یک تیم (اما یک تیم می‌تواند چندین Bounded Context داشته باشد) |
| **تفاوت از Subdomain** | Subdomain کشف می‌شود؛ Bounded Context طراحی می‌شود |
| **در دنیای واقعی** | دامین‌های معنایی، فیزیک، زندگی روزمره |

---

# فصل ۴: یکپارچه‌سازی Bounded Context‌ها - بخش اول

## مقدمه

نویسنده این فصل را با بیانی مهم آغاز می‌کند. اگرچه **Bounded Context‌ها** مستقل هستند و هر کدام مدل خود را دارند، اما **نمی‌توانند تنهایی کار کنند**. یک سیستم معمولاً شامل **چندین Bounded Context** است که باید **برای دستیابی به هدفِ کلی سیستم** با هم کار کنند.

این فصل درباره‌ی **الگوهایی** است که برای یکپارچه‌سازی Bounded Context‌ها استفاده می‌شود. اما این الگوها **تنها تکنیکی نیستند**—آن‌ها **توسط نحوه‌ی ارتباط تیم‌ها** تعیین می‌شوند.

## کنتراکت‌ها (Contracts)

قبل از اینکه درباره‌ی الگوهای یکپارچه‌سازی صحبت کنیم، باید درباره‌ی **کنتراکت‌ها** (Contracts) بحث کنیم.

### تعریف کنتراکت

هر Bounded Context با Bounded Context دیگر **یک رابط ارتباطی** دارد. این رابط، **کنتراکت** نام‌گذاری می‌شود. کنتراکت تعریف می‌کند:

- **کدام داده‌ها** بین Bounded Context‌ها تبادل می‌شود
- **کدام عملیات** یک Bounded Context از Bounded Context دیگر می‌خواهد
- **کدام قوانین** برای این تبادل اعمال می‌شود

### چرا کنتراکت‌ها مهم‌اند؟

هر کنتراکت **بیش از یک طرف** را تحت تأثیر قرار می‌دهد. اگر Bounded Context A یک API تغییر دهد، Bounded Context B که از این API استفاده می‌کند، متأثر می‌شود. بنابراین:

- **کنتراکت‌ها باید تعریف و هماهنگ شوند**
- **تمام طرف‌های درگیر باید موافق باشند**

### زبان کنتراکت

یکی دیگر از مسائل مهم این است: **کدام زبان برای کنتراکت استفاده شود؟**

برای مثال:
- Bounded Context A از **زبان مشترک خود** صحبت می‌کند: «Customer»
- Bounded Context B از **زبان مشترک خود** صحبت می‌کند: «User»

آیا این دو یکی هستند؟ نه لزوماً! Bounded Context A ممکن است درباره‌ی مشتریان پرداخت‌کننده صحبت کند، اما Bounded Context B درباره‌ی تمام کاربران لاگ‌کننده.

بنابراین، کنتراکت باید **بر حسب قرارداد متفق** تعریف شود—نه به زبان یک Bounded Context، نه به زبان دیگری.

## الگوهای یکپارچه‌سازی: سه دسته اصلی

نویسنده **الگوهای یکپارچه‌سازی** را به **سه دسته** تقسیم می‌کند، که هر کدام **بر اساس نوع ارتباط تیم‌ها** است:

### ۱. الگوهای تعاون (Cooperation Patterns)
### ۲. الگوهای مشتری-تامین‌کننده (Customer-Supplier Patterns)
### ۳. الگوهای مسیرهای جداگانه (Separate Ways Patterns)

در این بخش، ما درباره‌ی **الگوهای تعاون** صحبت می‌کنیم.

## الگوهای تعاون (Cooperation Patterns)

الگوهای تعاون برای **Bounded Context‌هایی** مناسب هستند که توسط **تیم‌های با ارتباط خوب و هماهنگی قوی** پیاده‌سازی می‌شوند.

### شرایط تعاون

تعاون موثر زمانی اتفاق می‌افتد:

۱. **تیم‌ها هدفِ یکسانی دارند:** موفقیت یکی برای دیگری مهم است.
۲. **ارتباط منظم:** تیم‌ها مکرراً و منظم با هم صحبت می‌کنند.
۳. **اعتماد و تعهد:** هر تیم برای رفع مسائل یکپارچه‌سازی تعهد دارد.

### دو الگو اصلی تعاون

#### ۱. الگوی شراکت (Partnership Pattern)

**تعریف:**
در الگوی شراکت، دو Bounded Context **هماهنگی دوطرفه** دارند. اگر یک تیم API خود را تغییر دهد، تیم دیگر را **مطلع می‌کند** و تیم دیگر **سازگار می‌شود**—بدون نزاع یا تعارض.

**خصوصیات:**

- **هماهنگی دوطرفه:** نه یکی طرف دیگری را فرمان می‌دهد. هردو برابر هستند.
- **حل‌کردن مشکلات درون قبیله:** زمانی که مسائل یکپارچه‌سازی رخ می‌دهند، تیم‌ها آن‌ها را **با هم حل می‌کنند**.
- **نیاز به انضباط:** Continuous Integration (CI) ضروری است. تغییرات باید **سریع** در هردو سیستم ادغام شوند.

**مثال:**

فرض کنید تیم A (Bounded Context Orders) و تیم B (Bounded Context Inventory) روی سیستم فروش کار می‌کنند.

- تیم A نیاز دارد تا **فوری** بفهمد که محصول در انبار موجود است یا نه.
- تیم B نیاز دارد تا **فوری** بفهمد که یک سفارش ثبت شد.

```
تیم A (Orders)          تیم B (Inventory)
    |                         |
    +-----> سرنخ سفارش ------>|
    |                         |
    |<--- وضعیت موجودی ------+
    |                         |
    +---> تأیید سفارش ------->|
```

تیم‌ها **نزدیک به هم** کار می‌کنند، مشکلات را **سریع** حل می‌کنند.

**محدودیت‌ها:**

- **نیاز به همکاری مستمر:** اگر تیم‌ها **دور از هم** باشند (جغرافیایی یا ساعتی)، این الگو کار نمی‌کند.
- **Scaling:** اگر سیستم بسیار پیچیده شود و تیم‌های زیادی باشند، این الگو مقیاس‌پذیر نیست.

#### ۲. الگوی هسته‌ی مشترک (Shared Kernel Pattern)

**تعریف:**
گاهی اوقات **دو یا بیشتر Bounded Context** نیاز دارند تا **مدل یا کدِ واحدی** را **به‌طور همزمان** استفاده کنند.

**مثال عملی:**

فرض کنید یک سیستم سازمانی سلسله‌مراتبی دارد. هر کارمند می‌تواند:
- **مستقیماً** اجازه‌هایی داشته باشد
- **غیرمستقیماً** اجازه‌هایی را از واحد تشکیلاتی خود **ارث** کند

```
کارمند John
├── اجازه‌های مستقیم: [Read, Edit]
└── اجازه‌های ارثی (از واحد Sales):
    └── [Approve Orders]
```

این مدل **پیچیده** است و **چندین Bounded Context** نیاز دارند تا آن را درک کنند:
- **Bounded Context AccessControl:** برای بررسی اجازه‌های دسترسی
- **Bounded Context HumanResources:** برای مدیریت کارمندان و واحدهای تشکیلاتی
- **Bounded Context AuditLog:** برای ثبت تغییرات اجازه‌ها

### مدل‌های مشترک (Shared Model)

در الگوی **Shared Kernel**، **مدلِ مشترک** (مثلاً کلاس Permission یا کلاس OrganizationalUnit) درون **چندین Bounded Context** **دقیقاً یکسان** استفاده می‌شود.

**نکات مهم:**

۱. **محدوده‌ی کوچک:** Shared Model باید **تنها** شامل بخش‌های ضروری باشد. تمام جزئیات دیگر به‌صورت خصوصی درون هر Bounded Context باقی می‌ماند.

   ```
   Shared Kernel:
   ├── Permission (نام، توضیح)
   └── OrganizationalUnit (ID، نام)
   
   Bounded Context AccessControl (خصوصی):
   ├── Role
   └── RoleAssignment
   
   Bounded Context HumanResources (خصوصی):
   ├── Employee
   └── EmployeeCompensation
   ```

۲. **سازگاری:** اگر **هر Bounded Context** مدل مشترک را تغییر دهد، باید **تغییر برای تمام** انجام شود. این باعث می‌شود که **تغییرات هماهنگ** باشند (یا اصلاً نباشند).

۳. **تعارض‌ها:** اگر دو Bounded Context **درخواست‌های متناقضی** از مدل مشترک داشته باشند، **نمی‌توانیم هردو را رضایت دهیم**. بنابراین، مدل مشترک باید برای **نیازهای تمام طرف‌ها** طراحی شود.

### پیاده‌سازی Shared Kernel

**روش ۱: مخزن مشترک (Shared Repository)**

اگر سازمان از **mono-repository** استفاده می‌کند (یک مخزن بزرگ برای تمام Bounded Context‌ها)، می‌توان مدل مشترک را در یک **پوشه‌ی مشترک** قرار داد:

```
shared-kernel/
├── Permission.cs
├── OrganizationalUnit.cs
└── ...

bounded-contexts/
├── AccessControl/
│   └── (استفاده از shared-kernel)
├── HumanResources/
│   └── (استفاده از shared-kernel)
└── AuditLog/
    └── (استفاده از shared-kernel)
```

**روش ۲: مخزن جداگانه (Separate Repository)**

اگر هر Bounded Context **مخزن جداگانه** دارد، می‌توان Shared Model را در یک **پکیج یا Library جداگانه** استخراج کرد:

```
shared-kernel-library/
├── Permission
├── OrganizationalUnit
└── pom.xml (یا package.json یا .csproj)

access-control-service/
├── pom.xml
└── (dependency: shared-kernel-library)

human-resources-service/
├── pom.xml
└── (dependency: shared-kernel-library)
```

## مزایا و نقاط ضعف الگوهای تعاون

### الگوی شراکت

**مزایا:**
- **ساده:** دو تیم مستقیماً با هم کار می‌کنند
- **کاهش پیچیدگی:** نیازی به میانجی یا کنتراکت پیچیده نیست
- **سرعت:** تصمیمات سریع گرفته می‌شود

**نقاط ضعف:**
- **قابلیت مقیاس‌پذیری:** وقتی تیم‌ها زیاد شوند، کار سخت می‌شود
- **وابستگی:** تیم‌ها بسیار وابسته به یکدیگر هستند
- **توزیع‌شدگی:** اگر تیم‌ها جغرافیایی‌اً دور باشند، غیرممکن است

### الگوی Shared Kernel

**مزایا:**
- **هماهنگی:** اگر مدل مشترک خوب طراحی شود، تمام Bounded Context‌ها آن را درک می‌کنند
- **تکرار‌نشدگی:** کد یا مدل تکرار نمی‌شود

**نقاط ضعف:**
- **تنگی و ارتباط:** تغییر در مدل مشترک **تمام Bounded Context‌ها** را متأثر می‌کند
- **دشواری:** اگر مدل مشترک نادرست طراحی شود، خرابی در تمام جا‌ها منتشر می‌شود
- **تعارض‌ها:** نیازهای مختلف Bounded Context‌ها ممکن است متناقض باشند

## خلاصه‌ی الگوهای تعاون

| الگو | شرایط | مزایا | نقاط ضعف |
|------|------|-------|----------|
| **شراکت (Partnership)** | تیم‌های با ارتباط خوب و قریب | ساده، سریع | نامقیاس‌پذیر، وابسته |
| **Shared Kernel** | نیاز به مدل مشترک | نکرار‌نشدگی کد | تنگی‌ی اتصال، خطر منتشرشدگی خرابی |

## نکات مهم

۱. **الگوهای تعاون برای سیستم‌های کوچک و تیم‌های قریب مناسب‌اند.**

۲. **Shared Kernel باید **کوچک و متمرکز** باشد. اگر بیش‌ازحد بزرگ شود، مشکلاتی ایجاد می‌شود.**

۳. **یک Bounded Context می‌تواند در دو الگوی مختلف قرار داشته باشد.** برای مثال، Bounded Context A با B در الگوی Shared Kernel است، اما با C در الگوی Partnership است.

---

# فصل ۴: یکپارچه‌سازی Bounded Context‌ها - بخش دوم

## الگوهای مشتری-تامین‌کننده (Customer-Supplier Patterns)

تا کنون درباره‌ی **الگوهای تعاون** صحبت کردیم. این الگوها برای تیم‌هایی مناسب بود که **برابر** و **متوازن** بودند.

اما دنیای واقعی **همیشه برابر** نیست. بسیاری از پروژه‌ها **رابطه‌های نامتوازن** دارند. در این موارع:
- یک تیم **تامین‌کننده** (Supplier) است و سرویس یا API ارائه می‌دهد.
- یک تیم **مشتری** (Customer) است و آن سرویس را **استفاده** می‌کند.

### تفاوت با الگوهای تعاون

در الگوهای تعاون:
- تیم A تغییر می‌دهد → تیم B را **خبر می‌دهد** → تیم B **سازگار می‌شود**
- هردو تیم **برابر** در تصمیم‌گیری هستند

در الگوهای مشتری-تامین‌کننده:
- تامین‌کننده سرویس خود را **نگهداری و توسعه** می‌دهد
- مشتری باید **سازگار شود** (یا فشار وارد کند)
- **نیازهای مشتری اهمیت دارد** اما تامین‌کننده **مسئول** نهایی است

## شرایط مناسب برای الگوهای مشتری-تامین‌کننده

این الگوها زمانی مناسب‌اند که:

۱. **وابستگی واضح:** مشتری **به سرویس** تامین‌کننده **وابسته** است
۲. **نقش‌های متفاوت:** تامین‌کننده و مشتری **نقش‌های متفاوتی** دارند
۳. **قدرت نابرابر:** تامین‌کننده **اختیار بیشتری** در تعریف API دارد
۴. **تیم‌های مختلف:** معمولاً این تیم‌ها **نزدیک نیستند** و در سرعت‌های متفاوت کار می‌کنند

## دو الگوی اصلی مشتری-تامین‌کننده

### ۱. الگوی میزبان باز (Open Host Service Pattern)

**تعریف:**
تامین‌کننده یک **API عمومی و خوب‌تعریف‌شده** ارائه می‌دهد که **چندین مشتری** می‌تواند از آن استفاده کند. این API **استاندارد** است و برای **راحتی** کلیه‌ی مشتریان طراحی شده است.

**خصوصیات:**

- **API عمومی و ثابت:** تامین‌کننده API خود را **واضح و مستند** می‌کند
- **حمایت از چندین مشتری:** یک API می‌تواند برای **بسیاری از Bounded Context‌های مختلف** استفاده شود
- **تعهد به سازگاری:** تامین‌کننده **تعهد می‌دهد** که API را **برای عقب‌سو سازگار** نگه دارد (Backward Compatible)
- **تجزیه‌و‌تحلیل تقاضا:** تامین‌کننده باید **نیازهای تمام مشتریان** را درک کند و API را بر این اساس طراحی کند

**مثال عملی:**

فرض کنید **Bounded Context Payment** (پرداخت) یک API عمومی ارائه می‌دهد:

```
API Open Host Service: Payment Service
├── POST /payments
│   ├── amount: number
│   ├── currency: string
│   ├── customer_id: string
│   └── metadata: object
│
├── GET /payments/{id}
│   └── [retrieve payment status]
│
├── POST /payments/{id}/refund
│   ├── amount: number (optional)
│   └── reason: string
│
└── WebHook: payment.completed
    └── [notify all customers when payment succeeds]
```

**مشتریان مختلف** می‌توانند از این API استفاده کنند:
- **Bounded Context Orders** برای تأیید پرداخت سفارش
- **Bounded Context Subscription** برای پرداخت اشتراک ماهانه
- **Bounded Context Refunds** برای بازپرداخت

### مزایا و چالش‌های Open Host Service

**مزایا:**
- **استقلال بیشتر:** مشتریان می‌توانند **به‌طور مستقل** توسعه دهند
- **تغییرات کنترل‌شده:** تامین‌کننده **تغییرات را کنترل** می‌کند و **نسخه‌های قدیم** را دعم می‌کند
- **بیشتر مشتریان:** یک API عمومی می‌تواند **هزاران** یا **میلیون‌ها** مشتری داشته باشد

**چالش‌ها:**
- **طراحی پیچیده:** API باید برای **تمام** مشتریان مفید باشد
- **تعارض‌های نیازمندی:** مشتریان مختلف نیازهای **متناقض** ممکن است داشته باشند
- **سرعت توسعه کاهش**: تامین‌کننده نمی‌تواند **سریع** تغییر کند

### ۲. الگوی زبان منتشرشده (Published Language Pattern)

**تعریف:**
تامین‌کننده یک **زبان (Data Format) استاندارد** برای تبادل‌ی اطلاعات تعریف می‌کند. این **نه API** است، بلکه **قرارداد داده‌ای** است.

**مثال:**

به‌جای اینکه تامین‌کننده یک API با اندپوینت‌های مختلف بدهد، **یک فرمت داده واحد** ارائه می‌دهد (مثلاً JSON Schema یا Protocol Buffers):

```json
// Published Language: Customer Data Format
{
  "customer_id": "string",
  "full_name": "string",
  "email": "string",
  "phone": "string (optional)",
  "address": {
    "street": "string",
    "city": "string",
    "postal_code": "string",
    "country": "string"
  },
  "metadata": {
    "created_at": "ISO8601 datetime",
    "updated_at": "ISO8601 datetime"
  }
}
```

**مشتریان** می‌توانند این **Published Language** را استفاده کنند:
- برای **خواندن** داده‌های Customer
- برای **نوشتن** داده‌های Customer
- برای **تبادل** اطلاعات Customer با سایر سیستم‌ها

### تفاوت Open Host Service و Published Language

| الگو | استفاده | مثال |
|------|---------|------|
| **Open Host Service** | API با عملیات مختلف (GET، POST، DELETE) | `POST /customers` |
| **Published Language** | قرارداد داده‌ای (Data Format) | `{customer_id, name, email, ...}` |

**Open Host Service** = **How** (چگونه عملیات انجام شود)
**Published Language** = **What** (چه داده‌هایی تبادل شود)

### مثال عملی: ترکیب دو الگو

فرض کنید **Bounded Context Customer Management** می‌خواهد برای چندین مشتری سرویس بدهد:

```
Bounded Context: Customer Management

1. Open Host Service API:
   ├── GET /customers
   ├── POST /customers
   ├── PUT /customers/{id}
   └── DELETE /customers/{id}

2. Published Language (قرارداد داده):
   {
     "id": "uuid",
     "name": "string",
     "email": "email",
     "created_at": "datetime"
   }

مشتریان:
├── Bounded Context Orders
│   └── استفاده از GET /customers + Published Language
├── Bounded Context Billing
│   └── استفاده از GET /customers + Published Language
└── Bounded Context Support
    └── استفاده از GET/PUT /customers + Published Language
```

## استراتژی‌های مشتری برای سازگاری

گاهی اوقات **مشتری** نمی‌تواند **مستقیماً** از API تامین‌کننده استفاده کند. شاید:
- API **ناسازگار** با مدل مشتری است
- تامین‌کننده **زیاد تغییر** می‌دهد
- نیازهای مشتری **خاص** هستند

در این موارع، مشتری می‌تواند **یک لایه‌ی درمیانی** بسازد.

### الگوی لایه‌ی ضد فساد (Anticorruption Layer Pattern)

**تعریف:**
مشتری **یک لایه‌ی ترجمه** می‌سازد که:
- داده‌های تامین‌کننده را **می‌گیرد**
- آن‌ها را به **مدل مشتری** **ترجمه** می‌کند
- مدل مشتری از تغییرات تامین‌کننده **محفوظ** می‌ماند

**مثال:**

فرض کنید **Bounded Context Orders** نیاز دارد اطلاعات **مشتری** را از **Bounded Context Customer Management** بگیرد.

اما مدل Customer Management به این شکل است:
```json
{
  "customer_id": "ABC123",
  "full_name": "John Doe",
  "email_address": "john@example.com",
  "phone_number": "+1-555-0000",
  "residential_address": {...}
}
```

مدل Orders بهتر می‌خواهد:
```json
{
  "id": "ABC123",
  "name": "John Doe",
  "contact": "john@example.com"
}
```

**حل: Anticorruption Layer**

Orders یک **ترجمه‌کننده** می‌سازد:

```csharp
// Anticorruption Layer
public class CustomerAdapter
{
    private readonly ICustomerManagementClient client;
    
    public OrderCustomer GetCustomer(string id)
    {
        // داده‌های خام از تامین‌کننده
        var rawCustomer = client.GetCustomer(id);
        
        // ترجمه به مدل Orders
        return new OrderCustomer
        {
            Id = rawCustomer.customer_id,
            Name = rawCustomer.full_name,
            Contact = rawCustomer.email_address
        };
    }
}
```

**مزایا:**

- **استقلال:** Orders **مستقل** از تغییرات Customer Management
- **ترجمه:** داده‌های خام **تبدیل** به مدل مناسب
- **محافظت:** اگر Customer Management **عمدی عوض شود**، Orders **متأثر** نمی‌شود

**نقص:**

- **کد اضافی:** ترجمه‌کننده **کد اضافی** است
- **نگهداری:** اگر Customer Management **زیاد** تغییر کند، ترجمه‌کننده باید **مکرر** بروزرسانی شود

## خلاصه‌ی الگوهای مشتری-تامین‌کننده

| الگو | استفاده | مناسب برای |
|------|---------|----------|
| **Open Host Service** | تامین‌کننده یک API عمومی می‌دهد | چندین مشتری، نیازهای متشابه |
| **Published Language** | قرارداد داده‌ای واضح | تبادل اطلاعات ساختارمند |
| **Anticorruption Layer** | مشتری ترجمه می‌کند | مشتری نیازهای خاص دارد |

## نکات مهم

۱. **Open Host Service برای تامین‌کننده خوب است:** اگر API خوب طراحی شود، چندین مشتری می‌تواند از آن استفاده کند.

۲. **Published Language برای استاندارد‌سازی خوب است:** اگر بسیاری از Bounded Context‌ها **همان قالب داده** را نیاز داشته باشند.

۳. **Anticorruption Layer برای مشتری دفاع است:** مشتری می‌تواند خودش را از تغییرات تامین‌کننده **محفوظ** کند.

۴. **تاثیر بر سرعت توسعه:** Open Host Service موجب می‌شود تامین‌کننده **کندتر** تغییر کند (برای سازگاری با تمام مشتریان)، اما Anticorruption Layer موجب می‌شود مشتری **خودش را نیاز‌های خاص** کند.

---

# فصل ۴: یکپارچه‌سازی Bounded Context‌ها - بخش سوم

## الگوی مسیرهای جداگانه (Separate Ways Pattern)

تا کنون درباره‌ی الگوهایی صحبت کردیم که **Bounded Context‌ها باید یکدیگر را یکپارچه کنند**:
- **الگوهای تعاون** (Partnership، Shared Kernel) برای تیم‌های قریب
- **الگوهای مشتری-تامین‌کننده** (Open Host Service، Anticorruption Layer) برای تیم‌های نامتوازن

اما گاهی اوقات **بهترین راه‌حل این است که Bounded Context‌ها اصلاً یکپارچه نشوند!**

### تعریف Separate Ways

**الگوی Separate Ways** یعنی:
- دو یا بیشتر **Bounded Context** کاملاً **مستقل** هستند
- **داده‌ای تبادل نمی‌کنند**
- **API مشترک ندارند**
- هر کدام **خود را مدیریت** می‌کند
- اگر یکی **تغییر** کند، دیگری **متأثر** نمی‌شود

### موارد استفاده

الگوی Separate Ways زمانی مناسب است که:

۱. **وابستگی کم:** Bounded Context‌ها **پیش‌زمینه‌ای** وابستگی ندارند
۲. **نیازهای متفاوت:** هر Bounded Context **مدل و منطق کاملاً متفاوت** دارد
۳. **تکرار قابل تحمل:** **تکرار داده یا کد** بین Bounded Context‌ها **مقبول** است
۴. **سرعت توسعه مهم:** **نرفتن به تعقیب** یکدیگر برای هماهنگی **اولویت** است

### مثال عملی

فرض کنید یک سیستم حسابداری داریم با دو Bounded Context:

**Bounded Context ۱: Accounting (حسابداری)**
```
Account
├── id
├── name
├── balance
├── type (Asset, Liability, Equity)
└── currency
```

**Bounded Context ۲: Reporting (گزارش‌دهی)**
```
Account
├── id
├── name
├── balance
├── last_updated
└── region
```

اگر نگاه کنیم، هردو **موجودیت Account** را دارند. اما **مدل‌های آن‌ها متفاوت** است:
- **Accounting** نیاز دارد به **نوع حساب و ارز**
- **Reporting** نیاز دارد به **تاریخ بروزرسانی و منطقه**

### راه‌حل Separate Ways

به‌جای تلاش برای **یکپارچه کردن**، Bounded Context‌ها **مستقل** عمل می‌کنند:

```
┌─────────────────┐
│  Accounting     │
│  ├── Accounts   │
│  ├── Journals   │
│  └── Ledgers    │
└────────┬────────┘
         │ (no integration)
         │
┌────────┴────────┐
│  Reporting      │
│  ├── Reports    │
│  ├── Summaries  │
│  └── Analytics  │
└─────────────────┘
```

**نتیجه:**
- هر Bounded Context **مدل Account خود را دارد**
- اگر **Accounting** تغییر کند، **Reporting** نیازی ندارد **تغییر** کند
- اگر **Reporting** ستون جدید اضافه کند، **Accounting** متأثر نمی‌شود

### اما داده‌ها را چگونه بروزرسانی کنیم؟

اگر **Reporting** نیاز دارد اطلاعات **جدید** از **Accounting** بگیرد، چند راه وجود دارد:

#### راه ۱: تکرار داده‌ها (Data Duplication)

**Reporting** **نسخه‌ی خود** از داده‌های Account را **نگهداری** می‌کند:

```
Accounting Database          Reporting Database
├── accounts                  ├── accounts (copy)
├── journals                  ├── reports
└── ledgers                   └── analytics

[Periodic Sync Job]
Accounting → Reporting (هر شب یا هر ساعت)
```

**مزایا:**
- **استقلال کامل:** Reporting می‌تواند **هر زمان** اطلاعات را پردازش کند
- **عملکرد:** Reporting **نیازی ندارد** به Accounting **درخواست** کند (کندتر است)

**نقص:**
- **تاخیر:** Reporting داده‌های **قدیمی** ممکن است داشته باشد
- **نگهداری:** اگر **ساختار داده** در Accounting تغییر کند، sync job **شکست** می‌خورد

#### راه ۲: هر Bounded Context داده خود را بسازد

هر Bounded Context **صفر از صفر** داده‌های خود را تولید می‌کند:

```
Accounting:
├── UserA SubmitTransaction $100
├── System: Create Account + Ledger Entry
└── Accounting Database: ✓ saved

Reporting:
├── [هر ۱۵ دقیقه یک بار]
├── Analyze transactions from logs
├── Generate Report
└── Reporting Database: ✓ updated
```

**مزایا:**
- **استقلال کامل:** هیچ وابستگی مستقیم نیست
- **نیازی به sync نیست:** هر یک **خود را مدیریت** می‌کند

**نقص:**
- **کار تکراری:** منطق تولید داده **تکرار** می‌شود
- **ناسازگاری:** اگر منطق تولید **متفاوت** باشد، داده‌ها **متناقض** می‌شود

## کی استفاده کنیم و کی نه؟

### استفاده از Separate Ways ✓

```
✓ Bounded Context‌ها نیازهای **بسیار متفاوت** دارند
✓ تکرار داده **قابل تحمل** است
✓ **تاخیر در اطلاعات** مشکل نیست
✓ تیم‌ها می‌خواهند **سریع** توسعه کنند
✓ هزینه‌ی یکپارچه‌سازی **زیاد** است
```

### استفاده نکنیم ✗

```
✗ Bounded Context‌ها **بسیار وابسته** هستند
✗ داده‌ها **باید همیشه سازگار** باشند
✗ **تاخیر در اطلاعات ناپذیرفتنی** است
✗ تکرار داده **خطرناک** است
```

## مثال عملی واقعی

فرض کنید یک **سیستم فروش آنلاین** داریم:

### سناریو ۱: استفاده از Separate Ways

```
Bounded Context: Order Management
├── Create Order
├── Update Order Status
└── Cancel Order

Bounded Context: Analytics
├── Report Sales
├── Track Metrics
└── User Behavior

[No direct integration]

Order Management عملیات سفارش را انجام می‌دهد
Analytics هر شب داده‌های دیروز را تجزیه‌و‌تحلیل می‌کند
```

**معادلاً:** تاخیر ۲۴ ساعت در گزارش‌ها قابل تحمل است.

### سناریو ۲: استفاده نکنیم (Open Host Service بهتر است)

```
Bounded Context: Payment
├── Charge Card
├── Handle Refund
└── Check Balance

Bounded Context: Inventory
├── Update Stock
└── Check Availability

[Need immediate sync!]

اگر سفارش تأیید شد:
1. Payment: برداشت پول ✓
2. Inventory: کاهش موجودی ✓
(هر دو باید **فوری** اتفاق بیفتد)
```

اگر Inventory **تاخیری** داشته باشد، می‌تواند **موجودی منفی** شود!

## چهار الگوی اصلی: یک جدول خلاصه

| الگو | رابطه | متناسب با | مثال |
|------|------|---------|------|
| **Partnership** | ↔ دوطرفه، برابر | تیم‌های قریب، تعاون خوب | Orders ↔ Inventory |
| **Shared Kernel** | ⊕ مدل مشترک | نیازهای متشابه | Permissions در چندین Bounded Context |
| **Open Host Service** | → یک‌طرفه، عمومی | تامین‌کننده قوی | Payment API برای چندین مشتری |
| **Separate Ways** | ⊘ هیچ ارتباط | نیازهای متفاوت، تاخیر قابل تحمل | Orders ⊘ Analytics |

## نکات مهم

۱. **Separate Ways نه شکست است:**
   بسیاری از توسعه‌دهندگان **فکر می‌کنند** که الگوی بدون یکپارچه‌سازی **شکست** یا **طراحی بد** است. اما **درست است!** گاهی **بدون تماس** بهتر از **تماس ضعیف** است.

۲. **قانون YAGNI (You Aren't Gonna Need It):**
   اگر **هنوز** نیاز یکپارچه‌سازی **نیست**، آن را **نسازید**. منتظر بمانید تا بفهمید **چه نیاز است**.

۳. **ارزیابی هزینه:**
   - **یکپارچه‌سازی** = بسیاری کد، تست، نگهداری
   - **تکرار** = کد ساده‌تر اما منطق مکرر
   - **کدام کارآمد است؟** این بستگی دارد.

۴. **تغییر الگو:**
   اگر **بعداً** معلوم شود که **Separate Ways** نمی‌تواند **کار کند**، می‌تواند به **Open Host Service** تبدیل شود.

**پایان بخش سوم از فصل ۴**

تا اینجا **سه گروه الگو** را کاور کردیم:
- ✓ الگوهای تعاون (Partnership، Shared Kernel)
- ✓ الگوهای مشتری-تامین‌کننده (Open Host Service، Anticorruption Layer)
- ✓ الگوی مسیرهای جداگانه (Separate Ways)

---

# فصل ۴: یکپارچه‌سازی Bounded Context‌ها - بخش چهارم (نهایی)

## Context Map - نقشه‌ی کانتکست

تا اینجا درباره‌ی **الگوهای یکپارچه‌سازی** مختلف صحبت کردیم. اما یک سیستم بزرگ ممکن است **دستها Bounded Context** و **صدها رابطه** داشته باشد. چگونه می‌توانیم **کل تصویر** را ببینیم؟

**پاسخ: Context Map**

### تعریف Context Map

**Context Map** یک **نمودار بصری** است که نشان می‌دهد:
- **کدام Bounded Context‌ها** در سیستم وجود دارند
- **چگونه Bounded Context‌ها** با یکدیگر **ارتباط دارند**
- **کدام الگو** برای هر ارتباط استفاده می‌شود
- **جریان داده** بین Bounded Context‌ها

### چرا Context Map مهم است؟

۱. **درک کلی:** اگر نقشه ندارید، سیستم **بسیار پیچیده** است
۲. **ارتباط:** توسط Context Map می‌توانید **با تیم‌های دیگر** صحبت کنید
۳. **تصمیم‌گیری:** برای **تغییرات بزرگ**، Context Map **راهنما** است
۴. **سند:** Context Map **مستند** می‌کند که سیستم **چگونه کار می‌کند**

## عناصر Context Map

### ۱. Bounded Context (جعبه)

هر Bounded Context به‌عنوان یک **جعبه** یا **مستطیل** نشان داده می‌شود:

```
┌─────────────────────┐
│   Order Management  │
│   (Bounded Context) │
└─────────────────────┘
```

### ۲. ارتباطات (خطوط و فلش‌ها)

ارتباطات بین Bounded Context‌ها به‌عنوان **خطوط** نشان داده می‌شود:

```
┌──────────────┐         ┌──────────────┐
│   Orders     │────────▶│   Inventory  │
│  (Customer)  │         │  (Supplier)  │
└──────────────┘         └──────────────┘
```

**فلش** جهت **وابستگی** یا **داده‌ای جریان** را نشان می‌دهد.

### ۳. نوع ارتباط (برچسب)

هر ارتباط با **نوع الگو** برچسب زده می‌شود:

```
┌──────────────┐           ┌──────────────┐
│   Orders     │───OHS────▶│   Payment    │
│              │           │              │
│ (Customer)   │           │ (Supplier)   │
└──────────────┘           └──────────────┘

OHS = Open Host Service
```

### ۴. جهت‌گیری

- **→ جهت دار:** Bounded Context سمت چپ **وابسته** به سمت راست است
- **↔ دوطرفه:** هردو **وابسته** هستند (Partnership)
- **⊘ بدون خط:** کاملاً **جداگانه** (Separate Ways)

## نمودار Context Map: مثال واقعی

فرض کنید یک **سیستم فروش آنلاین** داریم. نقشه‌ی Context آن می‌تواند به این‌گونه باشد:

```
                    ┌─────────────────┐
                    │    Billing      │
                    │  (Supporting)   │
                    └────────┬────────┘
                             │
                             │ OHS
                             ▼
    ┌────────────────┐  ┌─────────────┐      ┌──────────────┐
    │   Customers    │──│   Orders    │──SK──│  Inventory   │
    │    (Core)      │  │   (Core)    │      │ (Supporting) │
    └────────────────┘  └─────────────┘      └──────────────┘
             △               │
             │               │ OHS
           ACL               ▼
             │         ┌──────────────┐
             │         │   Payment    │
             └─────────│  (Generic)   │
                       └──────────────┘
```

**توضیح:**

- **Customers** و **Orders** از **SK (Shared Kernel)** استفاده می‌کنند
- **Orders** یک **OHS (Open Host Service)** را برای **Inventory** و **Billing** فراهم می‌کند
- **Customers** از **Payment** یک **ACL (Anticorruption Layer)** استفاده می‌کند
- **Billing** و **Inventory** **مستقل** هستند (Separate Ways)

## شماره‌گذاری الگوها در Context Map

معمولاً Context Map از **اختصارات** استفاده می‌کند:

| اختصار | الگو | مثال |
|-------|------|------|
| **P** | Partnership | دو طرفه ↔ |
| **SK** | Shared Kernel | مدل مشترک |
| **OHS** | Open Host Service | API عمومی |
| **PL** | Published Language | قرارداد داده |
| **ACL** | Anticorruption Layer | لایه ترجمه |
| **SW** | Separate Ways | بدون ارتباط |

## ساخت Context Map: مراحل عملی

### مرحله ۱: شناسایی Bounded Context‌ها

اول **تمام Bounded Context‌ها** را شناسایی کنید:
- کدام‌ها **Core** هستند؟
- کدام‌ها **Generic** هستند؟
- کدام‌ها **Supporting** هستند؟

```
Core:
├── Order Management
├── Customer Management
└── Pricing Engine

Generic:
├── Payment Processing
├── User Authentication
└── Notification Service

Supporting:
├── Reporting
└── Audit Logging
```

### مرحله ۲: شناسایی ارتباطات

برای هر جفت Bounded Context، بپرسید:
- آیا باید **ارتباط داشته باشند**؟
- اگر بله، **کدام الگو** مناسب است؟
- **کدام جهت** دارد؟

```
Order Management → Payment Processing
├── نوع: Customer-Supplier
├── الگو: OHS (Order Management فروشنده است)
└── جریان: Order Details → Payment API

Order Management ↔ Inventory Management
├── نوع: Cooperation
├── الگو: Partnership (تعاون شده)
└── جریان: Stock Updates ↔ Order Updates
```

### مرحله ۳: رسم نمودار

**ابزارهای استفاده‌شده:**
- **Miro** یا **Lucidchart** (برای نمودارات تعاونی)
- **Figma** (برای طراحی و ارتباط)
- **PlantUML** (برای نمودارات کدی)
- **draw.io** (رایگان و ساده)

### مرحله ۴: اعتبارسنجی

Context Map را با **تمام تیم‌ها** بررسی کنید:
- آیا **جاهای تاریک** وجود دارد؟
- آیا **ارتباطات** درست است؟
- آیا **الگوها** منطقی‌اند؟

## Context Map و تقسیم تیم

**Context Map** یک **ابزار مدیریتی** نیز است!

### مثال: تقسیم تیم‌ها

فرض کنید **۶ تا تیم** داریم:

```
Context Map:
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   Orders     │──│  Inventory   │──│  Shipping    │
│  (Team A)    │  │  (Team B)    │  │  (Team C)    │
└──────────────┘  └──────────────┘  └──────────────┘
       │                  │                  │
       │ OHS              │ OHS              │ OHS
       ▼                  ▼                  ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   Payment    │  │   Reports    │  │  Customers   │
│  (Team D)    │  │  (Team E)    │  │  (Team F)    │
└──────────────┘  └──────────────┘  └──────────────┘
```

**مثال تقسیم:**
- **Team A** مالک **Orders**
- **Team B** مالک **Inventory**
- **Team D** مالک **Payment**
- و غیره...

هر **تیم** **مالک یک Bounded Context** است و **نمی‌تواند** روی Bounded Context دیگری کار کند.

## Context Map و تصمیم‌های معماری

### مثال: آیا Separate Ways خوب است؟

فرض کنید **Reporting** و **Orders** **بدون ارتباط** هستند:

```
┌──────────────┐     ┌──────────────┐
│   Orders     │     │  Reporting   │
│              │     │              │
│  (generates  │     │  (reads from │
│   sales)     │     │   database)  │
└──────────────┘     └──────────────┘
         ⊘ (Separate Ways)
```

**سؤال:** آیا Reporting هم‌زمان با Orders است؟

**اگر بله (تاخیر ۶ ساعت مقبول):**
- ✓ Separate Ways خوب است

**اگر نه (تاخیر ناپذیر):**
- ✗ Separate Ways **نمی‌تواند** کار کند
- ✓ به **Open Host Service** تغییر بدهید

## Context Map برای انتقال تلفنی

یکی از بهترین استفاده‌های Context Map این است که **برای توضیح** سیستم در **جلسات تیم** یا **مراجعات معماری** استفاده شود.

### جلسه: تصمیم‌گیری درباره‌ی نوع الگو

```
سناریو: "آیا Payment باید Separate Ways باشد؟"

Context Map:
┌──────────────┐
│   Orders     │
└────────┬─────┘
         │
         ▼ (Separate Ways?)
┌──────────────┐
│   Payment    │
└──────────────┘

بحث:
Engineer A: "اگر Payment fail کند، Order ناقص بماند!"
Engineer B: "می‌تواند async job که دوباره تلاش کند."
Architect: "بیایید Open Host Service استفاده کنیم."

نتیجه: ارتباط تغییر می‌کند:
┌──────────────┐
│   Orders     │
└────────┬─────┘
         │
         ▼ OHS
┌──────────────┐
│   Payment    │
└──────────────┘
```

## نکات مهم درباره‌ی Context Map

۱. **نه استاتیک، پویا است:**
   Context Map **تغییر می‌کند** وقتی سیستم تکامل می‌یابد. **هر ماه یا هر سه‌ماه** آن را **بروزرسانی** کنید.

۲. **برای پروژه‌های بزرگ ضروری است:**
   برای سیستم‌های **۲-۳ Bounded Context**، Context Map **ساده** است. برای **۱۰+ Bounded Context**، **ضروری** است.

۳. **ابزار برای ارتباط:**
   Context Map **زبان مشترک** برای تیم‌های مختلف است. مهندسان، معماران، و مدیران می‌تواند آن را درک کنند.

۴. **نگهداری Context Map:**
   Context Map باید **در مخزن پروژه** ذخیره شود (مثلاً `architecture/context-map.md` یا `context-map.drawio`).

۵. **تکامل مسیری:**
   در حالی‌که پروژه بڑتر می‌شود، Context Map ممکن است **Separate Ways → Open Host Service** یا **Partnership → Open Host Service** شود.

## خلاصه‌ی فصل ۴

### الگوهای یکپارچه‌سازی

| گروه | الگوها | کاربرد |
|------|--------|--------|
| **تعاون** | Partnership، Shared Kernel | تیم‌های قریب، ارتباط خوب |
| **مشتری-تامین** | OHS، PL، ACL | تامین‌کننده قوی، مشتری ضعیف |
| **جداگانه** | Separate Ways | نیازهای متفاوت، استقلال |

### Context Map

- **نمودار بصری** تمام Bounded Context‌ها و ارتباطات
- **ابزار ارتباط** میان تیم‌ها
- **سند معماری** برای سیستم

### نکات کلیدی

۱. **نوع ارتباط بر اساس نوع تیم است:**
   - تیم‌های **تعاون‌گر** → Partnership یا Shared Kernel
   - تیم‌های **نامتوازن** → Open Host Service
   - تیم‌های **مستقل** → Separate Ways

۲. **Anticorruption Layer مهم است:**
   مشتری می‌تواند **خودش را از تغییرات** تامین‌کننده **محفوظ** کند.

۳. **هیچ الگوی "بهترین" نیست:**
   هر الگو **برای شرایط خاص** بهتر است.

۴. **Context Map یک سند زندهٔ است:**
   سیستم تکامل می‌یابد؛ Context Map نیز **باید تکامل** یابد.

**پایان فصل ۴**

## نقاط مهم برای یادگیری

**فصل ۳ و ۴ در یک نگاه:**

- **فصل ۳:** چگونه دامین را به **Bounded Context‌ها** تقسیم کنیم
- **فصل ۴:** چگونه **Bounded Context‌ها** را یکپارچه کنیم و آن‌ها را **مدیریت** کنیم

**بخش اول کتاب (Strategic Design) اکنون کامل است:**
- ✓ فصل ۱: تحلیل دامین کسب‌وکار
- ✓ فصل ۲: زبان مشترک (Ubiquitous Language)
- ✓ فصل ۳: Bounded Context
- ✓ فصل ۴: یکپارچه‌سازی Bounded Context‌ها

**بخش دوم (Tactical Design)** درباره‌ی **پیاده‌سازی** Bounded Context‌ها خواهد بود:
- الگوهای طراحی چگونگی
- Aggregates
- Domain Events
- و غیره

---