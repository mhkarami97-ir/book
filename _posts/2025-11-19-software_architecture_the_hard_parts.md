---
layout: post
full-width: true
title: Software Architecture The Hard Parts
subtitle: Modern Trade-Off Analysis for Distributed Architectures
cover-img: /assets/images/software_architecture_the_hard_parts.jpg
thumbnail-img: /assets/images/software_architecture_the_hard_parts.jpg
share-img: /assets/images/software_architecture_the_hard_parts.jpg
tags: [کتاب, برنامه_نویسی, سیستم_توزیع_شده]
---

## توضیحات
هیچ تصمیم آسانی در معماری نرم افزار وجود ندارد. در عوض، بخش‌های سخت بسیاری وجود دارد؛ مشکلات یا مسائل دشواری که بهترین شیوه ای برای انجام ندارند و شما را مجبور می‌کنند تا با انجام سبک سنگین‌های مختلف، یکی را برای موفقیت انتخاب کنید. با کمک کتاب Software Architecture: The Hard Parts (معماری نرم افزار: قسمت‌های سخت)، شما یاد خواهید گرفت که چگونه به طور انتقادی در مورد سبک سنگین‌های مربوط به معماری‌های توزیع شده فکر کنید.  
پیشکسوتان معماری و مشاوران مجرب، نیل فورد، مارک ریچاردز، پرامود سادالاژ و ژامک دهقانی، درباره راهبردهای انتخاب یک معماری مناسب بحث می‌کنند. نویسندگان با سر هم کردن داستانی درباره یک گروه خیالی از متخصصان فناوری - جوخه Sysops - همه چیز را از نحوه تعیین جزئیات سرویس، مدیریت گردش کار و هماهنگ سازی، مدیریت و جداسازی قراردادها و مدیریت تراکنش‌های توزیع شده تا نحوه بهینه سازی ویژگی‌های عملیاتی، مانند مقیاس پذیری، کشش و عملکرد را مورد بررسی قرار می‌دهند.  
این کتاب با تمرکز بر سوالات متداول، تکنیک‌هایی را ارائه می‌کند که به شما کمک می‌کند تا هنگام مواجهه با مسائلی که به عنوان یک معمار با آن مواجه هستید، سبک سنگین‌ها را انجام دهید و بررسی کنید.

## نظر


## نظر
 - `امتیاز` : 09/10
 - `به دیگران توصیه می‌کنم` : بله
 - `دوباره می‌خوانم` : بله
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : Mark Richards, Neal Ford, Pramod Sadalage, Zhamak Dehghani
 - `انتشارات` : O'Reilly Media

## بخش‌هایی از کتاب

# فصل اول کتاب "Software Architecture: The Hard Parts"
## آنچه رخ می‌دهد وقتی "بهترین روش" وجود ندارد

### چرا معماری نرم‌افزار کار سختی است؟
در این فصل، نویسندگان با یک حقیقت اساسی شروع می‌کنند: در معماری نرم‌افزار، اغلب با مسائلی روبرو هستیم که راه‌حل قطعی و جهانی برای آنها وجود ندارد. مفاهیمی مثل “best practice” فقط تا حدی (و در بعضی فضاها) کاربرد دارند. علت آن:
- پروژه‌ها و چالش‌ها بسیار متنوع‌اند.
- انتخاب‌ها همواره وابسته به نیازهای تجاری، محدودیت‌های فنی و شرایط سازمانی است.
- راه‌حل‌هایی که در یک زمینه جواب می‌دهند، ممکن است در جای دیگر مشکل‌ساز شوند.

### هدف فصل
هدف این فصل، تعریف درست مسئله و دادن نگرش درست به مخاطب است که قرار نیست برای هر چالش معماری، یک جواب واحد وجود داشته باشد. معماری، کار تصمیم‌گیری میان گزینه‌های مختلف و یافتن بهترین راه بر اساس شرایط است.

### چرایی بخش‌های سخت معماری
– **Ambiguity و عدم قطعیت:** خیلی وقت‌ها اطلاعات ناقص یا مبهم است؛ باید با فرضیات گام برداریم و تصمیمات را مطابق تغییرات اصلاح کنیم.
– **Trade-off:** هر راه‌حلی مزایا و معایبی دارد. لازم است مصالحه (trade-off) را بشناسیم و مدیریت کنیم.
– **تعاملات انسانی:** معماری فقط تکنولوژی نیست؛ شامل سازمان، ذینفعان، تیم‌ها و فرهنگ هم هست.

### داده‌ها و اهمیت آنها در معماری
بخشی از فصل به نقش محوری داده می‌پردازد:
- معماری خوب باید از همان ابتدا به سوال “داده‌ها کجا هستند؟ چه کسی صاحب آن‌هاست؟ چگونه اعمال تغییرات و پردازش اطلاعات انجام می‌شود؟” پاسخ بدهد.
- در دوران معماری‌های توزیع‌شده (مثل میکروسرویس یا کلود)، داده‌ها تبدیل به کلیدی‌ترین چالش‌ها شده‌اند چون مالکیت داده بین سرویس‌ها تقسیم می‌شود و مسائل consistency، امنیت و کارایی اهمیت مضاعف پیدا می‌‌کند.

### سند تصمیم معماری (ADR)
نویسندگان تاکید دارند که معماری یعنی "تصمیم‌گیری". بنابراین مستندسازی تصمیمات معماری با شفافیت دلایل، الزامی است. معماری باید "قابل توضیح" و "قابل دفاع" باشد تا بتوان به تیم، ذینفعان یا حتی معماران بعدی چرایی انتخاب‌ها را منتقل کرد.

سند "Architectural Decision Record" یا مخفف آن "ADR" برای همین هدف است: ثبت موضوع تصمیم، گزینه‌های قابل بررسی، دلایل انتخاب و رد هر گزینه و اثرات تصمیم. اگر این فرآیند شفاف و مدون شود، هم یادگیری تسهیل می‌شود، هم خطاهای قبلی تکرار نمی‌شود.

#### تمرین: فکر کن اگر در یک پروژه واقعی، سرویس پرداخت دارید و باید تصمیم بگیرید که اعتبارسنجی کارت بانکی را در همان سرویس انجام دهید یا یک سرویس مستقل ایجاد کنید، چه گزینه‌هایی دارید؟ هر کدام چه مزایا و معایبی دارند؟ دلیل انتخاب نهایی چه خواهد بود؟

### Fitness Function در معماری
ایده "Fitness Function" یا توابع سنجش کارایی/سلامت معماری، از یادگیری ماشین گرفته شده است. مشابه زمانی‌که یک معیار (function) داریم تا بفهمیم مدل یادگیری چقدر خوب کار می‌کند، در معماری هم باید معیارهایی داشته باشیم که به‌صورت اتوماتیک یا دستی، کیفیت تصمیمات و ساختار را ارزیابی کند.

مثال‌ها:
- هیچ سرویسی نباید به بیش از سه سرویس دیگر وابسته باشد.
- نرخ خطای ارتباطات سرویس‌ها باید زیر 0.5٪ بماند.
- دیتابیس‌ها باید فقط توسط سرویس‌های مشخص خودش قابل دسترسی باشند.

#### سوال: آیا تا به حال قانونی (تست یا مانیتورینگ) برای سلامت معماری تعریف کرده‌ای؟ مثلاً در مانیتورینگ‌هایتان چه چیزی را به عنوان "نشانه معماری سالم" می‌شناسید؟

### تفاوت معماری و طراحی
این بخش تمایز بین **معماری** (تصمیمات ساختاری سطح بالا، غیرقابل تغییر یا خیلی سخت قابل تغییر) و **طراحی** (جزئیات پیاده‌سازی، الگوها و ترکیب‌ها) را شرح می‌دهد.
- معماری چیزی است که اگر اشتباه شود، هزینه اصلاح آن بالا است.
- طراحی معمولاً جزئی‌تر است و اصلاحش کم‌هزینه‌تر.

### معرفی مطالعه موردی: Sysops Squad
نویسندگان برای ملموس کردن مباحث از مثال یک پروژه تخیلی به نام "Sysops Squad" استفاده می‌کنند و تصمیمات معماری آن را طی فصل‌ها بررسی می‌کنند تا مفاهیم نه صرفاً تئوری بلکه عملی و واقعی تدریس شوند.



## خلاصه فصل اول (برای تثبیت)
- در معماری نرم‌افزار، جواب قطعی وجود ندارد؛ تصمیمات همیشه trade-off دارند.
- داده‌ها و مالکیت آنها مرکز ثقل معماری توزیع‌شده هستند.
- مستندسازی تصمیمات با ADR الزامی است.
- تعریف Fitness Function برای سلامت معماری اهمیت دارد.
- مرز واضح بین معماری و طراحی را باید بشناسیم.
- مثال پروژه واقعی، مسیر یادگیری را عملی‌تر می‌کند.



### بررسی درک 
- **سئوال:** معمار نرم‌افزار چه زمانی به سراغ سند ADR می‌رود و قرار است چه موضوعاتی را در آن ثبت کند؟
- اگر دوست داری بیشتر با ADR یا Fitness Function کار کنیم یا مثالی برای هرکدام بزنم، بگو تا با هم تمرین کنیم.

## توضیح عمیق و مثالی از ADR (Architectural Decision Record)

### تعریف کامل‌تر
ADR ابزاری ساختاریافته برای ثبت و تحلیل تصمیمات معماری است. این سند، نه تنها انتخاب انجام‌شده، بلکه دلایل، شرایط، گزینه‌های جایگزین و پیامدها را (کامل و با صراحت) مستند می‌کند. کاربردش این است که هر معمار، مدیر یا دولوپری در آینده بتواند منطق تصمیمات را درک کند و اگر نیاز به تغییر بود، آن را آگاهانه و اصولی انجام دهد.

### ساختار استاندارد ADR

معمولاً هر ADR شامل چهار بخش کلیدی است:
1. **عنوان (Title):** موضوع تصمیم معماری، به‌صورت خلاصه.
2. **زمینه (Context):** توضیح شرایط و مشکل/فرصت، به‌همراه گزینه‌های جایگزین.
3. **تصمیم (Decision):** شرح تصمیم گرفته‌شده و علت ارجحیت آن.
4. **پیامدها (Consequences):** اثرات مثبت/منفی تصمیم و trade-offها.



### مثال واقعی ۱: ADR برای سرویس پرداخت

**عنوان:** جداسازی اعتبارسنجی کارت بانکی به سرویس مستقل

**زمینه:**  
پرداخت کاربران باید بلافاصله تأیید شود تا تجربه کاربری مناسب باشد. دو گزینه وجود دارد:
- انجام اعتبارسنجی در همان سرویس خرید
- جدا کردن اعتبارسنجی به یک سرویس مستقل
در صورت استقلال، مزیت دیپلوی مستقل و تحمل خطا داریم، اما لَتِنسی و پیچیدگی افزایش می‌یابد.

**تصمیم:**  
اعتبارسنجی کارت بانکی به‌‌عنوان یک سرویس مستقل پیاده‌سازی می‌شود. این سرویس نسخه‌بندی‌شده و مستقل از چک‌آوت عمل می‌کند.

**پیامدها:**  
- مزیت: دیپلوی مجزا، تحمل بالاتر به خطاهای بانکی، تسهیل تغییر بانک‌های ارائه‌دهنده API.
- عیب: افزایش لَتِنسی (رفت‌وبرگشت شبکه)، احتمال خطا در ارتباطات، پیچیدگی بیشتر مانیتورینگ مسیر سرویس‌ها.



### مثال واقعی ۲: ADR از متن کتاب (Sysops Squad)

**عنوان:** یکپارچگی سرویس مدیریت مشتری

**زمینه:**  
کاربر برای ثبت‌نام باید اطلاعات پروفایل، کارت، پسورد و محصولات را درج کند. سه گزینه:
- تجمیع همه قابلیت‌ها در یک سرویس (یکپارچگی)
- جداسازی بر اساس نوع داده (حساس/غیرحساس)
- جداسازی هر قابلیت به سرویس مستقل

**تصمیم:**  
یک سرویس یکپارچه ساخته می‌شود تا ضمن حفظ تراکنش اتمیک و ACID، انجام عملیات ثبت‌نام سریع و پایدار باشد. امنیت داده‌های حساس از طریق لایه امنیتی ابزار Tortoise و Service Mesh انجام می‌شود.

**پیامدها:**  
- مزیت: انجام عملیات ثبت‌نام در یک transaction، سهولت اطمینان از یکپارچگی داده.
- عیب: در صورت ضعف امنیتی، داده‌های حساس آسیب‌پذیرتر می‌شود؛ وابستگی بیشتر کدها.



## توضیح عمیق‌تر درباره Fitness Function

### فلسفه Fitness Function
در معماری و DevOps هدف این است که سلامت و تطابق ساختار معماری با اهداف تجاری یا تکنیکی به شیوه‌ای *قابل سنجش* و *اتوماتیک* بررسی شود. Fitness Function قاعده‌ای نرم‌افزاری (کد، تست، هشدار، پابنده، یا مانیتورینگ) است که به صورت پیوسته یکی از ویژگی‌های اصلی معماری را اندازه‌گیری می‌کند و اگر سازگاری مختل شد، هشدار یا خطا می‌دهد.

### دسته‌بندی
- **اتمی:** بررسی صرفاً یک معیار (مثلاً عدم وابستگی سیکلی بین ماژول‌ها)
- **کل‌نگر:** ترکیب چند ویژگی (مثلاً حفظ تعادل بین امنیت و کارایی)



### مثال Fitness Function اتمی (کد جاوا-سی‌شارپ)

**بررسی ضد-وابستگی سیکلی**
فرض کنیــد می‌خواهیم مطمئن شویم که هیچ cyclic dependency بین ماژول‌ها وجود ندارد. می‌توان از ابزارهایی مثل [NDepend] برای #C یا [JDepend] برای جاوا استفاده کرد.

```csharp
// با استفاده از NDepend در دات‌نت:
warnif count > 0 from t in Application.Types
where t.IsUsing(t) // چک کردن dependency بر روی خودش یا دیگر ماژول‌های یکسان
select t
```
این خط کد، گزارشی می‌دهد تا هر circular dependency دیده شد، تیم dev هشدار بگیرد.



### مثال Fitness Function کاربردی (سفارشی برای سلامت ارتباطات میکروسرویس‌ها)

**سلامت تعداد وابستگی‌های سرویس**
در سازمانی توافق شده هیچ سرویسی نباید به بیش از ۳ سرویس دیگر وابسته باشد (health of independence):
```yaml
# pseudo-code:
for each service in all_services:
    if service.dependencies.count > 3:
        alert("Service {service.name} has too many dependencies")
```
این اسکریپت می‌تواند در pipeline CI/CD یا مانیتورینگ اجرا شود.



### مثال پیشرفته: تست performance دوره‌ای (holistic)

فرض کنید تیم شما باید تضمین کند که response time برای endpoint خاص، همیشه زیر ۵۰۰ms باشد.
- یک تست performance اتوماتیک در pipeline اجرا می‌کند اگر:
    - میانگین پاسخ بالاتر از عدد threshold باشد، build fail شود.
    - (در تست) مصرف منابع کل cluster را در بازه شلوغی هم بررسی کند.



### مرور و نکاتی عملی:

- **ADR**: هر زمان تصمیم معماری جدی می‌گیرید یا الگوی جدیدی پیاده می‌کنید، همین ساختار را مستند کنید؛ حتی اگر اول کار ساده‌تر بنویسید و بعداً کامل‌تر کنید.
- **Fitness Function**: سعی کن برای هر اصل معماری که برات اهمیت حیاتی دارد، یک تست اتوماتیک یا مانیتورینگ قرار دهی تا هر نوع deviation بلافاصله قابل تشخیص باشد.

---
---

## فصل دوم: درک کوپلینگ (Discerning Coupling in Software Architecture)

در این فصل، تمرکز روی “کوپلینگ” یا وابستگی‌های درونی بخش‌های مختلف یک سیستم نرم‌افزاری است. یکی از سخت‌ترین وظایف معمار، تشخیص و مدیریت همین وابستگی‌هاست. بسیاری از مشکلات پیچیده معماری (مخصوصاً در معماری توزیع‌شده مثل مایکروسرویس‌ها) ناشی از درهم‌تنیدگی غیرشفاف این وابستگی‌هاست.



### ۱. چرا بحث کوپلینگ مهم است؟

همه جا می‌شنویم: *سیستم شُل‌-وابسته (loosely coupled) خوب است!*  
اما واقعیت ساده‌تر و عمیق‌تر است: بعضی کوپلینگ‌ها اجتناب‌ناپذیر و حتی ضروری‌اند. اگر همه اجزای سیستم کاملاً از هم جدا باشند، چگونه باید همکاری کنند؟ معمار موفق کسی است که بفهمد چه وقت، کجا، و چقدر کوپلینگ لازم و مفید است.

> **کوپلینگ یعنی: اگر تغییر در یک بخش سیستم، بخش دیگر را مجبور به تغییر کند، آن دو قسمت کوپل شده‌اند.**



### ۲. قدم‌های تحلیل پیچیدگی معماری

نویسندگان یک مسیر سه‌مرحله‌ای معرفی کرده‌اند:
1. **شناسایی بخش‌های به‌هم‌ گره خورده (Entangled Parts)**  
   باید بفهمیم دقیقا کدام بخش‌ها به هم وابسته‌اند.
2. **تحلیل نوع و شدت کوپلینگ**  
   کوپلینگ فقط یک معنی ندارد! نوع و سطح آن (ایستا/پویا) اهمیت دارد.
3. **تحلیل تِرِید-آف (Trade-Off)ها**  
   تغییر چه اثری روی بخش‌های دیگر می‌گذارد؟ هزینه تغییر چیست؟ ممکن است علاوه بر مشکلات کد و فنی، اثرات سازمانی و تجاری هم داشته باشد.



### ۳. تعریف "کوآنتوم معماری" (Architecture Quantum)

اینجا نویسندگان یک مفهوم بکر معرفی می‌کنند:  
**"کوآنتوم معماری" یعنی: کوچکترین واحد مستقل از نگاه پیاده‌سازی و دیپلوی که کارایی بالا، کوپلینگ ایستا و کوپلینگ پویا دارد.**

- مثال: یک میکروسرویس کامل که هسته یک بیزینس ‌دومِین (Bounded Context) را پیاده‌سازی می‌کند.
- هر کوآنتوم ویژگی‌های زیر را باید داشته باشد:
  - **دیپلوی مستقل** (شما می‌توانید آن را جدا توسعه و دیپلوی کنید)  
  - **همبستگی داخلی بالا** (functional cohesion بالا؛ یعنی اجزای داخلی آن به هم بشدت مرتبط‌اند ولی بیرونش کمترین ارتباط را دارد)  
  - **کوپلینگ ایستا (Static Coupling) بالا:** اجزای درون کوآنتوم از لحاظ کد، کانفیگ، دیتابیس و ... به هم وابسته‌اند.
  - **کوپلینگ پویا (Dynamic Coupling):** اجزای مختلف کوآنتوم در زمان اجرا با هم ارتباط دارند (معمولاً به صورت سینکرون).

#### پرسش:  
- آیا تجربه کردی که بخواهی بخشی از برنامه را جدا دیپلوی کنی، اما چون دیتابیس مشترک بود، عملاً نتوانستی مستقل این کار را انجام دهی؟  
- نتیجه: کوآنتوم عملی نشده و هنوز کوپلینگ بین دو بخش باقی مانده است.



### ۴. انواع کوپلینگ: ایستا و پویا

#### الف) کوپلینگ ایستا (Static Coupling)  
این همان وابستگی‌هایی است که در زمان ساخت و Build (نه اجرا) دیده می‌شود: مثلاً
- Dependency به یک پکیج یا لایبرری خارجی
- داشتن یک دیتابیس مشترک یا کامپوننت مشترک
- قراردادهای سخت کد (مثل Strong Typing، یا شِرینگ مدل‌های داده بین سرویس‌ها)
  
**ویژگی:** اگر بخواهید فلان سرویس را بدون این وابستگی دیپلوی کنید، شکست می‌خورید.  
 پس هر عنصر خارجی که برای اجرا لازمه، بخشی از کوپلینگ ایستا است.

#### ب) کوپلینگ پویا (Dynamic Coupling)  
ارتباطاتی که فقط در زمان اجرا ایجاد می‌شود:
- فراخوانی API بین سرویس‌ها در زمان اجرای برنامه
- ارسال پیام از طریق پیام‌برها (Message Broker) یا صف‌ها
- تعامل سرویس‌ها با یکدیگر در طول یک Workflow

**ویژگی:** بدون وجود ارتباط در لحظه، بخش‌ها می‌توانند "مستقل اجرا شوند" اما workflow به صورت runtime بهم وصل می‌شود.



### ۵. گیج‌کننده‌ترین چالش معماری: Granularity صحیح سرویس‌ها

سؤال قدیمی: "سرویس‌های من چندتا باشند؟ هرکدام چقدر بزرگ؟"  
- **سرویس خیلی کوچک:** مشکل تراکنش، اورکستراسیون و اجرای هماهنگ Workflow
- **سرویس خیلی بزرگ:** inherit مشکلات مانولیتی؛ scale و توزیع سخت می‌شود

اینجا تحلیل کوپلینگ تمرکز اصلی است؛ باید بفهمیم هر سرویس (یا کوآنتوم) چقدر از سایر سرویس‌ها مستقل است.



### ۶. مثال‌ها و سناریوها

#### مثال ۱:  
یک سیستم نوبت‌دهی کلینیک داریم:
- **مودل مانولیتی:** همه ماژول‌ها (ویزیت، صندوق، پیامک، پرداخت) یکجا دیپلوی می‌شوند و دیتابیس مشترک دارند. فقط یک کوآنتوم تشکیل می‌شود، هرچقدر هم بخش‌بندی کد کنیم.
- **سناریوی توزیع:** اگر "پرداخت" را واقعاً جدا کنیم (با دیتابیس مختص و API جدا)، و همه وابستگی‌های Deployment را قطع کنیم، تبدیل به یک کوآنتوم مستقل می‌شود.

#### مثال ۲ (از فصل):  
در یک معماری event-driven، اگر همه سرویس‌ها از یک message broker و یک دیتابیس استفاده کنند (مثلاً Kafka و یک RDBMS مشترک)، باز هم کوآنتوم یکی است، چون هیچ‌کدام بدون آن منابع مشترک کار نمی‌کنند.

ولی، اگر چند سرویس، دیتابیس و message broker جدا داشته باشند، هرکدام کوآنتوم مستقل خواهند بود.

#### تمرین:  
- در پروژه فعلی‌ات، اگر یک سرویس جدید بسازی:
  - آیا کاملاً جدا دیپلوی می‌شود؟
  - آیا دیتابیس و منابع زیرساخت خودش را دارد؟
  - آیا در زمان اجرایش نیازی به روشن بودن سایر سرویس‌ها نیست؟
  اگر به همه *بله* دادی، تو یک کوآنتوم مستقل داری.



### ۷. اشکال و الگوهای رایج معماری و وضعیت کوانتوم آنها

- **معماری مانولیتی و نیو-مانولیت (Monolithic):** فقط یک کوآنتوم
- **Service-Based**: اگر دیتابیس مشترک باشد، باز فقط یک کوآنتوم
- **Microservices واقعی:** هر سرویس (با دیتابیس، پیاده‌سازی، و منابع جدا) کوآنتوم جدا.  
- **Micro-frontends:** هر بخش از UI که توسط یک میکروسرویس جدا ران می‌شود، خودش یک کوآنتوم مجزاست.
- **Shared DB:** هر جا هنوز دیتابیس مشترک وجود دارد، حتی اگر سرویس‌ها مستقل باشند، فقط یک کوآنتوم واقعی خواهد بود و جداسازی ناقص است.



### ۸. ابزار عملی برای تحلیل کوپلینگ

#### معیار ساده:
"اگر این بخش را در محیط جدید بدون هیچ چیز دیگر بالا بیاوریم و کار کند، کوآنتوم مستقل است."

#### ابزارهای کمکی:
- دیاگرام‌های مدرن وابستگی (Dependency graphs)
- ابزارهای تحلیل استاتیک کد (مثل SonarQube، NDepend)
- جداسازی زیرساخت‌های مورد نیاز (Databases، Message Brokers، ...)
- تحلیل کانفیگ و مدیریت اسرار (Secrets Management)



### جمعبندی این فصل (کد به ذهن بسپار):

- **کوپلینگ الزاماً بد نیست؛ میزان و محل آن مهم است.**
- **کوآنتوم معماری = کمترین واحد واقعا مستقل اجرایی و ساختاری**
- **کوپلینگ ایستا = وابستگی‌های ساختاری/قبل اجرای برنامه**
- **کوپلینگ پویا = وابستگی‌های ارتباطی/در زمان اجرا**
- **هر منبع اشتراکی (حتی UI یا DB) عامل یکی‌کردن کوآنتوم‌هاست**
- **در فاز مهاجرت مانولیت به میکروسرویس، تحلیل دقیق و عملی کوپلینگ ضروری است**



#### سؤالات یادگیری و تأمل:
1. چگونه می‌توانی بفهمی یک کوآنتوم واقعی داری، نه یک شبه-میکروسرویس؟
2. نمونه‌ای در پروژه‌ات داری که کوپلینگ مانع جدایی کامل یک سرویس شده باشد؟
3. آیا دیاگرامی از Dependency ها در پروژه رسم کرده‌ای؟ چه چیزهایی را آشکار می‌کند؟

### بررسی کوپلینگ و کوآنتوم وقتی Broker و Database زیرساخت مرکزی دارند

#### ۱. سرویس مرکزی Kafka، ولی Topic جدا برای هر سرویس

**سناریو:**  
فرض ‌کن همه سرویس‌ها برای ارسال و دریافت پیام از یک Kafka مرکزی استفاده می‌کنند، اما هر سرویس فقط داخل topic خودش پیام می‌فرستد و مصرف می‌کند.

**تحلیل کوپلینگ:**  
- **زیرساخت مرکزی («Shared Infrastructure»):**  
  همه سرویس‌ها برای عملکردشان وابسته به Kafka هستند؛ اگر Kafka قطع شود، کل سیستم دچار اختلال خواهد شد.
- **Topic جدا:**  
  از نظر "business logic"، مستقل‌اند (یعنی داده و پیام‌های هر سرویس با دیگری ترکیب نمی‌شود)، اما از نظر اجرا وابسته به Kafka مرکزی.
  
**نتیجه:**  
- این معماری کوآنتوم واقعی نمی‌سازد، چون اگر مثلا بخواهی فقط یکی از سرویس‌ها را در محیطی بدون Kafka بالا بیاوری، کار نمی‌کند.
- اگر Kafka به طور موازی و مستقل (برای هر سرویس یک instance جدا) داشته باشی، تازه هر سرویس کاملاً مستقل می‌شود و کوآنتوم واقعی شکل می‌گیرد.
- فقط جدا بودن Topic کافی نیست: dependency روی Kafka مرکزی یعنی *کوپلینگ ایستا مشترک*، حتی اگر coupling پویا (ارتباطات داده‌ای) جدا باشد.

#### ۲. دیتابیس مرکزی، اما دیتابیس‌های جدا روی آن

**سناریو:**  
- یک سرور SQL یا RDBMS مرکزی داریم، اما برای هر سرویس schema و دیتابیس جدا تعریف شده است. هیچ سرویسی جدول‌های سرویس دیگر را نمی‌خواند یا نمی‌نویسد.

**تحلیل کوپلینگ:**  
- **زیرساخت مرکزی:**  
  همه سرویس‌ها نیازمند در دسترس بودن سرور دیتابیس مرکزی هستند. اگر سرور DB قطع شود، تمام سرویس‌ها آسیب می‌بینند.
- **دیتابیس جدا:**  
  "مرز داده‌ها" رعایت شده، هر سرویس صاحب data و schema خودش است، پس coupling در سطح business logic پایین آمده است.

**نتیجه:**  
- این هم کوآنتوم کامل نیست، مگر اینکه بتوانی هر سرویس را با دیتابیس خودش (روی instance جدا یا حتی روی سرور مستقل) بالا بیاوری.
- وقتی دیتابیس مشترک، هرچند با schema جدا، وجود دارد dependency زیرساختی یکجا می‌کند؛ تمام سرویس‌ها به روشن بودن سرور وابسته‌اند.
- از نظر تغییرپذیری: آپدیت امنیت یا patch سرور روی همه اثر دارد؛ اگر باید یکی را مستقل به روزرسانی کنی و بقیه وابسته باشند، وابستگی باقی مانده است.



### برای مقایسه

| **حالت دیتابیس**                   | **حالت واقعی**                                |
|-------------------------------------|-----------------------------------------------|
| دیتابیس server جدا برای هر سرویس    | هر سرویس کوآنتوم واقعی/دیپلوی/تغییر مستقل     |
| دیتابیس مشترک، ولی schema جدا      | کوپلینگ زیرساختی دارد، استقلال ناقص           |
| دیتابیس/جدول مشترک                  | کوپلینگ کامل، فقط یک کوآنتوم                  |

| **حالت Kafka/Message Broker**       | **حالت واقعی**                                |
|-------------------------------------|-----------------------------------------------|
| Broker جدا برای هر سرویس            | کوآنتوم واقعی/سرویس کاملاً منفصل               |
| Broker مشترک، Topic جدا            | استقلال ناقص، dependency زیرساختی باقی است     |
| Broker و Topic مشترک                | کوپلینگ کامل، تنها یک کوآنتوم                  |



### نکته مهم
در معماری‌های enterprise معمولاً اجتناب کامل از shared infrastructure عملی نیست (به دلایل هزینه، اجرا، DevOps). هدف معماری ایده‌آل این است که لایه زیرساخت طوری مدیریت شود که قطع یا تغییر یک سرویس، سایر سرویس‌ها را مختل نکند و دیپلوی سرویس‌ها صددرصد مستقل باشد. کوآنتوم کامل، این استقلال را ممکن می‌کند.

#### سوال برای تمرین:  
در پروژه فعلی‌ات (یا پروژه‌ای که ساختارش را می‌شناسی)، آیا سرویس‌ها واقعا مستقل‌اند؟ اگر زیرساخت دیتابیس یا Message Broker را قطع کنی، کدام سرویس‌ها واقعا زنده می‌مانند؟  
این تست ساده، میزان کوپلینگ را خیلی خوب نشان می‌دهد.

اگر دوست داشتی با هم درباره الگوهای حذف این کوپلینگ (مثل استفاده از دیتابیس‌های آسان-مستقل، Brokerهای Micro-Broker یا containerized) بیشتر کار کنیم، بگو تا راهکار معماری حرفه‌ای را تحلیل کنیم.  
آیا دوست داری سناریو و دیاگرام پیشنهادی برای یک کوآنتوم واقعی با ابزارهای دنیای .NET و Kafka عملی‌تر بررسی کنیم؟

---
---

## ادامه فصل دوم: کوپلینگ پویا (Dynamic Coupling) و Workflow در معماری سرویس‌گرا

در بخش قبلی، کوپلینگ ایستا (static coupling) و اثر آن بر "کوآنتوم معماری" را به دقت تحلیل کردیم. اما یک بخش کلیدی دیگر باقی مانده: کوپلینگ پویا و نقش آن در runtime و workflowهای معماری‌های نوین.



### کوپلینگ پویا (Dynamic Coupling) چیست؟

کوپلینگ پویا به ارتباطات اجزای معماری در زمان اجرا اشاره دارد. این یعنی: سرویس‌ها، ماژول‌ها یا اجزای یک سیستم، هنگام انجام عملیات تجاری چگونه با هم حرف می‌زنند و همکاری می‌کنند.

- اگر ارتباطات حتما باید به صورت هم‌زمان (synchronous) و با شِرط موفقیت فوری باشد، کوپلینگ پویا "سخت‌تر" است.
- اگر تعاملات به‌صورت غیرهم‌زمان (asynchronous) انجام شود (مثلا Event/Message مدل)، سطح کوپلینگ کمتر خواهد بود ولی مدیریتِ خطا و چرخه داده پیچیده‌تر می‌شود.

#### مثال:
- در ارتباط sync: سرویس پرداخت درخواست را به سرویس سفارش می‌دهد و منتظر پاسخ می‌ماند (اگر قطع شود، کل جریان متوقف می‌شود).
- در ارتباط async: سرویس پرداخت پیام را روی یک صف یا broker ارسال می‌کند و دیگر منتظر پاسخ سرویس سفارش نمی‌ماند؛ هر وقت جواب آماده شد، سرویس دیگر واکنش نشان می‌دهد.



### سه بُعد مهم در کوپلینگ پویا

نویسندگان کتاب می‌گویند هر معماری توزیع‌شده، باید این سه محور را در تعاملاتش شفاف کند:

1. **Communication (ارتباط):**  
   - Synchronous (همزمان)  
   - Asynchronous (غیرهمزمان)

2. **Consistency (تراکنش‌پذیری):**  
   - Atomic (همراه با تضمین اتمی بودن عملیات)
   - Eventual consistency (هر بخش به مرور به حالت سازگار می‌رسد، اما تضمین آنی نیست)

3. **Coordination (هماهنگی):**  
   - Orchestration (یک سرویس مرکزی فرآیند را مدیریت می‌کند)
   - Choreography (هر خدمت فقط خودش را می‌شناسد و به پیام‌های event-driven پاسخ می‌دهد)

این سه بعد به صورت ماتریس با eight الگوی مختلف ترکیب می‌شوند (مثلا Epic Saga, Fairy Tale, Phone Tag و غیره) که هرکدام برای نیازهای خاصی مناسب‌اند.



### اهمیت انتخاب الگوی مناسب

انتخاب اشتباه جفت‌های ارتباط/تراکنش/هماهنگی باعث موارد زیر می‌شود:
- افزایش latency و بروز race condition
- تحمل‌پذیری پایین و کاهش availability
- مدیریت مشکل خطاها و خطاهای تراکنشی

#### مثال:
- اگر هم orchestration و هم تضمین atomicity داشته باشیم، عملاً یک سرویس مرکزی داریم که باید کل عملیات را rollback کند (مثل نمونه Epic Saga).
- اگر choreography و eventual consistency باشد، هر سرویس با پیام event فقط بخش خودش را انجام می‌دهد حتی اگر بقیه سرویس‌ها شکست بخورند، با سیستم eventual recovery مشکل حل می‌شود (نمونه Fairy Tale).



### دیاگرام‌های تصمیم و کوپلینگ

کتاب مثال‌هایی تصویری دارد:
- **Mediated EDA** (Event-Driven با Central Mediator): هر سرویس برای تعامل با سایر سرویس‌ها یا منابع مشترکی مثل دیتابیس، از یک mediator یا broker مرکزی استفاده می‌کند. این کوپلینگ را تقویت می‌کند و معمولا فقط یک کوآنتوم ایجاد می‌کند.
- **Brokered EDA with Multiple Data Stores:** اگر هر مجموعه‌ای از سرویس‌ها دیتابیس و message broker مجزا داشته باشند، کوآنتوم‌های مستقل شکل می‌گیرند.



### ضرب‌آهنگ تصمیم‌سازی معمار

- باید ابتدا مرز کوآنتوم‌ها را مشخص کنی (هم از نظر دیپلوی و هم runtime)
- برای هر workflow، سطح مورد نیاز coupling و consistency و coordination را بازبینی کنی
- ابزارهایی مثل تست یکپارچگی (Integration Tests)، مانیتورینگ distributed tracing و event schema validation را استفاده کنی تا از سلامت runtime coupling مطمئن شوی



### جمع‌بندی بخش کوپلینگ پویا:

- کوپلینگ ایستا و پویا دو بُعد مکمل‌اند.
- مدیریت ارتباطات sync/async و atomic/eventual در قلب معماری مدرن قرار دارد.
- معمار خوب قبل از هر اقدام، الگوی مناسب برای workflowها را به صراحت انتخاب و مستند می‌کند.

---
---

### الگوهای مدیریت Workflow در معماری توزیع‌شده: Choreography و Orchestration

بخش بعدی فصل به بررسی دو الگوی عمده برای مدیریت جریان‌های کاری (workflow) در سامانه‌های توزیع‌شده می‌پردازد. انتخاب بین این الگوها، یکی از تصمیمات سرنوشت‌ساز معماری است چون روی کوپلینگ، مقیاس‌پذیری و قابلیت اطمینان سیستم تاثیر کلیدی دارد.


#### ۱. Orchestration

در این الگو، یک سرویس مرکزی (Orchestrator یا Mediator) کل جریان را مدیریت می‌کند. این سرویس مرکزی مسئول:
- تعیین توالی انجام کارها
- فراخوانی سرویس‌های مختلف
- مدیریت وضعیت جریان و هندل‌کردن errorها است

**ویژگی‌ها:**
- کنترلی متمرکز بر کل جریان.
- مدیریت راحت‌تر خطا و rollback.
- وضعیت workflow همیشه قابل ردیابی کامل است.
- اما: یکی از نقاط کوپلینگ مرکزی در سیستم تلقی می‌شود؛ کاهش دهنده flexibility و scale است.

**مثال:**  
در یک سیستم سفارش آنلاین، Order Orchestrator ترتیب را مشخص می‌کند:  
ابتدا ثبت سفارش → فراخوانی سرویس پرداخت → تایید پرداخت → ارسال به Fulfillment → ابلاغ به سرویس ایمیل.


#### ۲. Choreography

در این الگو هیچ سرویس مرکزی وجود ندارد؛ هر سرویس خودش با مشاهده eventها و پیام‌ها تصمیم می‌گیرد چه کاری انجام دهد. گردش کار به صورت غیرمتمرکز بین سرویس‌ها پخش می‌شود.

**ویژگی‌ها:**
- هر سرویس فقط خود و eventهای مرتبط را می‌شناسد و action خودش را انجام می‌دهد.
- مقیاس‌پذیری و انعطاف‌پذیری بالاتر.
- خطا و exception handling سخت‌تر و پراکنده‌تر است.
- ردیابی وضعیت کل workflow به شکل متمرکز دشوار است.

**مثال:**  
در همان سیستم سفارش، سرویس Order پس از ایجاد سفارش، event ایجاد سفارش رامنتشر می‌کند. Payment با شنیدن این پیام، اقدام به پرداخت می‌کند و پس از موفقیت، نتیجه را به صورت event اعلام می‌کند و Fulfillment با شنیدن نتیجه، سفارش را ارسال می‌کند.


#### ۳. مقایسه و Trade-off

|     | Orchestration | Choreography |
|-----|---------------|--------------|
| کنترل مرکزی کار | دارد | ندارد |
| مقیاس‌پذیری | کمتر | بیشتر |
| قابلیت ردیابی وضعیت | راحت | دشوار |
| مدیریت خطا | متمرکز | پراکنده |
| پیچیدگی پیاده‌سازی | پایین‌تر | بالاتر در سناریوهای پیچیده |
| تاثیر بر کوپلینگ | بالاتر | پایین‌تر |


#### ۴. مثال کاربردی: workflow تیکت پشتیبانی

فرض کن سه سرویس Ticket Management, Assignment, Notification داری:
- در Orchestration، یک سرویس Workflow Manager همه گام‌ها را سرویس به سرویس فراخوانی و نتیجه را پیگیری می‌کند.
- در Choreography، Ticket Management پس از ایجاد تیکت، event مربوطه را publish می‌کند. Assignment و Notification بر اساس این event تصمیم‌گیری و اجرا می‌کنند؛ اگر گامی fail شود، event مرتبط با خطا منتشر می‌شود و سایر سرویس‌ها واکنش نشان می‌دهند.


#### ۵. توصیه‌های کلیدی

- اگر به traceability، مدیریت متمرکز خطا یا انعطاف در تغییر گام‌ها نیاز داری، Orchestration انتخاب بهتری است.
- اگر scale و استقلال تیم‌ها هدف اصلی باشد، یا workflow ساده‌تر یا تغییرپذیر است، Choreography گزینه مناسب‌تری است.
- هر دو الگو در واقع complement هم هستند و می‌توانند ترکیبی در پروژه‌های بزرگ داشته باشند.

## تراکنش جبرانی (Compensating Transaction) چیست؟

تراکنش جبرانی یک الگو برای مدیریت خطا و بازگرداندن وضعیت در سیستم‌های توزیع‌شده است، زمانی که امکان استفاده از تراکنش‌های کلاسیک (ACID) وجود ندارد. چون در معماری microservices یا event-driven هر سرویس داده یا عمل خاص خودش را انجام می‌دهد، گاهی بخشی از عملیات کامل شده ولی یکی از مراحل آخر کار fail می‌شود. در این صورت دیگر نمی‌توان مثل تراکنش پایگاه داده “همه چیز را به عقب برگرداند”.

### تعریف دقیق
تراکنش جبرانی یا Compensating Transaction عملی است که اثر عملیات قبلی را که موفق بوده‌اند، خنثی (یا معکوس) می‌کند تا سیستم به وضعیت سازگار بازگردد. این کار معمولاً به صورت یک روال نرم‌افزاری مجزا برای هر مرحله‌ی موفق قبلی طراحی می‌شود.

### مثال کاربردی

فرض کن در یک سیستم رزرواسیون سفر، فرآیند خرید شامل مراحل زیر است:
1. صدور بلیت پرواز
2. رزرو هتل
3. پرداخت نهایی

اگر پس از موفقیت در مرحله 1 و 2، پرداخت نهایی شکست خورد، باید:
- بلیت پرواز **لغو** شود (compensating transaction)
- رزرو هتل **آزاد** یا کنسل شود (compensating transaction)
این لغو عملیات معادل “rollback” در تراکنش‌های متمرکز بانک اطلاعاتی است، با این تفاوت که هر مرحله rollback جداگانه‌ای دارد و با تاخیر اجرا می‌شود.

### نحوه پیاده‌سازی

- در معماری‌های مبتنی بر Saga، برای هر action یک compensating action تعریف می‌شود.
- این عملیات معمولاً به صورت پیام (event) به سرویس مسئول ارسال می‌شود.
- ممکن است عملیات جبرانی دقیقاً معکوس عمل اصلی نباشد، چون وضعیت سیستم یا داده‌ها تغییر کرده است (مثلاً اگر بلیت صادر شده refund می‌شود و جریمه‌ای لحاظ می‌گردد).

### نکات کلیدی

- همیشه برای هر گام اصلی که وضعیت سیستم را تغییر می‌دهد، باید امکان compensating action در نظر گرفته شود.
- تراکنش جبرانی تضمین می‌کند حتی در شکست‌های جزئی، داده سیستم به وضعیت سازگار نزدیک بماند، هرچند ممکن است مثل ACID کاملاً بی‌اثر نباشد.
- این روش trade-off اصلی را بین availability و consistency مدیریت می‌کند.

اگر نیاز داشتی یک مثال واقعی یا pseudo code اجرای compensating transaction در .NET یا یک نمونه event-driven را بررسی کنیم، بنویس تا دقیق‌تر توضیح دهم.

---
---

## درس جدید: الگوها و انواع Saga Pattern در معماری توزیع‌شده

Saga Pattern یکی از مهم‌ترین راهکارهای مدیریت تراکنش و یکپارچگی داده (Consistency) در معماری‌های مدرن است. استفاده درست از Saga به شما اجازه می‌دهد تراکنش‌هایی را که میان چند سرویس یا دیتابیس توزیع‌شده باید رخ دهند، بدون نیاز به 2PC و با قابلیت مدیریت خطا (و بازگشت وضعیت) طراحی کنید.

### معرفی: Saga چیست؟

Saga در اصل فرایندی است که از چند "تراکنش محلی" متوالی (Local Transaction) تشکیل شده است. هر قدم تراکنشی را روی یک سرویس یا زیرسیستم اجرا می‌کند. اگر در وسط کار یکی از این مراحل fail شود، بجای انجام "rollback" کامل مانند بانک اطلاعاتی سنتی، یک یا چند عملیات جبرانی (compensating transactions) اجرا می‌شود تا اثر مراحل قبلی را خنثی یا معکوس کند.

**شکل ساده:**  
1. اقدام A اجرا شود (مثلا محول‌کردن وظیفه)
2. اقدام B اجرا شود (مثلا پرداخت)
3. اگر مرحله بعدی fail شد (مثلا ارسال کالا)، مراحل پیشین با جبران‌کننده معکوس (cancel/reverse) شوند

### انواع Saga و ماتریس این الگو

در کتاب، Saga بر اساس سه بعد اصلی طبقه‌بندی می‌شود:

- **Communication**: Synchronous یا Asynchronous  
- **Consistency**: Atomic یا Eventual  
- **Coordination**: Orchestrated (با orchestrator) یا Choreographed (سرویس‌ها خودمختار)

این سه ویژگی باعث ایجاد 8 حالت یا Pattern اصلی می‌شود (Epic Saga، Fairy Tale، Anthology، ...). هر کدام مزایا و معایب خود را دارند و باید متناسب با نیاز سیستم انتخاب شوند.

| نام الگو        | نوع ارتباط | Consistency | هماهنگی    | توضیح مختصر                          |
|----------------|------------|-------------|------------|--------------------------------------|
| Epic Saga      | Sync       | Atomic      | Orchestrated| الگوی کلاسیک مثل monolithic ACID     |
| Phone Tag      | Sync       | Atomic      | Choreographed| فرانت کنترلر، atomic اما بدون mediator|
| Fairy Tale     | Sync       | Eventual    | Orchestrated| orchestrator اما با eventual          |
| Time Travel    | Sync       | Eventual    | Choreographed| بدون orchestrator و با eventual      |
| Fantasy Fiction| Async      | Atomic      | Orchestrated| پیچیده و کم کاربرد                  |
| Horror Story   | Async      | Atomic      | Choreographed| بدترین حالت؛ atomic, async, بی‌هماهنگی|
| Parallel       | Async      | Eventual    | Orchestrated| mediator + async + eventual          |
| Anthology      | Async      | Eventual    | Choreographed| کمترین coupling، بیشترین آسانی scale|

### مثال عملی از یک Saga مدیریت تیکت پشتیبانی

1. **START**: ثبت تیکت توسط کاربر (در Ticket Service).
2. **CREATED**: سرویس ذی‌ربط، تیکت را assign می‌کند.
3. **ASSIGNED**: تیکت به موبایل متخصص ارسال می‌شود.
4. **ACCEPTED**: متخصص تائید می‌کند.
5. **COMPLETED/REASSIGN**: یا مشکل رفع و وضعیت بسته می‌شود، یا به متخصص دیگر می‌رود.

اگر در هر مرحله شکست رخ دهد، یک transaction جبرانی برای معکوس کردن عملیات قبلی اجرا می‌شود (مثلا اگر assign موفق شود اما ارسال پیام شکست بخورد → assign لغو شود).

### نکات کلیدی انتخاب Saga Pattern

- **الگوهای orchestration**، مدیریت خطا و وضعیت را ساده‌تر می‌کنند و برای workflowهای پیچیده مناسب‌اند اما ممکن است scale را کاهش دهند.
- **Choreography**، ساده‌تر، مقیاس‌پذیرتر و decoupled تر است اما مدیریت error و وضعیت workflow سخت‌تر می‌شود.
- در الگوهای "Eventual Consistency" تاخیر و اختلاف لحظه‌ای داده بین سرویس‌ها طبیعی است.
- پیاده‌سازی "Compensating Transaction" ضروری است و هر عملیات عملی باید قابلیت معکوس‌سازی داشته باشد.

### تمرین و استفاده حرفه‌ای

- برای هر معماری distributed، ببین کدام نقطه از ماتریس Saga برای کاربرد تو مناسب‌تر است (مثلا سامانه سفارش ساده = Anthology، سامانه مالی حساس = Epic یا Fairy Tale).
- ترسیم state machine کارکرد Saga با نمودار (یا code) کمک به شفافیت روند می‌کند.
- در هر گام باید logging و dead-letter queue طراحی شود برای بازیابی خودکار یا بررسی دستی خطاها.


برای هر پترن، سه‌تا محور رو یادت نگه دار:  
Communication (Sync/Async)، Consistency (Atomic/Eventual)، Coordination (Orchestrated/Choreographed). الان هر ۸ تا رو با تمرکز روی کاربرد، مزایا/معایب و جاهایی که به درد می‌خورن باز می‌کنیم.

## Epic Saga (sao) – کلاسیک، شبیه Monolith

- **ویژگی‌ها:** Sync + Atomic + Orchestrated.
- **شکل ذهنی:** یک Orchestrator مرکزی داری که با چند سرویس صحبت می‌کند و همه باید در یک تراکنش “همه یا هیچ” موفق شوند.

### مزایا
- بیشترین شباهت به دنیای Monolith و ACID؛ برای تیم‌های عادت‌کرده به RDBMS راحت‌تر است.
- یک نقطه واضح برای کنترل workflow و error handling (Orchestrator).

### معایب
- Coupling بسیار زیاد (هر سه بعد شدید): هر مشکلی در یک سرویس، کل saga را می‌خواباند.
- پیاده‌سازی distributed atomicity (با compensating transactions و امثالهم) پر از failure mode و پیچیدگی است؛ scale و performance ضعیف می‌شود.

### کِی استفاده؟
- فرآیندهای خیلی حساس که فعلاً سازمان “اتمی بودن” را رها نمی‌کند (بانکی/مالی internal).  
- وقتی هنوز به‌نوعی در حال transition از monolith هستی و نخواستی ذهن بیزینس را با eventual consistency درگیر کنی.

## Phone Tag (sac) – Front Controller بدون Orchestrator

- **ویژگی‌ها:** Sync + Atomic + Choreographed.
- **شکل ذهنی:** هیچ Orchestrator رسمی نیست؛ اولین سرویسی که call می‌شود نقش Front Controller را دارد و بعد خودش سرویس بعدی را call می‌کند، و همین‌طور زنجیروار.

### مزایا
- یک bottleneck مرکزی (orchestrator) نداری، پس کمی scale بهتر نسبت به Epic.
- happy path می‌تواند سریع‌تر باشد چون آخرین سرویس مستقیم جواب را برمی‌گرداند.

### معایب
- هنوز atomic است، پس پیچیدگی transactional باقی است.
- هر سرویس باید هم منطق دامین خودش را بداند هم منطق workflow و error chain را، که complexity را بالا می‌برد.

### کِی استفاده؟
- Workflow ساده، تعداد گام کم، و نیاز به atomic بودن؛ ولی نمی‌خواهی Orchestrator مرکزی بسازی.  
- به‌محض اینکه workflow پیچیده شود، عملاً مجبورت می‌کند برگردی به Orchestrator.

## Fairy Tale (seo) – خوش‌خیم‌ترین حالت پرکاربرد

- **ویژگی‌ها:** Sync + Eventual + Orchestrated.
- **شکل ذهنی:** Orchestrator داری، ولی به‌جای atomic بودن، هر سرویس تراکنش محلی خودش را انجام می‌دهد و کل داستان با eventual consistency تنظیم می‌شود.

### مزایا
- constraint سخت Atomic حذف می‌شود؛ هر سرویس transaction خودش را مدیریت می‌کند.
- Orchestrator مدیریت workflow و error handling را ساده می‌کند؛ پیچیدگی ذهنی نسبتاً پایین است.
- scale نسبت به Epic خیلی بهتر است، چون locking سراسری و ۲PC نداری.

### معایب
- Coupling هنوز بالاست (sync + orchestrator).
- باید بیزینس را قانع کنی که “تاخیری کوتاه” در هماهنگ شدن داده‌ها طبیعی است.

### کِی استفاده؟
- اکثر سیستم‌های business-critical با نیاز به traceability و مدیریت خطای متمرکز ولی قابل‌قبول بودن eventual consistency.  
- جای خیلی خوبی برای مهاجرت از Epic به سمت الگوهای شُل‌تر.

## Time Travel (sec) – chain sync با eventual

- **ویژگی‌ها:** Sync + Eventual + Choreographed.
- **شکل ذهنی:** سرویس‌ها chain می‌سازند (مثل Pipes and Filters یا Chain of Responsibility)، هرکدام تراکنش خودش را انجام می‌دهد و نتیجه را به بعدی پاس می‌دهد؛ orchestrator وجود ندارد.

### مزایا
- coupling نسبت به Fairy Tale کمتر است چون Orchestrator حذف شده.
- برای workflowهای خطی با throughput بالا (import داده، پردازش batch، pipeline های ساده) بسیار خوب است.

### معایب
- برای workflowهای پیچیده، debugging و error handling سخت می‌شود.
- هر سرویس باید context بیشتری از workflow بداند (state + خطا).

### کِی استفاده؟
- pipelineهای نسبتاً ساده با مراحل زیاد ولی منطق ساده (ETL، پردازش log، پردازش سندها).  
- جایی که eventual consistency اوکی است و نیاز به orchestrator مرکزی نداری.

## Fantasy Fiction (aao) – Async + Atomic + Orchestrated

- **ویژگی‌ها:** Async + Atomic + Orchestrated.
- **شکل ذهنی:** می‌خواهی هم atomic باشی، هم orchestrator داشته باشی، هم async باشی؛ ظاهراً “خوبه”، اما…

### مزایا
- از نظر تئوری، می‌خواهد performance را با async بالا ببرد ولی transactional باقی بماند.

### معایب
- atomicity در دنیای async یعنی orchestrator باید state همه تراکنش‌های درحال اجرا (pending) را نگه‌ دارد، با race condition و deadlock و ترتیب رسیدن پیام‌ها سر و کله بزند.
- پیاده‌سازی و دیباگ بسیار سخت؛ scale هم در عمل خوب نمی‌شود چون atomic بودن گلوگاه است.

### کِی استفاده؟
- خیلی کم؛ معمولاً باید یا atomic را رها کنی (برو Parallel)، یا async را؛ این پترن در کتاب تقریباً به‌عنوان “چیزی که بهتر است نروی سمتش مگر مجبور باشی” مطرح شده.

## Horror Story (aac) – ضد‌الگوی واقعی

- **ویژگی‌ها:** Async + Atomic + Choreographed.
- **شکل ذهنی:** هیچ Orchestrator ای نداری، همه چیز async است، ولی می‌خواهی atomic هم باشی. باید از هر جایی بتوانی state همه تراکنش‌های توزیع‌شده را در زمان‌های مختلف، out-of-order، rollback کنی.

### مزایا
- تقریباً مزیت جدی‌ای ندارد نسبت به الگوهای بهتر! coupling در دو بعد کم شده، ولی atomic همه چیز را خراب می‌کند.

### معایب
- پیاده‌سازی و reasoning تقریباً کابوس؛ هر سرویس باید undo چند تراکنش درحال اجرا را بداند، با ترتیب‌های مختلف و پیام‌های out-of-order.
- error handling به‌شدت پیچیده؛ debugging و operation آن در محیط واقعی بسیار سخت.

### کِی استفاده؟
- عملاً نباید انتخاب شود؛ بیشتر به‌عنوان anti-pattern مطرح است و هشدار: «اگر از Epic شروع کردی و برای performance فقط async و choreography اضافه کردی، داری توی Horror Story می‌افتی».

## Parallel (aeo) – Orchestrator + Async + Eventual

- **ویژگی‌ها:** Async + Eventual + Orchestrated.
- **شکل ذهنی:** orchestrator داری، اما callها async هستند و هر سرویس تراکنش خودش را دارد؛ orchestrator بیشتر state و هماهنگی و error recovery را مدیریت می‌کند.

### مزایا
- throughput و responsiveness بالا به خاطر async.
- eventual consistency complexity atomic را کاهش می‌دهد؛ تراکنش‌های محلی ساده‌ترند.
- مناسب workflowهای پیچیده که هنوز می‌خواهی “مرکز کنترل” داشته باشی.

### معایب
- orchestrator همچنان یکی از گلوگاه‌های معماری است (از نظر scale و availability).
- مدیریت state async و error handling پیچیده‌تر از Fairy Tale است.

### کِی استفاده؟
- workflowهای پیچیده با نیاز به throughput بالا و کنترل متمرکز (مثلاً orchestration سفارش در سیستم‌های بزرگ).  
- وقتی از Fairy Tale شروع کردی و بعد نیاز به async برای performance پیدا شد.

## Anthology (aec) – کم‌کوپل‌ترین، بیشترین scale

- **ویژگی‌ها:** Async + Eventual + Choreographed.
- **شکل ذهنی:** هیچ orchestrator ای نیست؛ سرویس‌ها با event/message و async کار می‌کنند، هرکدام state و تراکنش خودش را دارد؛ نهایت decoupling.

### مزایا
- کمترین coupling بین همه پترن‌ها؛ بهترین scale و elasticity.
- عالی برای throughput بالا، پردازش‌های event-driven، pipes & filters با حجم زیاد.

### معایب
- complexity بالاست: هیچ مرکز کنترل واحدی نیست، برای workflow پیچیده باید state را در خود پیام‌ها یا state machineها (با تکنیک‌هایی مثل stamp coupling) حمل کنی.
- debug و trace کل workflow نیاز به observability قوی (tracing, correlation id, log) دارد.

### کِی استفاده؟
- سیستم‌های event-driven بزرگ، ingestion و پردازش انبوه داده، microservices mature با تیم‌های مستقل و observability قوی.  
- وقتی SLA ها بیشتر روی throughput و availability است تا “فوری atomic بودن”.

## جمع‌بندی مقایسه‌ای

### جدول مقایسه‌ای سریع

| Pattern        | Comm   | Consistency | Coord        | Coupling | Complexity | Scale | نمونه استفاده خوب |
|----------------|--------|------------|-------------|---------|-----------|-------|--------------------|
| Epic           | Sync   | Atomic     | Orchestrated| خیلی زیاد | کم تا متوسط | خیلی کم | شبیه monolith، مالی حساس |
| Phone Tag      | Sync   | Atomic     | Choreograph.| زیاد | زیاد | کم | workflow ساده، بدون orchestrator |
| Fairy Tale     | Sync   | Eventual   | Orchestrated| زیاد | خیلی کم | خوب | میکروسرویس های تجاری متعارف |
| Time Travel    | Sync   | Eventual   | Choreograph.| متوسط | کم | خوب | pipelines ساده با throughput بالا |
| Fantasy Fiction| Async  | Atomic     | Orchestrated| زیاد | زیاد | کم | نادر، بهتر است از Parallel استفاده شود |
| Horror Story   | Async  | Atomic     | Choreograph.| متوسط | خیلی زیاد | متوسط | anti-pattern، ازش فرار کن |
| Parallel       | Async  | Eventual   | Orchestrated| کم | کم | خیلی خوب | workflow پیچیده + throughput بالا |
| Anthology      | Async  | Eventual   | Choreograph.| خیلی کم | زیاد | عالی | event-driven با خطای کم/ساده |