---
layout: post
full-width: true
title: Working Effectively with Legacy Code
subtitle: Working Effectively with Legacy Code
cover-img: /assets/images/working_effectively_with_legacy_code.jpg
thumbnail-img: /assets/images/working_effectively_with_legacy_code.jpg
share-img: /assets/images/working_effectively_with_legacy_code.jpg
tags: [کتاب, مهندسی, برنامه_نویسی]    
---

## توضیحات
در صنعت، اغلب از Legacy Code به عنوان اصطلاحی برای کدی که تغییرش سخت است و ما آن را نمی‌فهمیم استفاده می‌شود. اما من پس از سال‌ها کار با تیم‌های مختلف و کمک کردن به آن‌ها در رفع کردن مشکلات جدی کد هایشان، به تعریف متفاوتی دست یافتم.

از نظر من Legacy Code، کدی است که فاقد تست است. چند دلیل نیز برای این تعریف خودم دارم. تست‌ها چه ربطی به بد بودن کد دارند؟ از نظر من پاسخ بدیهی است و این نکته ای است که در این کتاب می‌خواهم آن را بیان کنم:

کد بدون تست، کد بدی است. اهمیتی ندارد که چقدر خوب نوشته شده باشد یا چقدر زیبا و شی گرا یا به خوبی کپسوله سازی شده باشد. با داشتن تست‌ها است که ما می‌توانیم رفتار کد را به سرعت و به طرز صحیحی تغییر دهیم. بدون آن‌ها ما واقعا نمی‌دانیم که آیا کد بهتر شده یا بدتر شده است.

## نظر


## نظر
 - `امتیاز` : 00/10
 - `به دیگران توصیه می‌کنم` : 
 - `دوباره می‌خوانم` : 
 - `ایده برجسته` : 
 - `تاثیر در من` : 
 - `نکات مثبت` : 
 - `نکات منفی` : 

## مشخصات
 - `نویسنده` : Michael C. Feathers
 - `انتشارات` : Prentice Hall
 - `صفحه مشخصات` : [goodreads](https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code)  

## بخش‌هایی از کتاب

بسیار خوب، اکنون محتوای ابتدایی کتاب را دریافت کردم. اجازه دهید اولین بخش را به صورت مفهومی و ساختاریافته برای شما تشریح کنم.

## **Part I: The Mechanics of Change (مکانیک تغییر)**

### **فصل ۱: Changing Software (تغییر نرم‌افزار)**

#### **بخش اول: چهار دلیل برای تغییر نرم‌افزار**

مایکل فِترز در ابتدای این فصل یک تمایز بنیادین را مطرح می‌کند: تغییر کد کار ماست، اما **چگونگی** این تغییر می‌تواند زندگی ما را سخت یا آسان کند. او چهار دلیل اصلی برای تغییر نرم‌افزار را مطرح می‌کند:

1. **اضافه کردن یک قابلیت (Adding a feature)**
2. **رفع باگ (Fixing a bug)**
3. **بهبود طراحی (Improving the design)**
4. **بهینه‌سازی استفاده از منابع (Optimizing resource usage)**

#### **نکته کلیدی ۱: تمایز بین Add Feature و Fix Bug چالش‌برانگیز است**

فِترز مثال می‌زند: مدیری می‌گوید لوگوی صفحه را از چپ به راست ببرید و animated کنید. این یک **bug** است یا **feature**؟

- از نگاه **مشتری**: یک مشکل است که باید برطرف شود.
- از نگاه **توسعه‌دهنده**: این یک feature کاملاً جدید است.

**اما واقعیت چیست؟**  
تمام این بحث‌ها پرده‌ای است که یک مفهوم فنی مهم‌تر را پنهان می‌کند: **Behavioral Change** (تغییر رفتار).

> **قاعده طلایی:**  
> رفتار (Behavior) مهم‌ترین چیز در نرم‌افزار است. کاربران به آن وابسته‌اند. اگر رفتاری که به آن اعتماد دارند را تغییر دهیم (یا باگ ایجاد کنیم)، اعتمادشان را از دست می‌دهیم.

#### **نکته کلیدی ۲: تمایز بین "افزودن رفتار" و "تغییر رفتار"**

فِترز یک تمایز فنی مهم ایجاد می‌کند:

- **اگر باید کد را تغییر دهیم** (modify existing code) → احتمالاً رفتار را تغییر می‌دهیم.
- **اگر فقط کد جدید اضافه کنیم و آن را فراخوانی کنیم** → معمولاً رفتار جدید اضافه می‌کنیم.

**مثال Java:**

```java
public class CDPlayer {
    public void addTrackListing(Track track) { ... }
}
```

اگر متد جدیدی اضافه کنیم:

```java
public void replaceTrackListing(String name, Track track) { ... }
```

**آیا رفتار تغییر کرد؟** خیر! چرا؟ چون متد فراخوانی نشده است.

اما اگر یک دکمه در UI اضافه کنیم که این متد را فراخوانی می‌کند → رفتار اضافه می‌شود **و** رفتار موجود (رندر UI) کمی تغییر می‌کند (یک دکمه بیشتر، زمان رندر کمی بالاتر).

> **بینش عمیق:**  
> تقریباً غیرممکن است که بدون تغییر حداقلی رفتار، رفتار جدیدی اضافه کنیم.

---

## **بخش دوم: بهبود طراحی (Improving Design) و بهینه‌سازی (Optimization)**

### **۳. بهبود طراحی (Design Improvement)**

فِترز اینجا یک نکته بسیار اساسی را مطرح می‌کند: **تغییر طراحی یک کار متفاوت است**.

وقتی می‌خواهیم ساختار نرم‌افزار را تغییر دهیم تا **قابل‌نگهداری‌تر** شود، معمولاً می‌خواهیم **رفتار نرم‌افزار بدون تغییر باقی بماند**.

> **مشکل اساسی:**  
> بسیاری از برنامه‌نویسان تلاش برای بهبود طراحی را انجام نمی‌دهند، چون **بسیار آسان است که رفتار را تغییر دهند** یا بدتر، **باگ جدیدی ایجاد کنند**.

#### **تعریف Refactoring:**

**Refactoring** (بازسازی) به معنای **بهبود ساختار بدون تغییر رفتار** است.

```
تعریف رسمی: "تغییری در ساختار داخلی نرم‌افزار که آن را راحت‌تر برای فهم 
و ارزان‌تر برای تغییر می‌کند، بدون تغییر رفتار موجود"
```

**نکته کلیدی:** تفاوت بین refactoring و تمیزکاری عمومی:
- **Refactoring**: مجموعه‌ای از تغییرات **ریز و محدود** (مثل extract method)، **با تست‌های حمایتی**
- **Cleanup عمومی**: ممکن است شامل کارهای **ریسک‌آمیز** مانند بازنویسی بخش‌های بزرگ باشد

> **اصل طلایی Refactoring:**  
> هنگام refactoring، **نباید تغییرات عملکردی** رخ دهد (اگرچه عملکرد می‌تواند بهتر یا بدتر شود)

### **۴. بهینه‌سازی (Optimization)**

Optimization شبیه refactoring است، اما **هدف متفاوت** دارد:

- **Refactoring**: ساختار را تغییر می‌دهیم تا **قابل‌فهم‌تر** شود
- **Optimization**: منابع (زمان، حافظه) را تغییر می‌دهیم

در **هر دو حالت**، **عملکردی (functionality) را ثابت نگه می‌داریم**.

### **۵. گردهم‌آوری (Putting It All Together)**

فِترز اینجا یک جدول مهم ارائه می‌دهد که **سه چیز متفاوتی را در هر نوع تغییر** نشان می‌دهد:

| نوع تغییر | ساختار | عملکردی جدید | عملکردی موجود | استفاده از منابع |
|---------|--------|-------------|--------------|-----------------|
| **اضافه کردن قابلیت** | تغییر | تغییر | - | - |
| **رفع باگ** | تغییر | - | تغییر | - |
| **Refactoring** | تغییر | - | - | - |
| **Optimization** | - | - | - | تغییر |

**دو نکته مهم:**
1. در **Refactoring و Optimization** هر دو، **عملکردی موجود ثابت می‌ماند**
2. **اضافه کردن قابلیت و Refactoring و Optimization** همگی **عملکردی موجود را حفظ** می‌کنند (یا تغییرات بسیار کم)

### **۶. بخش پایانی: ریسک (Risky Change)**

فِترز سؤالی بسیار مهم می‌پرسد:

> **"اگر هر تغییری ریسک‌آمیز است، چقدر تغییر می‌توانیم تحمل کنیم؟"**

او یک **تصویر شماتیک** ترسیم می‌کند که نشان می‌دهد **ما همیشه مقدار زیادی رفتار موجود را باید حفظ کنیم**:

- رفتار موجود = 95%
- رفتار جدید = 5%

**این یعنی:**
- باید تغییرات **کوچک** را **درست** انجام دهیم
- باید **بیشتر رفتار** را حفظ کنیم و **نمی‌دانیم** چه مقدار از آن در خطر است

#### **سه سؤال برای کاهش ریسک:**
1. **چه تغییراتی باید انجام دهیم؟**
2. **چگونه می‌دانیم که درست انجام شده است؟**
3. **چگونه می‌دانیم که چیزی را شکسته نیستیم؟**

#### **استراتژی نادرست:**

بسیاری از تیم‌ها تلاش می‌کنند با **اجتناب از تغییرات** ریسک را کم کنند:
- سیاست: "اگر خرابی نیست، دست نزنید"
- درخواست کم: کد را درون یک متد قرار دهید تا از نیاز به تغییرات بیشتر جلوگیری شود

**مشکل این استراتژی:** کد بزرگ‌تر می‌شود، درک آن سخت‌تر می‌شود، و **کوچک‌تر کردن کلاس‌ها سخت‌تر می‌شود**

---