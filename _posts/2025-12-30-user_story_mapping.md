---
layout: post
full-width: true
title: User Story Mapping
subtitle: User Story Mapping Discover the Whole Story, Build the Right Product
cover-img: /assets/images/user_story_mapping.jpg
thumbnail-img: /assets/images/user_story_mapping.jpg
share-img: /assets/images/user_story_mapping.jpg
tags: [کتاب, مهندسی, برنامه_نویسی]
---

## توضیحات
اگر از یک روند توسعه چابک استفاده می‌کنید، به احتمال زیاد لیست کار‌های انجام نشده (backlogs) را با داستان‌های کاربری پر می‌کنید. از آنجایی که من تصور می‌کردم که داستان‌ها (stories) شیوه رایجی هستند، نوشتن درباره آنها در این کتاب باعث اتلاف وقت من می‌شود. اما من اشتباه می‌کردم. در یک دهه و نیم از زمانی که داستان‌ها توسط Kent Beck برای اولین بار توصیف شده اند، آنها بیشتر از هر زمان دیگری محبوب‌تر هستند و همچنین بیشتر بد فهمیده و بد استفاده شده اند. این مرا ناراحت می‌کند. علاوه بر این، همه مزایایی که ما از نگاشت داستان به دست می‌آوریم را از بین می‌برد. بنابراین، در این کتاب، من مایلم تا آنجا که می‌توانم تصورات غلط بزرگ در مورد داستان‌ها و نحوه استفاده از آنها در توسعه نرم افزار Agile و Lean را اصلاح کنم. به همین دلیل، به گفته Tom Waits، من این «ساندویچ را به یک ضیافت» تبدیل کرده ام.
نگاشت داستان کاربری، ابزاری ارزشمند برای توسعه نرم افزار است؛ اما وقتی که دلیل و نحوه‌ی استفاده از آن را بفهمید. این کتاب آموزنده، بررسی می‌کند که چگونه این تکنیک اغلب بد فهمیده شده، می‌تواند به تیم شما کمک کند تا بر روی کاربران و نیاز هایشان بدون گم شدن در ویژگی‌های منحصر به فرد محصول، متمرکز باقی می‌بماند.
نویسنده این کتاب، Jeff Patton به شما نشان می‌دهد که چگونه نگاشت‌های داستانی متغیر، تیم شما را قادر می‌سازد تا در طول مراحل توسعه گفتگوهای بهتری درباره پروژه انجام دهند. تیم شما یاد خواهد گرفت تا به درکی مشترک از آن چه که شما کوشش می‌کنید تا بسازید برسد.

## نظر


## نظر
 - `امتیاز` : 08/10
 - `به دیگران توصیه می‌کنم` : بله
 - `دوباره می‌خوانم` : بله
 - `ایده برجسته` : User Story Mapping به تیم‌ها کمک می‌کند تا دید بهتری نسبت به محصول و نیازهای کاربران داشته باشند و از گم شدن در جزئیات ویژگی‌ها جلوگیری کنند
 - `تاثیر در من` : درک بهتر از اهمیت نگاشت داستانی در توسعه نرم‌افزار و بهبود همکاری تیمی
 - `نکات مثبت` : کمک به تمرکز بر نیازهای کاربران، بهبود همکاری تیمی، تسهیل گفتگوهای پروژه
 - `نکات منفی` : ممکن است برای تیم‌های تازه‌کار در Agile کمی پیچیده باشد

## مشخصات
 - `نویسنده` : Jeff Patton
 - `انتشارات` : O'Reilly

## بخش‌هایی از کتاب

### بخش ۱: پیش‌گفتار مارتین فاولر (Foreword by Martin Fowler)

**۱. ریشه اصلی User Story (داستان کاربر):**
فاولر توضیح می‌دهد که مفهوم *User Story* اولین بار توسط کنت بک (Kent Beck) در متدولوژی XP (Extreme Programming) معرفی شد. هدف اصلی کنت بک این بود که فرآیند «نیازمندی‌های نرم‌افزار» (Requirements) را تغییر دهد.
در رویکردهای سنتی، نیازمندی‌ها به صورت اسناد سنگین و طولانی نوشته می‌شدند که اغلب درک درستی از آنها بین تیم فنی و بیزنس وجود نداشت.

**۲. سوءتفاهم رایج در صنعت:**
نکته انتقادی فاولر این است:
> "Many people have focused on the 'User Story' as a thing written on a card."
> (بسیاری از افراد تمرکزشان را فقط روی این گذاشتند که User Story چیزی است که روی یک کارت نوشته می‌شود.)

بسیاری از تیم‌ها فکر می‌کنند اگر نیازمندی‌ها را روی کارت‌های کوچک بنویسند، در حال انجام Agile هستند. اما هدف اصلی کنت بک، **نوشتن** نبود؛ بلکه **گفتگو (Conversation)** بود. کارت‌ها فقط باید بهانه‌ای برای شروع گفتگو بین توسعه‌دهندگان و ذینفعان (Stakeholders) باشند، نه اینکه جایگزین مستندات قطور شوند و همان رفتار سنتی را داشته باشند.

**۳. مشکل Backlogهای خطی (Flat Backlogs):**
فاولر اشاره می‌کند که تیم‌های Agile اغلب با یک لیست طولانی و خطی از داستان‌ها (Flat Backlog) مواجه می‌شوند. این لیست خطی باعث می‌شود تیم، **«تصویر بزرگ» (The Big Picture)** پروژه را گم کند. یعنی تیم‌ها روی فیچرهای کوچک تمرکز می‌کنند بدون اینکه بدانند این قطعات چطور در کنار هم یک تجربه کاربری منسجم را می‌سازند.

**۴. راهکار جف پاتون:**
تکنیک *User Story Mapping* که در این کتاب معرفی می‌شود، دقیقاً برای حل همین مشکل است. این تکنیک به تیم کمک می‌کند تا از گم شدن در جزئیاتِ لیست‌های طولانی جلوگیری کند و ارتباط بین داستان‌ها و کل سیستم را ببیند.

---

## فصل ۱: تصویر بزرگ

### بخش ۱: کلمه "الف"

**معنای عملی Agile:**
اگر از کتاب‌های دیگر شروع کنی، احتمالاً با «مانیفست Agile» (Manifesto for Agile Software Development) سرو کار خواهی داشت که در سال ۲۰۰۱ توسط ۱۷ نفر نوشته شد. اما پاتون (نویسنده) در اینجا از ذکر دوباره مانیفست صرف‌نظر می‌کند و بجای آن یک نکته حیاتی را مطرح می‌کند:

**Agile فقط به معنای سرعت یا ساختار فنی نیست.** بلکه این یک فلسفه است که تمرکز را از **مستندات سنگین** به سمت **گفتگو و همفهمی مشترک** منتقل می‌کند.

**بازگشت به تاریخ:**
پاتون در سال ۲۰۰۰ در یک استارتاپ در سان‌فرانسیسکو کار می‌کرد، جایی که **کنت بک** (Kent Beck) به عنوان مشاور حضور داشت. کنت بک خالق **Extreme Programming (XP)** و معرف مفهوم User Story بود. مقدار کلیدی:

> **Stories نام خود را از نحوه استفاده آن‌ها می‌گیرند، نه از آنچه باید نوشته شود.**

این تفاوت بنیادی است. بسیاری تیم‌ها فکر می‌کنند User Story یعنی کاغذ یا تیکتی در Jira، اما حقیقتاً منظور **تعامل و گفتگو** است.

**مشکل دوران قدیم (Pre-Agile):**
روش سنتی مدیریت پروژه بر این اساس بود:
1. تحلیل‌گران نیازمندی‌ها را جمع‌آوری می‌کردند
2. آن‌ها را به صورت اسناد طولانی و تفصیلی می‌نوشتند
3. آن اسناد را به توسعه‌دهندگان می‌رساندند

**مشکل اصلی:** اسناد مکتوب **تفسیرهای مختلفی** را برای افراد مختلف ایجاد می‌کند. همین که صفحات و صفحات مستند بنویسی نمی‌توانی اطمینان داشته باشی که تمام افراد یک‌سان آن را درک کرده‌اند.

**تجربه شخصی پاتون:**
اولین بار که پاتون در یک پروژه Agile کار کرد، تنگناهایی را احساس کرد:
- یک User Story می‌نوشت که به اعتقادش می‌توانست در یک iteration انجام شود
- اما وقتی با توسعه‌دهندگان صحبت کرد، فهمید داستان **خیلی بزرگ** است
- این باعث ناامیدی او شد چون **تصویر بزرگ** را از دست داد

این مشکل تا به امروز جریان دارد: تیم‌ها در جزئیات گم می‌شوند و نمی‌دانند چگونه قطعات کوچک در کنار هم یک تجربه کاربری منسجم را می‌سازند.

**حل پاتون - Story Mapping:**
پاتون متوجه شد که ما نیاز داریم:
1. بر روی **تصویر بزرگ** تمرکز کنیم
2. سپس آن را به قطعات کوچک برای ساخت تقسیم کنیم

این دقیقاً آنچیزی است که User Story Mapping حل می‌کند.

**نتیجه‌گیری برای این بخش:**
سه نکته کلیدی:
1. **Agile به معنای سرعت در نوشتن نیست**؛ بلکه به معنای گفتگویی است که درک مشترک ایجاد می‌کند
2. **User Story ابزار برای گفتگو است، نه برای جابه‌جایی تیکت‌ها**
3. **مشکل پروژه‌های Agile امروزی** این است که تیم‌ها در فهرست‌های خطی و بدون معنی گم می‌شوند

---

### بخش ۲: روایت کردن داستان‌ها، نه نوشتن آن‌ها (Telling Stories, Not Writing Stories)

از این بخش به بعد، پاتون وارد عمق فلسفه User Story می‌شود. این بخش کوتاه اما بسیار حیاتی است.

**۱. چرا اسم این تکنیک "Story" است؟**
پاتون اعتراف می‌کند که در ابتدا با این واژه مخالف بود. او فکر می‌کرد که اگر نیازمندی‌های مهم را «داستان» بنامیم، آن‌ها را کوچک و بی‌اهمیت می‌کنیم. اما زمانی که به عمق این اصطلاح پی برد، درک کرد:

> **"Stories get their name from how they should be used, not what should be written."**
> (داستان‌ها نامشان را از نحوه استفاده گرفته‌اند، نه از آنچه باید نوشته شود.)

این نکته **کلیدی‌ترین** مفهوم در تمام کتاب است. بیشتر تیم‌ها فکر می‌کنند User Story یعنی یک «تمپلیت» است که باید بر اساس آن، یک مستند خوب بنویسند. اما واقعیت این است: **User Story یعنی روایت شفاهی (Oral Storytelling)** که باید در گفتگو اتفاق بیفتد.

**۲. چالش اولیه پاتون:**
پاتون توضیح می‌دهد که در اولین پروژه Agile خود، از index card ها استفاده کرد و نیازمندی‌ها را روی آن‌ها نوشت. او می‌توانست آن‌ها را جابه‌جا کند، اولویت‌بندی کند و سپس با تیم صحبت کند. این مفهوم **فوق‌العاده قدرتمند** بود چون کارت‌ها قابل چیدمان و مرتب‌سازی بودند.

اما مشکل اینجا بود:
- یک کارت ممکن بود کاری باشد که ۲ ساعت زمان می‌برد یا ممکن بود **۱ ماه** طول بکشد
- تا زمانی که با تیم صحبت نمی‌کرد، نمی‌دانست که حجم دقیق کار چقدر است

**۳. تجربه منفی اول:**
> "I got into a nasty argument..."

پاتون با تیم مشاجره کرد چون Story او خیلی بزرگ بود و نمی‌شد در یک iteration تمام کرد. توسعه‌دهندگان گفتند فقط بخش کوچکی از آن را می‌توانند تحویل دهند. پاتون احساس ناکامی کرد چون:
- او می‌خواست **تصویر بزرگ** را ببیند
- اما فرآیند Agile او را مجبور می‌کرد فقط روی **یک قطعه کوچک** تمرکز کند

این همان **فاجعه Flat Backlog** است که در بخش بعدی توضیح خواهد داد.

### بخش ۳: روایت کردن کل داستان (Telling the Whole Story)

**۱. راهکار پاتون - سال ۲۰۰۱:**
پاتون تصمیم گرفت رویکرد دیگری را امتحان کند. او و تیمش شروع کردند به:
- تمرکز بر **تصویر بزرگ محصول**
- استفاده از کارت‌ها برای سازماندهی افکار و تجزیه کارهای بزرگ به قطعات کوچک

در سال ۲۰۰۴، او اولین مقاله خود را در این باره نوشت، اما تا سال ۲۰۰۷ نام **Story Mapping** را برای این تکنیک انتخاب نکرد. و بعد از آن، این تکنیک به سرعت منتشر شد.

**۲. کشف الگو (Pattern Discovery):**
پاتون فکر می‌کرد این یک «اختراع» شخصی اوست، اما زمانی که با دیگران صحبت کرد، متوجه شد که افراد زیادی کارهای مشابهی انجام می‌دهند. او این تعریف از الگو (Pattern) را از لیندا رایزینگ (Linda Rising) نقل می‌کند:

> **"When you tell someone about a great idea and he says, 'Yeah, we do something like that, too.' It's not an invention, it's a pattern."**
> (وقتی ایده خودت را به کسی می‌گویی و او می‌گوید «آره، ما هم کاری شبیه این می‌کنیم»، آن دیگر یک اختراع نیست، بلکه یک الگو است.)

**۳. نقل‌قول از مارتینا از SAP:**
در سال ۲۰۱۳، مارتینا، یکی از کارشناسان SAP، به پاتون گفت:
> "...at this point more than 120 USM [User Story Mapping] workshops have officially been recorded. A lot of POs just simply love it! It is simply a well-established approach at SAP."

این نشان می‌دهد که Story Mapping در سازمان‌های بزرگ مانند SAP به صورت گسترده پذیرفته شده است.

**۴. جمع‌بندی این بخش:**
> **"Story maps are for breaking down big stories as you tell them."**

Story Map ابزاری است که:
- به شما کمک می‌کند **تصویر بزرگ** را ببینید
- داستان‌های بزرگ را به قطعات کوچک تقسیم کنید
- **درحین روایت** این کار را انجام دهید (نه قبل یا بعد از آن)

**تحلیل منتورینگ:**
این دو بخش پایه‌گذار فلسفه Story Mapping هستند. نکات کلیدی:

1. **User Story یک مستند نیست**: بسیاری از تیم‌ها به اشتباه فکر می‌کنند User Story یک تمپلیت است که باید با دقت پر شود. این تصور کاملاً اشتباه است. Story یعنی **گفتگو**.

2. **تصویر بزرگ گم می‌شود**: وقتی شما صرفاً یک لیست خطی از Story ها دارید (Flat Backlog)، نمی‌دانید که این قطعات چگونه در کنار هم یک محصول منسجم می‌سازند. این دقیقاً چیزی است که تیم‌های Agile با آن دست‌وپنجه نرم می‌کنند.

3. **Story Mapping یک Pattern است**: این تکنیک، راهی طبیعی برای سازماندهی افکار و دیدن تصویر بزرگ است. اگر شما هم با این مشکل مواجه بوده‌اید، نشان می‌دهد که شما نیز به طور ناخودآگاه به دنبال چنین الگویی بوده‌اید.

---

### فصل ۱: تصویر بزرگ (The Big Picture)

#### بخش: گری و تراژدی بک‌لاگ تخت (Gary and the Tragedy of the Flat Backlog)

این بخش با یک داستان واقعی و بسیار آموزنده شروع می‌شود. **گری (Gary)** یک موزیسین است که ایده ساخت یک محصول نرم‌افزاری به نام **Mad Mimi** را دارد (یک سرویس ایمیل مارکتینگ برای موزیسین‌ها).

**۱. مشکل گری چه بود؟**
گری با یک تیم توسعه Agile کار می‌کرد. تیم به او گفت:
> "Write down a list of all the things you want, prioritize the list, and then we'll start building them one at a time."
> (لیستی از تمام چیزهایی که می‌خواهی بنویس، اولویت‌بندی کن، و ما یکی‌یکی آن‌ها را می‌سازیم.)

گری دقیقاً همین کار را کرد. او یک **Flat Backlog** (لیست تخت و طولانی) ساخت و تیم شروع به کار کرد.
اما نتیجه فاجعه‌بار بود:
- گری در حال از دست دادن پول زیادی بود.
- نرم‌افزار داشت تکه‌تکه ساخته می‌شد، اما هیچ شباهتی به چشم‌انداز (Vision) او نداشت.
- گری نگران بود که قبل از اینکه محصول قابل استفاده شود، بودجه‌اش تمام شود.

**نکته منتورینگ:**
این سناریو برای بسیاری از Product Ownerها آشناست. وقتی بک‌لاگ شما فقط یک لیست خطی است، **ارتباط منطقی** بین فیچرها گم می‌شود. تیم فقط "تیکت‌ها" را می‌بندد بدون اینکه بداند این تیکت‌ها چطور به هم وصل می‌شوند.

#### بخش: صحبت کن و مستند کن (Talk and Doc)

پاتون برای نجات پروژه وارد می‌شود. او با گری ملاقات می‌کند و یک تکنیک ساده اما حیاتی را اجرا می‌کند: **Talk and Doc**.

**۱. تکنیک Talk and Doc:**
> "Don't let your words vaporize. Write them down on cards so you can refer back to them later."
> (اجازه نده کلماتت تبخیر شوند. آن‌ها را روی کارت بنویس تا بتوانی بعداً به آن‌ها رجوع کنی.)

هر بار که گری ایده‌ای را توضیح می‌داد، پاتون آن را روی یک کارت یا استیکی نوت می‌نوشت و روی میز (و بعداً روی زمین) می‌چید.

**۲. قدرت بصری‌سازی (Visualization):**
- وقتی کلمات روی کارت نوشته می‌شوند، می‌توانید به آن‌ها اشاره کنید (Pointing).
- می‌توانید آن‌ها را جابه‌جا کنید و گروه‌بندی کنید.
- این کار باعث می‌شود **Shared Understanding** (درک مشترک) شکل بگیرد.

**۳. فرآیند Think-Write-Explain-Place:**
پاتون یک چرخه ۴ مرحله‌ای برای جلسات پیشنهاد می‌کند:
1. **Think:** ایده را در ذهن داشته باش.
2. **Write:** قبل از گفتن، آن را روی کارت بنویس.
3. **Explain:** کارت را به دیگران نشان بده و توضیح بده.
4. **Place:** کارت را در جای مناسب روی نقشه یا دیوار قرار بده.

این روش باعث می‌شود که ایده‌ها گم نشوند و همه روی یک موضوع متمرکز باشند.

**نتیجه‌گیری این بخش:**
گری یاد گرفت که نوشتن لیست اولویت‌بندی شده (Backlog) کافی نیست. او نیاز داشت داستان کاربر را از ابتدا تا انتها **ببیند** و درک کند که کدام قطعات برای نسخه اول (MVP) حیاتی هستند.

---

### فصل ۱: تصویر بزرگ (ادامه)

#### بخش: ایده خود را قاب‌بندی کنید (Frame Your Idea)

پس از اینکه پاتون با تکنیک **Talk and Doc** کارت‌ها را نوشت، اولین مکالمه جدی آن‌ها درباره «قاب‌بندی» ایده بود.

**چرا قاب‌بندی مهم است؟**
بسیاری از افراد مستقیماً سراغ لیست ویژگی‌ها (Features) می‌روند. اما پاتون یک گام به عقب برداشت و سوالات بنیادی پرسید:
1. **Why are you building this?** (چرا اصلاً دارید این را می‌سازید؟)
2. **Who is it for?** (برای چه کسی است؟)
3. **What problems does it solve?** (چه مشکلاتی را حل می‌کند؟)

**مدل Now and Later:**
پاتون در اینجا به مدلی اشاره می‌کند که در بخش‌های قبل توضیح داده بود:
- ما باید روی **Outcomes** (نتایج) تمرکز کنیم، نه **Output** (خروجی کار/کد).
- اگر دو کارت را روی هم بگذاریم، کارتی که بالاتر است، مهم‌تر دیده می‌شود. پاتون از این ویژگی بصری برای اولویت‌بندی اهداف گری استفاده کرد.

**نکته منتورینگ:**
به عنوان یک توسعه‌دهنده ارشد، وقتی Product Owner با لیستی از فیچرها می‌آید، اولین سوال شما باید این باشد: *"هدف بیزنس از این فیچر چیست؟"* اگر نتوانند پاسخ دهند، یعنی ایده هنوز به درستی Frame نشده است.

#### بخش: مشتریان و کاربران خود را توصیف کنید (Describe Your Customers and Users)

بعد از تعیین اهداف، نوبت به شناسایی «انسان‌ها» می‌رسد.

**۱. تفاوت مشتری (Customer) و کاربر (User):**
- **مشتری:** کسی که پول می‌دهد و محصول را می‌خرد.
- **کاربر:** کسی که واقعاً با نرم‌افزار کار می‌کند.
(گاهی این دو یکی هستند، گاهی متفاوت).

**۲. ساختن تپه کارت‌ها (The Pile):**
پاتون و گری شروع کردند به نوشتن انواع مختلف کاربران روی کارت‌ها. طبیعتاً، کاربران مهم‌تر در بالای توده کارت‌ها قرار گرفتند.

**۳. سوال طلایی پاتون:**
> **"If we were to focus on thrilling just one of those users, who would it be?"**
> (اگر بخواهیم فقط **یک** نفر از این کاربران را شگفت‌زده کنیم، آن یک نفر کیست؟)

این سوال حیاتی است چون در توسعه نرم‌افزار همیشه وقت و بودجه محدود است. نمی‌توان همه را راضی کرد. باید بدانیم **Core User** (کاربر اصلی) کیست.

**مثال گری (Mad Mimi):**
کاربران شناسایی شده شامل موارد زیر بودند:
- **Band Manager (مدیر گروه موسیقی):** کاربر اصلی. کسی که می‌خواهد ایمیل‌ها را بفرستد.
- **The Fan (طرفدار):** کسی که ایمیل را دریافت می‌کند.
- **Venue Manager (مدیر سالن کنسرت):** کسی که اطلاعات کنسرت را نیاز دارد.

#### بخش: داستان کاربران خود را بگویید (Tell Your Users' Stories)

حالا که کاربر اصلی مشخص شد (Band Manager)، نوبت به روایت داستان او می‌رسد.

**۱. جریان داستان (Flow):**
پاتون گفت: *"بیایید فرض کنیم آینده است و سیستم ساخته شده. یک روز از زندگی این کاربر را برای من تعریف کن."*
آن‌ها داستان را **از چپ به راست** چیدند.
- **چپ به راست:** نشان‌دهنده **زمان** (Time/Sequence) است. اول این کار را می‌کند، بعد آن کار را.

**۲. جادوی بصری:**
> **"Reorganizing cards together allows you to communicate without saying a word."**
> (جابه‌جا کردن کارت‌ها به شما اجازه می‌دهد بدون حرف زدن، ارتباط برقرار کنید.)

وقتی کارتی را سمت چپ دیگری می‌گذارید، یعنی "این زودتر اتفاق می‌افتد". این زبان مشترک بصری است.

**۳. کشف حفره‌ها (Spotting Holes):**
وقتی گری شروع به تعریف داستان کرد، متوجه شد که بخش‌های زیادی را فراموش کرده است!
> **"Mapping your story helps you find holes in your thinking."**

مثلاً داستان فقط درباره ارسال ایمیل نبود؛ بلکه درباره این بود که وقتی طرفدار (Fan) ایمیل را می‌گیرد چه می‌کند؟ یا مدیر سالن کنسرت چه واکنشی نشان می‌دهد؟
این باعث شد نقشه بزرگتر شود و لایه‌های جدیدی به آن اضافه شود.

**۴. عمق در برابر سطح (Breadth vs. Depth):**
یک قانون مهم در Story Mapping:
> **"Think mile wide, inch deep."**
> (یک مایل پهنا، یک اینچ عمق.)

یعنی اول **کل داستان را تا آخر** برو (Breadth)، قبل از اینکه در جزئیات فنی یک قسمت خاص غرق شوی (Depth).
گری داشت در جزئیات طراحی گرافیکی ایمیل‌ها گم می‌شد، اما پاتون او را متوقف کرد و گفت: *"بیاییم اول به آخر داستان برسیم، بعداً برمی‌گردیم و جزئیات را پر می‌کنیم."*

**جمع‌بندی این بخش:**
تا اینجا یاد گرفتیم:
1. ایده را با "چرا" و "برای چه کسی" قاب‌بندی کنیم.
2. کاربر اصلی را انتخاب کنیم.
3. داستان او را در طول زمان (چپ به راست) بچینیم.
4. اول پهنای داستان (کل ماجرا) را تمام کنیم، بعد وارد جزئیات شویم.

---

### فصل ۱: تصویر بزرگ (ادامه)

#### بخش: جزئیات و گزینه‌ها را کاوش کنید (Explore Details and Options)

در این بخش، پاتون به چالش بعدی گری و تیمش می‌پردازد: **مدیریت جزئیات**.
وقتی داستان‌های بزرگ را تعریف کردید (مثل "خرید بلیط کنسرت" یا "ارسال ایمیل به طرفداران")، هنوز کار تمام نشده است. این داستان‌ها خیلی بزرگ‌تر از آن هستند که بتوان آن‌ها را ساخت.

**۱. شکستن داستان‌های بزرگ (Breaking Down Stories):**
پاتون توضیح می‌دهد که داستان‌های سطح بالا (که به آن‌ها **Epic** یا **Activity** هم می‌گویند) باید به مراحل کوچکتر شکسته شوند. اما نکته مهم این است که این مراحل نباید صرفاً "تسک‌های فنی" باشند.
- **اشتباه رایج:** تبدیل داستان به تسک‌هایی مثل "طراحی دیتابیس"، "ساخت API"، "ساخت UI".
- **روش درست:** شکستن به مراحل کوچک‌تری از تجربه کاربر.

**۲. گزینه‌ها و تنوع (Variations):**
برای هر مرحله از داستان کاربر، ممکن است چندین راه برای انجام آن وجود داشته باشد.
مثلاً اگر مرحله "پرداخت هزینه" است، گزینه‌ها می‌توانند این‌ها باشند:
- پرداخت با کارت اعتباری
- پرداخت با PayPal
- پرداخت با بیت‌کوین

پاتون این گزینه‌ها را به صورت **عمودی** زیر هر مرحله قرار می‌دهد.
- **محور افقی (چپ به راست):** روایت داستان در طول زمان (Narrative Flow).
- **محور عمودی (بالا به پایین):** جزئیات، گزینه‌ها و جایگزین‌ها.

**۳. اولویت‌بندی در محور عمودی:**
این بخش بسیار حیاتی است. در محور عمودی، کارت‌هایی که بالاتر هستند، **ضروری‌تر** هستند.
- کارت‌های بالا: کارهایی که "باید" انجام شوند تا سیستم اصلاً کار کند (MVP).
- کارت‌های پایین: کارهایی که خوب است داشته باشیم (Nice to have) یا برای نسخه‌های بعدی هستند.

این ساختار شبکه‌ای (Grid) دقیقاً همان چیزی است که به آن **Story Map** می‌گویند.

**۴. مثال "مشاهده اطلاعات فیلم" (View Movie Info):**
پاتون مثالی می‌زند که چطور می‌توان یک داستان ساده مثل "دیدن اطلاعات فیلم" را به سطوح مختلف کیفیت تقسیم کرد:
- **نسخه پایه (Good Enough):** فقط نام فیلم و خلاصه داستان.
- **نسخه بهتر (Better):** اضافه کردن امتیاز منتقدان و لیست بازیگران.
- **نسخه عالی (Best/Fabulous):** تریلر فیلم، اخبار مرتبط، بحث‌های کاربران.

این تفکر به تیم اجازه می‌دهد که به جای اینکه ماه‌ها روی "کامل‌ترین نسخه" کار کنند، ابتدا یک نسخه پایه و کارا را بسازند و سپس آن را بهبود دهند.

**نتیجه‌گیری فصل اول:**
فصل اول با این پیام تمام می‌شود که Story Map فقط یک ابزار بصری نیست؛ بلکه ابزاری برای:
1. ایجاد **درک مشترک** (Shared Understanding).
2. دیدن **تصویر بزرگ** (Big Picture).
3. **اولویت‌بندی هوشمندانه** بر اساس تجربه کاربر، نه فقط لیست فیچرها.

---

### فصل ۲: برنامه‌ریزی برای ساختن کمتر (Plan to Build Less)

این فصل یکی از مهم‌ترین مفاهیم Agile مدرن را آموزش می‌دهد: **هنر کم کردن کارها**.
عنوان فصل کمی عجیب به نظر می‌رسد، چون معمولاً مدیران می‌خواهند "بیشتر" بسازند. اما پاتون استدلال می‌کند که "بیشتر" همیشه بهتر نیست.

#### بخش: نقشه‌کشی به گروه‌های بزرگ کمک می‌کند درک مشترک بسازند (Mapping Helps Big Groups Build Shared Understanding)

**۱. مشکل گروه‌های بزرگ:**
وقتی تعداد افراد تیم زیاد می‌شود (مثلاً ۲۰-۳۰ نفر)، "درک مشترک" سخت‌تر می‌شود.
پاتون مثالی از شرکت **Globo.com** (بزرگترین شرکت رسانه‌ای برزیل) می‌زند. آن‌ها می‌خواستند سیستم مدیریت محتوای (CMS) قدیمی خود را با یک سیستم جدید جایگزین کنند.
- ۳۰ نفر درگیر پروژه بودند.
- هیچکس نمی‌دانست دقیقاً چه چیزی باید ساخته شود.
- همه نگران بودند.

**۲. راه‌حل کارگاهی (Workshop Solution):**
پاتون همه ۳۰ نفر را در یک اتاق جمع کرد و از آن‌ها خواست یک Story Map بسازند.
- آن‌ها دیوارها را با کارت پوشاندند.
- هر کس دانش خود را به نقشه اضافه کرد.
- نتیجه: یک نقشه عظیم (Big Wall of Stickies) که نشان می‌داد سیستم چقدر پیچیده است.

**نکته کلیدی:**
> **"It wasn't the map on the wall that was important. It was what happened in their heads."**
> (نقشه روی دیوار مهم نبود. آنچه در ذهن آن‌ها اتفاق افتاد مهم بود.)

این فرآیند باعث شد که همه افراد (توسعه‌دهنده، طراح، مدیر محصول) بفهمند که پروژه چقدر بزرگ است و چه بخش‌هایی را نادیده گرفته بودند.

#### بخش: نقشه‌کشی کمک می‌کند حفره‌ها را پیدا کنید (Mapping Helps You Spot Holes in Your Story)

**۱. مثال Mad Mimi:**
برمی‌گردیم به گری و Mad Mimi. وقتی گری داستان کاربر را روی دیوار چید، متوجه شد که یک بخش مهم را فراموش کرده:
- او روی "ارسال ایمیل" تمرکز کرده بود.
- اما فراموش کرده بود که "وقتی کاربر پسوردش را گم می‌کند چه می‌شود؟"
- یا "وقتی ایمیل به دست طرفدار می‌رسد و او روی لینک کلیک می‌کند، چه اتفاقی می‌افتد؟"

**۲. دیدن نادیده‌ها:**
نقشه به شما اجازه می‌دهد **جریان (Flow)** را ببینید. اگر بین دو کارت فاصله‌ای باشد که منطقی نیست، فوراً می‌فهمید که یک مرحله (Step) گم شده است.
- در لیست خطی (Backlog)، پیدا کردن این حفره‌ها تقریباً غیرممکن است.
- در نقشه دوبعدی، حفره‌ها فریاد می‌زنند!

#### بخش: همیشه کار زیاد است (There’s Always Too Much)

این بخش واقعیت تلخ مهندسی نرم‌افزار است:
> **"There’s always more to build than we have time or money for."**
> (همیشه بیشتر از زمان و پولی که داریم، چیز برای ساختن هست.)

**۱. توهم کامل بودن:**
بسیاری از تیم‌ها سعی می‌کنند "همه چیز" را بسازند. اما پاتون می‌گوید این غیرممکن و اشتباه است.
شما باید یاد بگیرید که **"نه"** بگویید. اما به چه چیزی نه بگوییم؟

**۲. برش زدن (Slicing):**
اینجا مفهوم **Release Slicing** معرفی می‌شود.
شما نباید فیچرها را یکی‌یکی اولویت‌بندی کنید. بلکه باید **برش‌هایی افقی** روی نقشه بزنید.

- **برش اول (MVP):** حداقل چیزی که محصول را زنده نگه می‌دارد.
- **برش دوم:** فیچرهایی که تجربه را بهتر می‌کنند.
- **برش سوم:** چیزهای لوکس و اضافی.

در تصویر ذهنی: یک خط افقی روی نقشه بکشید. هر چیزی بالای خط است در Release 1 می‌رود. هر چیزی پایین خط است به بعد موکول می‌شود.

**جمع‌بندی این بخش:**
تا اینجا یاد گرفتیم:
1. Story Mapping ابزاری برای همسو کردن تیم‌های بزرگ است.
2. نقشه کمک می‌کند کارهای فراموش شده (Holes) را پیدا کنید.
3. همیشه کار زیاد است، پس باید یاد بگیرید که نقشه را به صورت افقی **برش (Slice)** بزنید تا نسخه‌های قابل انتشار (Releases) را تعریف کنید.

---

### فصل ۲: برنامه‌ریزی برای ساختن کمتر (ادامه)

در ادامه مفهوم "برش زدن" (Slicing)، پاتون به چالش‌های پیاده‌سازی این مفهوم و سوءتفاهم‌های رایج درباره MVP می‌پردازد.

#### بخش: برش زدن برای انتشار MVP (Slice Out a Minimum Viable Product Release)

**مثال Globo.com:**
تیم‌های Globo با یک ضرب‌الاجل غیرقابل تغییر روبرو بودند: **انتخابات برزیل**.
آن‌ها نمی‌توانستند تاریخ انتخابات را عقب بیندازند! بنابراین باید تصمیم می‌گرفتند چه چیزی را بسازند و چه چیزی را نسازند.

**۱. استراتژی برش زدن:**
آن‌ها از نوار چسب آبی رنگ استفاده کردند و یک خط افقی روی نقشه کشیدند.
- **بالای خط:** کارهایی که "باید" برای انتخابات آماده باشد (مثلاً نمایش نتایج زنده، اخبار فوری).
- **پایین خط:** کارهایی که می‌توانند بعداً اضافه شوند (مثلاً آرشیو اخبار قدیمی، پروفایل‌های پیچیده کاربری).

**۲. تمرکز بر Outcome:**
نکته مهم این است که آن‌ها فیچرها را بر اساس "راحتی توسعه" انتخاب نکردند. آن‌ها بر اساس **نتیجه (Outcome)** انتخاب کردند:
> "We need to make a splash during the election."
> (ما باید در طول انتخابات سر و صدا کنیم.)

هر فیچری که به این هدف کمک می‌کرد، در برش اول قرار گرفت.

#### بخش: برش زدن نقشه راه انتشار (Slice Out a Release Roadmap)

بعد از تعیین اولین برش (MVP)، آن‌ها خط‌های افقی بیشتری کشیدند تا ریلیزهای بعدی را مشخص کنند.
این ساختار به یک **Release Roadmap** تبدیل شد.

**تفاوت با Roadmap سنتی:**
- در روش سنتی، Roadmap لیستی از فیچرها و تاریخ‌هاست (Feature List).
- در Story Mapping، نقشه راه لیستی از **Outcomes** (نتایج کسب‌وکار) است.
  - ریلیز ۱: پوشش انتخابات (هدف: جذب ترافیک بالا).
  - ریلیز ۲: بهبود تعامل کاربران (هدف: افزایش زمان ماندن در سایت).
  - ریلیز ۳: ابزارهای شخصی‌سازی (هدف: وفاداری کاربران).

#### بخش: فیچرها را اولویت‌بندی نکنید، نتایج را اولویت‌بندی کنید (Don’t Prioritize Features—Prioritize Outcomes)

این بخش یکی از عمیق‌ترین مفاهیم کتاب است.
پاتون می‌گوید:
> **"Focus on outcomes—what users need to do and see when the system comes out."**

**Output vs. Outcome:**
- **Output (خروجی):** کدی که می‌نویسید، فیچری که شیپ می‌کنید (مثلاً دکمه "لایک").
- **Outcome (نتیجه):** تغییری که در رفتار کاربر ایجاد می‌شود (مثلاً کاربران بیشتر با محتوا تعامل می‌کنند).
- **Impact (تأثیر):** نتیجه نهایی برای بیزنس (مثلاً درآمد بیشتر).

شما نباید بگویید "اول دکمه لایک را می‌سازیم". باید بگویید "اول تعامل کاربر را افزایش می‌دهیم". این تغییر دیدگاه باعث می‌شود شاید اصلاً دکمه لایک نسازید و راه بهتری پیدا کنید!

#### بخش: چرا اینقدر درباره MVP بحث می‌کنیم؟ (Why We Argue So Much About MVP)

پاتون به آشفتگی مفهوم MVP در صنعت اشاره می‌کند. هر کس تعریف متفاوتی دارد.
او سه تعریف ارائه می‌دهد: یک تعریف بد و دو تعریف خوب.

**۱. تعریف بد (The Bad Definition):**
> "MVP is not the crappiest product you could possibly release."
> (MVP به معنای مزخرف‌ترین محصولی که می‌توانید منتشر کنید نیست.)
بسیاری از شرکت‌ها به بهانه MVP، محصولی ناقص، پر از باگ و زشت به کاربران می‌دهند و می‌گویند "این MVP است". این کار برند شما را نابود می‌کند.

**۲. تعریف خوب اول (The Good Definition 1):**
> "The minimum viable product is the smallest product release that successfully achieves its desired outcomes."
> (MVP کوچکترین انتشاری است که با موفقیت به نتایج دلخواه می‌رسد.)
کلمه "Viable" (حیاتی/قابل زیست) یعنی محصول باید بتواند زنده بماند و کارش را انجام دهد.

**۳. تعریف خوب دوم (The Good Definition 2 - Lean Startup Style):**
این تعریف از اریک رایز (Eric Ries) می‌آید:
> "A minimal viable product is also the smallest thing you could create or do to prove or disprove an assumption."
> (MVP کوچکترین چیزی است که می‌توانید بسازید تا یک فرضیه را ثابت یا رد کنید.)

در این تعریف، MVP ممکن است اصلاً یک محصول کامل نباشد! ممکن است یک Landing Page باشد، یا یک پروتوتایپ کاغذی. هدفش **یادگیری (Learning)** است، نه فروش.

**نکته منتورینگ:**
به عنوان یک توسعه‌دهنده ارشد، باید بدانید که در چه فازی هستید:
- آیا در فاز **Learning** هستید؟ (پس کد کثیف هم مشکلی ندارد، چون هدف یادگیری است).
- یا در فاز **Earning** هستید؟ (پس محصول باید با کیفیت و Viable باشد).
خلط کردن این دو فاز باعث می‌شود کد "دور انداختنی" (Throwaway Code) وارد پروداکشن شود و بدهی فنی (Technical Debt) ایجاد کند.

**جمع‌بندی فصل دوم:**
ما یاد گرفتیم که:
1. نقشه را افقی برش بزنیم تا ریلیزها مشخص شوند.
2. هر ریلیز باید یک **Outcome** مشخص داشته باشد.
3. MVP به معنای محصول ناقص نیست، بلکه کوچکترین محصولی است که هدف را محقق می‌کند یا چیزی به ما یاد می‌دهد.

---

### فصل ۳: برنامه‌ریزی برای یادگیری سریع‌تر (Plan to Learn Faster)

تا اینجا یاد گرفتیم که چطور ایده را به یک نقشه تبدیل کنیم و آن را برای انتشار برش بزنیم. اما سوال حیاتی این است: **آیا اصلاً ایده ما درست است؟**

این فصل درباره **Discovery (کشف)** است. درباره اینکه چطور قبل از اینکه کدی بنویسیم، بفهمیم چه چیزی را باید بسازیم.

#### بخش: شروع با بحث درباره فرصت (Start by Discussing Your Opportunity)

**۱. داستان اریک (Eric) و لیکوئیدنت:**
پاتون مثالی از اریک، یک Product Owner در شرکت مالی Liquidnet می‌زند. اریک ایده‌ای از سمت مدیریت دریافت کرد، اما به جای اینکه فوراً شروع به ساختن بک‌لاگ کند، کار دیگری کرد.
او ایده را به عنوان یک **فرصت (Opportunity)** دید، نه یک **دستور (Order)**.

**۲. سوالات حیاتی قبل از شروع:**
اریک با مدیران و ذینفعان جلسه گذاشت و این سوالات را پرسید:
- ایده بزرگ چیست؟
- مشتریان و کاربران کی هستند؟
- چرا آن‌ها این را می‌خواهند؟ (مشکلشان چیست؟)
- **چرا ما این را می‌سازیم؟** (اگر این موفق شود، چه سودی برای شرکت دارد؟)

**نکته منتورینگ:**
بسیاری از تیم‌های فنی فقط می‌پرسند *"چه بسازیم؟"* (What). اما تیم‌های حرفه‌ای می‌پرسند *"چرا بسازیم؟"* (Why). اگر ندانید "چرا"، نمی‌توانید راه حل درستی ارائه دهید.

#### بخش: اعتبارسنجی مشکل (Validate the Problem)

**۱. فرضیه (Hypothesis):**
اریک می‌دانست که ایده مدیران، فقط یک **فرضیه** است. ممکن است اشتباه باشد.
> "Validate that the problems you're solving really exist."
> (اعتبارسنجی کنید که مشکلاتی که حل می‌کنید، واقعاً وجود دارند.)

**۲. صحبت با کاربران واقعی:**
اریک با مشتریان صحبت کرد. او فهمید که برخی از مشکلاتی که فکر می‌کردند وجود دارد، اصلاً برای کاربران مهم نیست! و برعکس، مشکلات دیگری وجود دارد که آن‌ها ندیده بودند.
اگر اریک مستقیماً شروع به کدنویسی کرده بود، محصولی می‌ساخت که هیچ کس نمی‌خواست.

#### بخش: پروتوتایپ برای یادگیری (Prototype to Learn)

**۱. نساختن نرم‌افزار (Not Building Software):**
اریک برای تست راه‌حل، کد نزد. او از **Prototype** استفاده کرد.
- اسکچ‌های ساده روی کاغذ.
- وایرفریم‌های ساده با ابزارهایی مثل Axure یا حتی پاورپوینت.

**۲. تفاوت ساختن برای یادگیری و ساختن برای انتشار:**
> "Build to learn" vs "Build to earn"
هدف پروتوتایپ این است که چیزی را به کاربر نشان دهید تا بازخورد بگیرید. این کد نیست که قرار باشد در پروداکشن کار کند.

#### بخش: مراقب باشید مردم چه می‌گویند (Watch Out for What People Say They Want)

این یک دام کلاسیک است. کاربران اغلب می‌گویند "من فیچر X را می‌خواهم"، اما وقتی آن را می‌سازید، از آن استفاده نمی‌کنند.
**چرا؟** چون کاربران در پیش‌بینی رفتار آینده خودشان بد هستند.
به همین دلیل است که باید **رفتار** آن‌ها را با پروتوتایپ تست کنید، نه فقط **نظرات** آن‌ها را بپرسید.

#### بخش: ساختن برای یادگیری (Build to Learn)

گاهی اوقات پروتوتایپ کافی نیست و باید واقعاً چیزی بسازید تا تست کنید. اما این "ساختن" با ساختن نهایی فرق دارد.
- این کد ممکن است دور ریخته شود.
- هدفش فقط جمع‌آوری دیتا است (مثلاً یک دکمه که پشتش هیچ منطقی نیست، فقط می‌خواهیم ببینیم چند نفر رویش کلیک می‌کنند).

**مفهوم Validated Learning:**
این اصطلاح از کتاب "Lean Startup" می‌آید. یعنی یادگیری که با داده‌های واقعی تأیید شده باشد، نه فقط حدس و گمان.

**جمع‌بندی فصل سوم:**
پیام این فصل برای تیم‌های فنی بسیار مهم است:
**کدنویسی گران‌ترین راه برای تست یک ایده است.**
قبل از اینکه تیم توسعه را درگیر کدنویسی سنگین کنید، باید با روش‌های ارزان‌تر (گفتگو، اسکچ، پروتوتایپ) مطمئن شوید که ایده درست است.

---

### فصل ۴: برنامه‌ریزی برای اتمام به‌موقع (Plan to Finish on Time)

در این فصل، پاتون به جنبه‌های اجرایی و مدیریتی پروژه می‌پردازد. چطور مطمئن شویم که چیزی که نقشه‌کشی کردیم، واقعاً در زمان و بودجه مشخص تحویل داده می‌شود؟

#### بخش: آن را برای تیم بگویید (Tell It to the Team)

**داستان آرون (Aaron) و مایک (Mike):**
آرون و مایک در شرکت Workiva کار می‌کنند. آن‌ها با استفاده از پروتوتایپ‌های سریع (در Axure)، ایده خود را اعتبارسنجی کردند. حالا نوبت انتقال این دانش به تیم توسعه است.

**۱. نقشه را به عنوان ابزار داستان‌گویی استفاده کنید:**
آن‌ها اسکرین‌شات‌های پروتوتایپ را روی نقشه چسباندند. وقتی داشتند داستان کاربر را برای تیم تعریف می‌کردند، به اسکرین‌شات‌ها اشاره می‌کردند.
> "Map only what you need to support your conversation."
(فقط چیزی را نقشه کنید که برای حمایت از گفتگو نیاز دارید.)

**۲. مشارکت تیم:**
وقتی تیم توسعه داستان را شنید، سوالاتی پرسید که مایک (Product Owner) به آن‌ها فکر نکرده بود:
- "وقتی این دکمه زده می‌شود دقیقاً چه اتفاقی می‌افتد؟"
- "وابستگی‌های فنی این بخش چیست؟"

این باعث شد تیم حس مالکیت (Ownership) پیدا کند و باگ‌های منطقی را قبل از کدنویسی پیدا کنند.

#### بخش: راز تخمین خوب (The Secret to Good Estimation)

این بخش یکی از حقایق تلخ و شیرین مهندسی نرم‌افزار است.

**۱. راز بزرگ:**
> **"The best estimates come from developers who really understand what they're estimating."**
> (بهترین تخمین‌ها از توسعه‌دهندگانی می‌آید که واقعاً می‌فهمند چه چیزی را دارند تخمین می‌زنند.)

هیچ متدولوژی جادویی (مثل Planning Poker یا Fibonacci) نمی‌تواند عدم درک را جبران کند. اگر توسعه‌دهنده نفهمد "چرا" و "چطور"، تخمین او پرت خواهد بود.

**۲. درک مشترک = تخمین دقیق‌تر:**
وقتی شما با Story Map داستان را کامل روایت می‌کنید و تیم "تصویر بزرگ" را می‌بیند، آن‌ها می‌توانند پیچیدگی‌های پنهان را شناسایی کنند.

#### بخش: برنامه‌ریزی برای ساختن قطعه‌به‌قطعه (Plan to Build Piece by Piece)

**۱. استراتژی بازی (Game Strategy):**
پاتون ساخت نرم‌افزار را به سه مرحله تشبیه می‌کند (مثل شطرنج):
- **Opening Game (شروع بازی):** ساختن زیرساخت‌های حیاتی و ریسکی‌ترین بخش‌ها.
- **Mid Game (میانه بازی):** پر کردن فیچرهای اصلی و گوشت و پوست محصول.
- **End Game (پایان بازی):** تمیزکاری، بهبود UI، رفع باگ‌ها و آماده‌سازی برای انتشار.

**۲. برش‌های توسعه (Development Slices):**
شما نباید فیچرها را تصادفی بسازید. باید بر اساس ریسک و ارزش بسازید.
- اول: چیزی که ثابت می‌کند معماری کار می‌کند (Walking Skeleton).
- دوم: چیزی که تجربه کاربری اصلی را کامل می‌کند.
- سوم: چیزهایی که آن را زیبا می‌کنند.

#### بخش: هر برش را منتشر نکنید (Don’t Release Each Slice)

این یک نکته ظریف است.
- **Development Strategy:** برش‌هایی که تیم توسعه می‌سازد (مثلاً هر ۲ هفته).
- **Release Strategy:** برش‌هایی که به مشتری تحویل داده می‌شود (مثلاً هر ۳ ماه).

لازم نیست هر چیزی که تیم می‌سازد فوراً به دست مشتری برسد. شما می‌توانید "توسعه تکرارشی" (Iterative Development) داشته باشید اما "انتشار افزایشی" (Incremental Release) انجام دهید.

> "Don't confuse output (what you build) with outcome (what you release)."

**خلاصه فصل چهارم:**
1. تخمین دقیق فقط زمانی ممکن است که تیم درک عمیقی از داستان داشته باشد.
2. توسعه را به سه فاز (Opening, Mid, End) تقسیم کنید.
3. استراتژی توسعه (ساختن) با استراتژی انتشار (تحویل به بازار) متفاوت است.

---

### فصل ۵: شما همین حالا هم بلد هستید (You Already Know How)

در این فصل، جف پاتون یک تمرین بسیار ساده اما عمیق را معرفی می‌کند تا نشان دهد که ساختن Story Map اصلاً پیچیده نیست. او از مثالی استفاده می‌کند که همه ما هر روز تجربه می‌کنیم: **صبح بیدار شدن و آماده شدن برای کار.**

#### تمرین: داستان صبح خود را بنویسید

**۱. داستان را قدم به قدم بنویسید (Write Out Your Story a Step at a Time):**
پاتون از خواننده می‌خواهد چشمانش را ببندد و لحظه بیدار شدن امروز صبح را به یاد بیاورد.
- اولین کاری که کردی چه بود؟ (مثلاً: زدن دکمه Snooze).
- بعدش؟ (خاموش کردن آلارم).
- بعدش؟ (رفتن به دستشویی).

هر کدام از این‌ها را روی یک برگه چسب دار (Sticky Note) بنویسید و به ترتیب از چپ به راست روی میز بچینید.

**۲. وظایف همان کارهایی هستند که انجام می‌دهیم (Tasks Are What We Do):**
این عبارات کوتاه فعلی (مثل "دوش گرفتن"، "مسواک زدن") همان **Task** ها هستند.
> "User tasks are the basic building blocks of a story map."
(تسک‌های کاربر، بلوک‌های سازنده اصلی نقشه داستان هستند.)

**نکته منتورینگ:**
تسک (Task) در اینجا با تسک فنی (مثل "ساختن دیتابیس") فرق دارد. این‌ها کارهایی هستند که **کاربر** انجام می‌دهد تا به هدفش برسد.

**۳. تفاوت‌ها و جزئیات (Different People, Different Details):**
- شاید شما ورزش کنید، اما همکارتان نکند.
- شاید شما جزئی‌نگر باشید ("نان را در توستر گذاشتم"، "کره مالیدم") و دیگری کلی‌نگر ("صبحانه خوردم").
این تفاوت‌ها طبیعی است و در طراحی نرم‌افزار هم وجود دارد.

**۴. مفهوم سطح هدف (Goal Level Concept):**
پاتون از استعاره "سطح دریا" (Sea Level) که آلیستر کاکبرن (Alistair Cockburn) ابداع کرده استفاده می‌کند:
- **Sea Level Task:** کاری که انجام می‌دهید و تمام می‌کنید (مثلاً "دوش گرفتن").
- **Below Sea Level (Fish):** جزئیات ریز (مثلاً "شامپو زدن"، "آبکشی").
- **Summary Level (Kite):** کارهای سطح بالا (مثلاً "تمیز کردن خود").

در نقشه داستان، ما معمولاً روی سطح دریا (کارهای اصلی) تمرکز می‌کنیم.

**۵. ستون فقرات نقشه را بسازید (Make a Backbone):**
حالا که کلی تسک ریز داریم (مثلاً ۲۰-۳۰ تا)، آن‌ها را گروه‌بندی می‌کنیم.
- تمام کارهای مربوط به حمام و دستشویی -> **فعالیت (Activity):** "آماده‌سازی شخصی".
- تمام کارهای مربوط به صبحانه -> **فعالیت:** "خوردن صبحانه".
- تمام کارهای مربوط به خروج -> **فعالیت:** "ترک خانه".

این فعالیت‌های سطح بالا (Activities) که در بالای نقشه قرار می‌گیرند، **Backbone (ستون فقرات)** نقشه را تشکیل می‌دهند. این ساختار به شما کمک می‌کند در جزئیات گم نشوید.

**۶. داستان‌های جایگزین و استثناها (Explore Alternative Stories):**
حالا فکر کنید: "اگر آب قطع بود چه؟"، "اگر دیر بیدار شدم چه؟".
این‌ها شاخ و برگ‌های داستان هستند (Alternatives & Exceptions) که زیر تسک‌های اصلی قرار می‌گیرند.

**۷. برش زدن (Slicing):**
حالا تصور کنید دیرتان شده و باید در ۵ دقیقه از خانه خارج شوید!
یک خط بکشید.
- تسک‌های ضروری (پوشیدن لباس، برداشتن کیف) را بالای خط نگه دارید.
- تسک‌های غیرضروری (دوش گرفتن، قهوه دم کردن) را به پایین خط منتقل کنید.

تبریک می‌گویم! شما همین الان یک **MVP** برای "خروج سریع از خانه" ساختید.

**خلاصه فصل پنجم:**
1. ساختن Story Map مثل تعریف کردن داستان روزانه‌تان ساده است.
2. تسک‌ها (Tasks) کارهای کاربر هستند.
3. فعالیت‌ها (Activities) گروه‌هایی از تسک‌ها هستند که ستون فقرات (Backbone) را می‌سازند.
4. با تصور شرایط مختلف (مثل کمبود وقت)، می‌توانید اولویت‌بندی (Slicing) را تمرین کنید.

---

### فصل ۶: داستان واقعی درباره داستان‌ها (The Real Story About Stories)

بعد از اینکه تمرین عملی فصل ۵ را انجام دادیم، جف پاتون در این فصل به عقب برمی‌گردد تا ریشه و فلسفه "User Story" را توضیح دهد. چرا اصلاً به آن‌ها "داستان" می‌گوییم؟

#### ۱. ایده ساده و مخرب کنت بک (Kent’s Disruptively Simple Idea)

کنت بک (Kent Beck)، خالق XP (Extreme Programming)، کسی بود که ایده User Story را مطرح کرد.
او متوجه شد که یکی از بزرگترین مشکلات نرم‌افزار، **مستندات (Requirements)** است.
- ما وقت زیادی صرف نوشتن مستندات دقیق می‌کنیم.
- اما باز هم وقتی نرم‌افزار ساخته می‌شود، آن چیزی نیست که مشتری می‌خواست.

**ایده کنت این بود:**
به جای نوشتن مستندات سنگین، بیایید دور هم جمع شویم و داستان بگوییم.
> **"Stories get their name from how they should be used, not what should be written."**
> (داستان‌ها نامشان را از نحوه استفاده‌شان می‌گیرند، نه از چیزی که روی کاغذ می‌نویسید.)

اگر فقط روی "نوشتن" داستان تمرکز کنید (مثلاً فرمت `As a user, I want...`)، کل ماجرا را اشتباه فهمیده‌اید. هدف "گفتگو" است، نه نوشتن.

#### ۲. ساده آسان نیست (Simple Isn’t Easy)

پاتون توضیح می‌دهد که اگرچه ایده ساده است، اما انجام دادنش سخت است. بسیاری از تیم‌ها داستان‌ها را جایگزین مستندات قدیمی می‌کنند اما همچنان با همان ذهنیت قدیمی کار می‌کنند.
آن‌ها داستان‌ها را می‌نویسند و ایمیل می‌کنند، به جای اینکه درباره‌شان حرف بزنند.

#### ۳. مدل ۳C ران جفریس (Ron Jeffries and the 3 Cs)

ران جفریس (یکی دیگر از بنیان‌گذاران XP) ساختار User Story را با ۳ کلمه که با C شروع می‌شوند توصیف کرد. این شاید مهم‌ترین مفهوم تئوری این کتاب باشد که باید به عنوان یک Senior بلد باشید:

**۱. کارت (Card):**
- یک کارت فیزیکی (یا آیتم در جیرا) که فقط یک "تیتر" یا یادآور دارد.
- این کارت خودِ مستندات نیست! بلکه **دعوت‌نامه‌ای برای گفتگو** است.
- روی آن جزئیات زیادی ننویسید.

**۲. گفتگو (Conversation):**
- توسعه‌دهندگان، تسترها و Product Owner دور هم جمع می‌شوند و درباره کارت حرف می‌زنند.
- اینجا جایی است که جزئیات کشف می‌شود.
- اینجا جایی است که Shared Understanding شکل می‌گیرد.
- این گفتگو باید شفاهی باشد، نه متنی.

**۳. تایید (Confirmation):**
- از کجا بفهمیم کار تمام شده؟
- اینجا **Acceptance Criteria** (معیارهای پذیرش) وارد می‌شود.
- این‌ها توافق‌هایی هستند که در حین گفتگو به دست آمده‌اند و پشت کارت (یا در بخش توضیحات) نوشته می‌شوند تا مطمئن شویم همه یک چیز را ساخته‌اند.

**نکته منتورینگ برای Senior Dev:**
اگر در تیم شما، Product Owner داستان را می‌نویسد و بدون هیچ جلسه‌ای به دست شما می‌دهد تا کد بزنید، شما بخش **Conversation** را حذف کرده‌اید. در این حالت، شما Agile کار نمی‌کنید، بلکه Waterfall در ابعاد کوچک کار می‌کنید!

#### ۴. کلمات و تصاویر (Words and Pictures)

پاتون تأکید می‌کند که گفتگو فقط با کلمات کافی نیست.
وقتی حرف می‌زنید، باید از وایت‌برد، ماژیک، اسکچ و وایرفریم استفاده کنید.
> "Shared documents aren’t shared understanding."
(مستندات مشترک به معنی درک مشترک نیست.)

تنها راه ایجاد درک مشترک، گفتگوی تعاملی با استفاده از تصاویر است.

**خلاصه فصل ششم:**
1. User Story یک "سند" نیست، بلکه یک روش تعامل است.
2. مدل ۳C (Card, Conversation, Confirmation) را در تیمتان نهادینه کنید.
3. کارت فقط یک یادآور است؛ جادوی اصلی در گفتگو اتفاق می‌افتد.

---

### فصل ۷: تعریف کردن داستان‌های بهتر (Telling Better Stories)

در این فصل، جف پاتون به ما یاد می‌دهد که چطور از "نوشتن" فاصله بگیریم و شروع به "تعریف کردن" کنیم. او از تمپلیت معروف User Story شروع می‌کند و نشان می‌دهد چطور می‌تواند به یک دام تبدیل شود.

#### ۱. تمپلیت باحال Connextra (Connextra’s Cool Template)

احتمالاً این فرمت را هزاران بار دیده‌اید:
> **As a** [type of user]
> **I want to** [do something]
> **So that I can** [get some benefit]

این تمپلیت اولین بار توسط شرکت Connextra ابداع شد. هدفش عالی بود: وادار کردن ما به فکر کردن درباره **سه عنصر کلیدی**:
1.  **Who:** چه کسی این را می‌خواهد؟
2.  **What:** چه کاری می‌خواهد انجام دهد؟
3.  **Why:** چرا؟ چه ارزشی برایش دارد؟

اما پاتون هشدار می‌دهد که این فقط یک **آغازگر گفتگو** (Conversation Starter) است، نه خودِ داستان.

#### ۲. زامبی‌های تمپلیت و ماشین برف‌روب (Template Zombies and the Snowplow)

این یکی از جذاب‌ترین استعاره‌های کتاب است.

**زامبی‌های تمپلیت:**
تیم‌هایی که بدون فکر کردن، فقط جاهای خالی را پر می‌کنند.
مثال: *"به عنوان یک کاربر لاگین شده، می‌خواهم لاگین کنم، تا بتوانم وارد سیستم شوم!"*
این جمله هیچ اطلاعات مفیدی ندارد. فقط فرمت را رعایت کرده است. این کار یک زامبی است: ظاهراً زنده است، اما مغز ندارد.

**ماشین برف‌روب (The Snowplow):**
پاتون داستانی تعریف می‌کند که در کودکی منتظر اتوبوس مدرسه بود، اما برف سنگینی آمده بود. ناگهان یک ماشین برف‌روب آمد و جاده را باز کرد.
برای او، آن ماشین فقط "برف‌روب" نبود.
- **As a** دانش‌آموز یخ زده،
- **I want to** جاده باز شود،
- **So that** اتوبوس بیاید و من گرم شوم؟
نه! هدف واقعی این بود که به مدرسه برسد و دوستانش را ببیند.

اگر شما فقط روی "باز کردن جاده" تمرکز کنید (Output)، ممکن است فراموش کنید که هدف "رسیدن به مدرسه" (Outcome) است. شاید مدرسه تعطیل باشد! پس باز کردن جاده بی‌فایده است.

#### ۳. چک‌لیست برای صحبت کردن (A Checklist of What to Really Talk About)

به جای پر کردن کورکورانه تمپلیت، درباره این‌ها حرف بزنید:
1.  **کاربران واقعی (Real Users):** نه فقط "کاربر". بلکه "مریم، مدیر حسابداری که عینکی است و از اکسل متنفر است".
2.  **نیازهای واقعی (Real Needs):** مشکلش چیست؟
3.  **چرا (Why):** چرا الان؟ چرا این راه حل؟
4.  **چطور (How):** (اینجا جایی است که توسعه‌دهندگان وارد می‌شوند). راه حل فنی چیست؟ چقدر طول می‌کشد؟
5.  **شرایط پذیرش (Acceptance):** کی بگوییم تمام شد؟

#### ۴. عکس‌های تعطیلات بسازید (Create Vacation Photos)

این مهم‌ترین مفهوم این فصل است.
پاتون می‌گوید: **مستندات باید مثل عکس‌های تعطیلات باشند.**

- وقتی شما عکس تعطیلات خودتان را می‌بینید، تمام خاطرات، بوها، و احساسات آن لحظه برایتان زنده می‌شود.
- اما اگر من عکس تعطیلات شما را ببینم، فقط چند نفر را می‌بینم که در ساحل ایستاده‌اند. هیچ حسی ندارم.

**نکته برای تیم‌ها:**
- اگر شما در جلسه (Conversation) بودید، عکس وایت‌برد و نوشته‌های کوتاه (Card) برایتان حکم همان عکس تعطیلات را دارد. همه چیز را به یاد می‌آورید.
- اما اگر کسی در جلسه نبود، آن کارت برایش بی‌معنی است. شما نمی‌توانید کارت را به کسی بدهید که در "تعطیلات" (جلسه) نبوده و انتظار داشته باشید همه چیز را بفهمد.

> **"Documents help you remember, they don't help you explain."**
> (مستندات به شما کمک می‌کنند به یاد بیاورید، نه اینکه توضیح دهید.)

بنابراین، اگر عضو جدیدی به تیم اضافه شد، کارت را به او ندهید. **داستان را برایش تعریف کنید.**

**خلاصه فصل هفتم:**
1. تمپلیت `As a... I want...` فقط برای شروع بحث است، نه پایان آن.
2. از زامبی شدن بپرهیزید؛ جملات بی‌معنی ننویسید.
3. کارت‌ها مثل عکس‌های تعطیلات هستند؛ فقط برای کسانی معنی دارند که "آنجا" (در جلسه) بوده‌اند.

---

### فصل ۸: همه چیز روی کارت نیست (It’s Not All on the Card)

این فصل یکی از مهم‌ترین سوءتفاهم‌های User Story را حل می‌کند. بسیاری از تیم‌ها سعی می‌کنند تمام اطلاعات را روی همان کارت کوچک یا در یک تیکت جیرا جا دهند. پاتون در این فصل به ما می‌گوید که کارت محدودیت دارد و این خوب است!

#### ۱. آدم‌های متفاوت، گفتگوهای متفاوت (Different People, Different Conversations)

تصور کنید برای ساختن یک فیچر باید با افراد مختلف صحبت کنید:
- **با کاربر:** درباره نیازش صحبت می‌کنید ("چرا این را می‌خواهی؟").
- **با طراح UI:** درباره ظاهر و تجربه کاربری ("این دکمه کجا باشد؟").
- **با تستر:** درباره حالت‌های شکست و باگ‌ها ("اگر اینترنت قطع شد چه؟").
- **با دیتابیس کار:** درباره اسکیمای جدول‌ها.

آیا می‌توانید همه این مکالمات را روی یک کارت ۳x۵ اینچی بنویسید؟ قطعاً نه.
تلاش برای نوشتن همه چیز روی کارت، آن را تبدیل به یک هیولای غیرقابل خواندن می‌کند.

#### ۲. ما به کارت بزرگتری نیاز داریم! (We’re Gonna Need a Bigger Card)

این تیتر ارجاعی به دیالوگ معروف فیلم "Jaws" است ("We're gonna need a bigger boat").
اما راه حل، بزرگتر کردن کارت نیست.

**استعاره کارت کتابخانه (Library Card Catalog):**
پاتون از مثال کارت‌های قدیمی کتابخانه استفاده می‌کند.
- روی کارت کتابخانه چه چیزی نوشته شده؟ عنوان کتاب، نویسنده، و **آدرس قفسه**.
- کارت کتابخانه، **خودِ کتاب نیست**.
- کارت User Story هم **خودِ مستندات نیست**.

کارت فقط یک **Pointer** (اشاره‌گر) یا **Token** است.
این کارت به شما می‌گوید: "هی! ما باید درباره این موضوع حرف بزنیم. جزئیاتش در ویکی/کانفلوئنس/وایت‌برد/ذهن مریم است."

#### ۳. رادیاتورها و یخچال‌ها (Radiators and Ice Boxes)

این مفهوم را آلیستر کاکبرن (Alistair Cockburn) معرفی کرده است.

**Information Radiator (رادیاتور اطلاعات):**
- چیزی که روی دیوار است (مثل وایت‌برد یا بورد فیزیکی).
- اطلاعات را به سمت شما **پرت** می‌کند (Radiate).
- وقتی رد می‌شوید، ناخودآگاه آن را می‌بینید.
- برای اطلاعات "زنده" و "در جریان" عالی است.

**Information Ice Box (یخچال اطلاعات):**
- جایی که اطلاعات می‌رود تا سرد و نگهداری شود (مثل جیرا، اکسل، شیرپوینت).
- برای دیدن اطلاعات، باید در یخچال را باز کنید (لاگین کنید، سرچ کنید).
- اطلاعات در اینجا تمیز و ماندگار است، اما "دیده" نمی‌شود.

**مشکل تیم‌ها:**
بسیاری از تیم‌ها فقط از یخچال (Jira) استفاده می‌کنند. نتیجه این است که هیچ کس از وضعیت کلی خبر ندارد چون کسی حال ندارد مدام در یخچال را باز کند!
پاتون توصیه می‌کند: از دیوار (رادیاتور) برای بحث و گفتگو استفاده کنید، و از ابزار دیجیتال (یخچال) برای بایگانی و ردیابی.

#### ۴. ابزار برای این کار نیست (That’s Not What That Tool Is For)

ابزارهایی مثل جیرا برای **Tracking** (ردیابی) عالی هستند، اما برای **Shared Understanding** (درک مشترک) افتضاح هستند.
شما نمی‌توانید با کامنت گذاشتن در جیرا، درک عمیق ایجاد کنید.
- برای **یادگیری و درک**: از وایت‌برد و گفتگو استفاده کنید.
- برای **ردیابی و یادآوری**: از ابزار دیجیتال استفاده کنید.

**خلاصه فصل هشتم:**
1. کارت User Story فقط یک "آدرس" یا "نشانه" است، نه مخزن اطلاعات.
2. مکالمات مختلف با آدم‌های مختلف را نمی‌توان روی یک کارت جا داد.
3. تفاوت **Radiator** (دیوار/وایت‌برد) و **Ice Box** (جیرا/ابزار) را بدانید و از هر کدام درست استفاده کنید.
4. ابزار دیجیتال جایگزین گفتگو نیست.

---

### فصل ۹: کارت فقط شروع ماجراست (The Card Is Just the Beginning)

در این فصل، پاتون به ما می‌گوید که بعد از نوشتن کارت و حتی بعد از گفتگوی اولیه، چه اتفاقی باید بیفتد.

#### ۱. با تصویری شفاف در ذهن بسازید (Construct with a Clear Picture in Your Head)

بعد از مکالمات طولانی و نوشتن جزئیات روی وایت‌برد یا پشت کارت، حالا نوبت "ساختن" است.
- برنامه‌نویسان کد می‌زنند.
- تسترها تست‌پلن می‌نویسند.
- طراحان UI اتود نهایی می‌زنند.

**هشدار بزرگ پاتون:**
> **"Handing off all the details about the story to someone else to build doesn’t work. Don't do that."**
> (دست‌به‌دست کردن جزئیات داستان به شخص دیگری برای ساختن، کار نمی‌کند. این کار را نکنید.)

اگر شما در جلسه بودید و همکارتان نبود، نمی‌توانید کارت را به او بدهید و بگویید "بیا این را بساز". چون مغز شما جزئیات را پر کرده (مثل عکس تعطیلات)، اما مغز او خالی است.

#### ۲. سنت شفاهی داستان‌گویی بسازید (Build an Oral Tradition of Storytelling)

اگر کسی در جلسه نبوده و باید روی داستان کار کند، چه کنیم؟
- **داستان را برایش تعریف کنید (Retell the Story):**
  زمان بگذارید و دوباره داستان را با استفاده از وایت‌برد و مستندات برایش روایت کنید.
- **گروه‌های کوچک (Small Groups):**
  همه نباید در همه جلسات باشند (چون جلسه شلوغ می‌شود).
  یک گروه کوچک (۲-۵ نفر) تصمیم می‌گیرند، و سپس نماینده آن گروه، داستان را برای بقیه تعریف می‌کند.

#### ۳. نتایج کارتان را بازرسی کنید (Inspect the Results of Your Work)

وقتی کد زده شد، کار تمام نیست.
تیم باید دور هم جمع شود و چیزی که ساخته شده را بررسی کند.

پاتون سه نوع کیفیت را بررسی می‌کند:
1.  **User Experience Quality:** آیا استفاده از آن راحت و لذت‌بخش است؟ (ظاهر و حس).
2.  **Functional Quality:** آیا کار می‌کند؟ باگ ندارد؟ (تست).
3.  **Code Quality:** آیا کد تمیز است؟ (معماری، بدهی فنی).

**نکته منتورینگ:**
بسیاری از تیم‌ها در دمو (Sprint Review) فقط چک می‌کنند که "آیا کار می‌کند؟". اما یک تیم حرفه‌ای (Senior) حتماً **Code Quality** را هم بررسی می‌کند (Code Review) و از خود می‌پرسد: "آیا این کد قابل نگهداری است یا فقط سرهم‌بندی شده؟"

#### ۴. برای شما نیست (It’s Not for You)

وقتی محصول را بررسی می‌کنید، یادتان باشد:
> **"You can’t always get what you want. But if you try sometime, you just might find, you get what you need."**
(شما همیشه چیزی که می‌خواهید را نمی‌گیرید، اما شاید چیزی که نیاز دارید را بگیرید.)

در نرم‌افزار برعکس است!
شما دقیقاً چیزی که **خواستید** (Agreed upon) را می‌گیرید، اما وقتی آن را می‌بینید، می‌فهمید که چیزی نیست که **نیاز** داشتید!
- این طبیعت نرم‌افزار است. دیدن محصول واقعی، نیازهای جدیدی را در ذهن شما بیدار می‌کند که قبلاً به آن‌ها فکر نکرده بودید.
- پس تغییر در نیازها (Change in Requirements) نشانه شکست نیست، نشانه **یادگیری** است.

#### ۵. برای یادگیری بسازید (Build to Learn)

اگر بپذیریم که اولین نسخه احتمالاً کامل نیست، پس هدف از ساختن چیست؟
هدف **یادگیری** است.
- ما می‌سازیم تا ببینیم.
- می‌بینیم تا یاد بگیریم.
- یاد می‌گیریم تا نسخه بعدی را بهتر بسازیم.

این چرخه (Build-Measure-Learn) قلب تپنده توسعه چابک است.

**خلاصه فصل نهم:**
1. مستندات را دست‌به‌دست نکنید؛ داستان را سینه به سینه نقل کنید.
2. کیفیت کد به اندازه کیفیت محصول مهم است.
3. تغییر نظر بعد از دیدن محصول طبیعی است؛ از آن برای یادگیری استفاده کنید.

---

### فصل ۱۰: پختن داستان‌ها مثل کیک (Bake Stories Like Cake)

پاتون در این فصل از یک استعاره خوشمزه استفاده می‌کند تا فرآیند تبدیل یک ایده انتزاعی به وظایف قابل انجام را توضیح دهد.

#### ۱. دستور پخت بسازید (Create a Recipe)

جف داستان "کیک پختن" برای تولد دخترش را تعریف می‌کند.
او با شیرینی‌پز (سیدنی) تماس می‌گیرد.
- **جف:** "یه کیک برای تولد ۱۲ سالگی گریس می‌خوام."
- **سیدنی:** "گریس چی دوست داره؟ چه طعم‌هایی؟ چند نفر هستید؟"

سیدنی در حین مکالمه، در ذهنش دارد "دستور پخت" (Recipe) را می‌سازد: آرد، شکر، تخم‌مرغ، قالب پرنده شکل و غیره.
اگر سیدنی فقط لیست مواد اولیه (Tasks) را بنویسد و به جف بدهد، جف هیچ چیزی از کیک نهایی نمی‌فهمد.

**نکته کلیدی:**
تیم توسعه هم مثل سیدنی است. وقتی شما (به عنوان PO یا مشتری) داستان را می‌گویید، تیم در ذهنش دارد آن را به **Tasks** (تسک‌های فنی) تبدیل می‌کند.
- دیتابیس می‌خواهیم.
- API می‌خواهیم.
- فرانت‌‌اند می‌خواهیم.

اما نباید بحث را با "آرد و شکر" (تسک‌های فنی) شروع کنید. بحث باید درباره "کیک و تولد" (ارزش برای کاربر) باشد.

#### ۲. شکستن کیک بزرگ (Breaking Down a Big Cake)

حالا فرض کنید کیک خیلی بزرگ است (یک پروژه بزرگ نرم‌افزاری).
بسیاری از تیم‌ها اشتباه می‌کنند و کیک را اینطور می‌شکنند:
- هفته اول: فقط آردها را الک می‌کنیم (لایه دیتابیس).
- هفته دوم: فقط خمیر را هم می‌زنیم (لایه API).
- هفته سوم: کیک را می‌پزیم (UI).
- هفته چهارم: تزئین می‌کنیم (Integration).

**مشکل این روش چیست؟**
تا هفته چهارم هیچ کیکی برای تست کردن ندارید! اگر در هفته چهارم بفهمید کیک بدمزه است، کل ۴ هفته هدر رفته است.

**راه حل پاتون: کاپ‌کیک (Cupcakes)!**
به جای پختن یک کیک عروسی ۵ طبقه، اول یک **کاپ‌کیک** بپزید.
- کاپ‌کیک همه لایه‌ها را دارد (آرد، شکر، پخت، تزئین).
- می‌توانید طعمش را تست کنید.
- می‌توانید ظاهرش را ببینید.
- اگر بد بود، فقط مواد یک کاپ‌کیک هدر رفته.

**در نرم‌افزار:**
یک ویژگی کوچک را انتخاب کنید که همه لایه‌ها (DB, API, UI) را درگیر کند و آن را کامل بسازید (Walking Skeleton).
> **"Break big things into small things with small plans."**
> (چیزهای بزرگ را به چیزهای کوچک با برنامه‌های کوچک بشکنید.)


---

### فصل ۱۱: شکستن سنگ‌ها (Rock Breaking)

پاتون از استعاره جدیدی استفاده می‌کند: **داستان‌ها مثل سنگ هستند.**
گاهی سنگ‌ها آنقدر بزرگند که نمی‌توان آن‌ها را بلند کرد (ساخت). باید آن‌ها را شکست.

#### ۱. اندازه همیشه مهم است (Size Always Matters)

اندازه داستان بستگی به این دارد که چه کسی به آن نگاه می‌کند:
- **از دید کاربر (User Perspective):** داستان باید یک **نیاز** را برطرف کند (Need-sized). کاربر برایش مهم نیست چقدر طول می‌کشد.
- **از دید تیم توسعه (Dev Perspective):** داستان باید **قابل ساخت در چند روز** باشد (Task-sized).
- **از دید بیزنس (Business Perspective):** داستان باید یک **Outcome** تجاری داشته باشد (Release-sized).

هنر شما این است که این اندازه‌های مختلف را با هم آشتی دهید.

#### ۲. داستان‌ها، اپیک‌ها و تم‌ها (Stories, Epics, Themes)

پاتون به ترمینولوژی رایج Agile حمله می‌کند!
- **Epic:** یک سنگ خیلی بزرگ که گاهی برای زدن توی سر بقیه استفاده می‌شود! (شوخی پاتون با مدیرانی که اپیک‌های عظیم تعریف می‌کنند).
- **Theme:** گروهی از داستان‌ها.

پاتون می‌گوید: **این اصطلاحات را فراموش کنید و روی داستان‌گویی تمرکز کنید.**
مهم نیست اسمش را چه می‌گذارید (Epic, Feature, Story). مهم این است که آیا به اندازه کافی کوچک شده که بتوان آن را ساخت؟ و آیا هنوز آنقدر بزرگ هست که برای کاربر ارزش داشته باشد؟

**چرخه شکستن سنگ:**
1.  **Opportunity:** سنگ خیلی بزرگ (ایده بیزنس).
2.  **Discovery:** شکستن سنگ بزرگ به چند سنگ متوسط (Minimum Viable Solution).
3.  **Delivery:** شکستن سنگ‌های متوسط به سنگ‌ریزه‌ها (User Stories برای دولوپرها).

**خلاصه فصول ۱۰ و ۱۱:**
1. نرم‌افزار را لایه‌ای (فقط دیتابیس، فقط UI) نسازید؛ مثل کاپ‌کیک بسازید (End-to-End).
2. داستان‌ها اندازه‌های مختلفی دارند. هنر ما شکستن سنگ‌های بزرگ (ایده‌ها) به سنگ‌ریزه‌های قابل حمل (تسک‌ها) است، بدون اینکه ارزش نهایی (مجسمه سنگی) را فراموش کنیم.

---

### فصل ۱۲: سنگ شکن‌ها (Rock Breakers)

در فصل قبلی گفتیم که داستان‌ها مثل سنگ هستند و باید آن‌ها را بشکنیم. اما چه کسانی این سنگ‌ها را می‌شکنند و چطور؟

#### ۱. ارزشمند، قابل استفاده، شدنی (Valuable - Usable - Feasible)

برای ساختن یک محصول موفق، باید سه ویژگی را همزمان داشته باشیم. این مدل بسیار معروف را مارتی کیگان (Marty Cagan) معرفی کرده است:

1.  **Valuable (ارزشمند):** آیا مشتری این را می‌خرد؟ آیا بیزنس از آن سود می‌برد؟
2.  **Usable (قابل استفاده):** آیا کاربر می‌تواند بفهمد چطور با آن کار کند؟
3.  **Feasible (شدنی):** آیا با تکنولوژی و زمان و بودجه فعلی می‌توانیم آن را بسازیم؟

اگر فقط روی Feasible تمرکز کنیم (کاری که دولوپرها دوست دارند)، محصولی می‌سازیم که کار می‌کند اما کسی آن را نمی‌خواهد.
اگر فقط روی Valuable تمرکز کنیم، ایده‌هایی داریم که ساختنشان ۱۰ سال طول می‌کشد.

#### ۲. سه رفیق (The Three Amigos)

برای اینکه مطمئن شویم هر سه جنبه بالا در نظر گرفته شده‌اند، به سه نقش کلیدی نیاز داریم که پاتون آن‌ها را **سه رفیق** (The Three Amigos) می‌نامد:

1.  **نماینده بیزنس (Product Owner/Product Manager):**
    - مسئول **Valuable** بودن است.
    - می‌گوید: "چه چیزی بسازیم که پول دربیاوریم؟"
2.  **نماینده تجربه کاربری (UX Designer):**
    - مسئول **Usable** بودن است.
    - می‌گوید: "کاربر چطور با این کار می‌کند؟"
3.  **نماینده فنی (Lead Developer/Architect):**
    - مسئول **Feasible** بودن است.
    - می‌گوید: "چقدر طول می‌کشد؟ پرفورمنس آن چطور است؟"

**نکته مهم:** این سه نفر باید **با هم** داستان‌ها را بنویسند و بشکنند.
اگر PO داستان را بنویسد و به Dev بدهد، جنبه Feasible نادیده گرفته شده است.

---

### فصل ۱۳: شروع با فرصت‌ها (Start with Opportunities)

قبل از اینکه وارد جزئیات شویم و مپ درست کنیم، باید یک "سنگ خیلی بزرگ" داشته باشیم که ارزش شکستن داشته باشد. پاتون این سنگ اولیه را **Opportunity** می‌نامد.

#### ۱. گفتگو درباره فرصت‌ها (Have Conversations About Opportunities)

فرصت (Opportunity) همان ایده خامی است که هنوز مطمئن نیستیم باید رویش سرمایه‌گذاری کنیم یا نه.
به جای اینکه فوراً شروع به نوشتن User Story کنید، اول درباره فرصت حرف بزنید:
- این برای چه کسی است؟
- چه مشکلی را حل می‌کند؟
- چرا برای سازمان ما خوب است؟

#### ۲. عمیق شوید، دور بریزید یا فکر کنید (Dig Deeper, Trash It, or Think About It)

وقتی درباره یک فرصت بحث می‌کنید، سه خروجی ممکن است:
1.  **Dig Deeper (Go):** ایده خوب است. بیایید بیشتر بررسیش کنیم (وارد فاز Discovery شویم).
2.  **Trash It (No-Go):** ایده به درد نمی‌خورد یا الان وقتش نیست. دورش بریزید! (این خیلی مهم است. نترسید از اینکه بگویید نه).
3.  **Think About It:** اطلاعات کافی نداریم. برویم تحقیق کنیم.

#### ۳. بوم فرصت (The Opportunity Canvas)

پاتون ابزاری معرفی می‌کند به نام **Opportunity Canvas** (که الهام گرفته از Marty Cagan و Business Model Canvas است).
این بوم کمک می‌کند قبل از شروع پروژه، سوالات سخت را از خودتان بپرسید:
1.  مشکل چیست؟
2.  راه‌حل چیست؟
3.  مشتریان کیستند؟
4.  چطور موفقیت را اندازه می‌گیریم؟
5.  بودجه ما چقدر است؟

**کاربرد عملی:**
قبل از اینکه تیم را درگیر کدنویسی کنید، یک جلسه ۱ ساعته با **سه رفیق** بگذارید و این بوم را برای ایده جدید پر کنید. اگر نتوانستید پر کنید، یعنی هنوز آماده ساخت نیستید.

**خلاصه فصول ۱۲ و ۱۳:**
1. هر استوری باید از فیلتر **Valuable, Usable, Feasible** رد شود.
2. برای این کار به همکاری **PO, UX, Dev** (سه رفیق) نیاز دارید.
3. هر ایده‌ای ارزش ساختن ندارد. قبل از شروع، با استفاده از **Opportunity Canvas** مطمئن شوید که ایده خوبی است یا آن را دور بریزید.

---

### فصل ۱۴: استفاده از دیسکاوری برای درک مشترک (Discovery for Shared Understanding)

در این فصل، پاتون وارد جزئیات فاز **Discovery** می‌شود. او توضیح می‌دهد که هدف دیسکاوری "ساختن نرم‌افزار" نیست، بلکه ساختن **درک مشترک** است تا بفهمیم چه چیزی ارزش ساختن دارد.

#### ۱. دیسکاوری درباره ساختن نرم‌افزار نیست (Discovery Isn’t About Building Software)

اگر در فاز دیسکاوری دارید کد می‌زنید یا تسک‌های جیرا را پر می‌کنید، دارید اشتباه می‌زنید!
هدف دیسکاوری **یادگیری** است:
- واقعاً چه مشکلی را حل می‌کنیم؟
- راه‌حل قابل استفاده (Usable) چیست؟
- آیا ساختش شدنی (Feasible) است؟

#### ۲. چهار گام ضروری دیسکاوری (Four Essential Steps to Discovery)

پاتون یک چارچوب ۴ مرحله‌ای ساده برای دیسکاوری معرفی می‌کند:

**۱. ایده‌پردازی و چارچوب‌بندی (Frame the Idea):**
- این ایده از نظر بیزنس چرا مهم است؟
- برای چه کسی است؟
- مرزهایش کجاست؟ (چه چیزی نیست؟)

**۲. درک مشتریان و کاربران (Understand Customers and Users):**
- از **پرسونا (Persona)** استفاده کنید.
- اما نه پرسوناهای فانتزی و طولانی که کسی نمی‌خواند. پرسوناهای ساده و کاربردی روی کاغذ فلیپ‌چارت.
- پاتون مثال می‌زند: "چاک، دونیت‌کننده اینترنتی". با تیم جمع شوید و روی کاغذ بنویسید چاک کیست و چه دردی دارد.

**۳. تصور راه‌حل (Envision Your Solution):**
- اینجا جایی است که **Story Map** می‌درخشد.
- داستان چاک را تعریف کنید: "چاک ایمیل را می‌بیند، روی لینک کلیک می‌کند..."
- از **Design Studio** استفاده کنید: همه اعضای تیم (حتی دولوپرها) کاغذ و قلم بردارند و راه‌حل (UI) را نقاشی کنند. سپس طرح‌ها را مقایسه و ترکیب کنید.
- **نکته کلیدی:** "Design by community is not design by committee". یعنی همه ایده می‌دهند، اما در نهایت یک طراح یا رهبر باید تصمیم نهایی را بگیرد و طرح یکپارچه را بسازد.

**۴. کوچک‌سازی و برنامه‌ریزی (Minimize and Plan):**
- حالا که راه‌حل ایده‌آل را دیدید، چاقوی جراحی را بردارید!
- چه چیزی را می‌توانیم حذف کنیم و هنوز "چاک" بتواند کارش را انجام دهد؟
- به یک **Minimum Viable Solution** برسید.

---

### فصل ۱۵: استفاده از دیسکاوری برای یادگیری معتبر (Validated Learning)

در این فصل، پاتون مفهوم **Lean Startup** (اریک ریس) را وارد ماجرا می‌کند.

#### ۱. ما اکثر اوقات اشتباه می‌کنیم (We’re Wrong Most of the Time)

این اعتراف دردناک ولی واقعی است.
- طبق آمار Standish Group، حدود **۶۴٪ فیچرهای نرم‌افزارها هرگز یا به ندرت استفاده می‌شوند**.
- یعنی ما وقتمان را صرف ساختن چیزهایی می‌کنیم که کسی نمی‌خواهد.
- حتی اگر بهترین پروسه دیسکاوری را داشته باشید، باز هم در نهایت دارید **حدس می‌زنید**.

#### ۲. روزهای بد قدیم (The Bad Old Days)
قدیم‌ها شرکت‌ها ماه‌ها وقت صرف نوشتن نیازمندی‌ها می‌کردند، ماه‌ها می‌ساختند و بعد از یک سال شکست می‌خوردند.
حالا ما سریع‌تر می‌سازیم (Agile)، ولی اگر مراقب نباشیم، فقط **سریع‌تر شکست می‌خوریم**!

#### ۳. حلقه‌های کوتاه یادگیری (Short Validated Learning Loops)

راه حل چیست؟ **Build-Measure-Learn**.
- به جای اینکه کل محصول را بسازید تا بفهمید اشتباه کرده‌اید، کوچکترین چیزی که می‌توانید بسازید تا یک **فرض** را تست کنید چیست؟

#### ۴. با حدس زدن شروع کنید (Start by Guessing)

نترسید که بگویید "نمی‌دانم".
- **فرضیات پرخطر (Risky Assumptions) را نام ببرید:**
  - "ما فرض می‌کنیم کاربران حاضرند شماره موبایلشان را وارد کنند."
  - "ما فرض می‌کنیم مدیران وقت دارند گزارش‌ها را بخوانند."
- **یک تست کوچک طراحی کنید:**
  - پروتوتایپ کاغذی.
  - مصاحبه.
  - یک لندینگ پیج ساده.

**نکته منتورینگ:**
به عنوان یک سنیور، وظیفه تو این نیست که فقط "کد تمیز" بزنی. وظیفه تو این است که از PO بپرسی: "چطور مطمئنیم که کاربر این را می‌خواهد؟ آیا می‌توانیم قبل از اینکه من دو هفته وقت صرف کدنویسی کنم، این را با یک پروتوتایپ ساده تست کنیم؟" اینجاست که ارزش واقعی تو مشخص می‌شود.

**خلاصه فصول ۱۴ و ۱۵:**
1. دیسکاوری ۴ مرحله دارد: Frame -> Understand -> Envision -> Minimize.
2. هدف دیسکاوری ساختن **درک مشترک** است، نه پر کردن بک‌لاگ.
3. فروتن باشید: اکثر ایده‌های ما غلط از آب در می‌آیند.
4. قبل از ساختن (Building)، یاد بگیرید (Learning). از حلقه‌های بازخورد کوتاه استفاده کنید.

---

### فصل ۱۶: پالایش، تعریف و ساختن (Refine, Define, and Build)

حالا که ایده‌های بزرگ را در دیسکاوری بررسی کردیم، وقت آن است که آن‌ها را برای تیم توسعه آماده کنیم. این فصل دقیقاً جایی است که "توسعه‌دهنده ارشد" بودن شما می‌درخشد، چون بحث تبدیل ایده به کد اجرایی است.

#### ۱. کارگاه داستان (Workshopping Stories)

بسیاری از تیم‌ها فقط یک جلسه "اسپرینت پلنینگ" (Sprint Planning) دارند. پاتون می‌گوید این کافی نیست.
شما قبل از پلنینگ، به جلسات **Story Workshop** (که اغلب به آن Backlog Refinement یا Grooming هم می‌گویند) نیاز دارید.

**تفاوت کلیدی:**
- در **Planning** ما تعهد می‌دهیم (Commit) که چه کاری را در ۲ هفته انجام دهیم.
- در **Workshop** ما یاد می‌گیریم، بحث می‌کنیم و داستان‌ها را خرد می‌کنیم.

در کارگاه داستان:
1.  **داستان را بخوانید:** نه فقط تیتر را، بلکه کل روایت را.
2.  **گفتگو کنید:** دولوپرها سوالات فنی می‌پرسند (Validation, Edge cases).
3.  **معیارهای پذیرش (Acceptance Criteria) را بنویسید:** این‌ها "شرط پایان" کار هستند.

#### ۲. جمعیت همکاری نمی‌کند (Crowds Don’t Collaborate)

پاتون یک قانون طلایی دارد: **"اگر تعداد افراد جلسه زیاد باشد، همکاری می‌میرد."**
- اگر کل تیم ۱۰ نفره را در یک اتاق بنشانید تا یک استوری را بشکنند، معمولاً ۲ نفر حرف می‌زنند و ۸ نفر با گوشی بازی می‌کنند.
- **راه حل:** تیم را به گروه‌های کوچک (۲ تا ۳ نفره) تقسیم کنید. هر گروه روی یک استوری کار کند و بعد نتیجه را به بقیه بگوید (Divide and Conquer).

#### ۳. تقسیم کردن و نازک کردن (Split and Thin)

این یکی از تکنیکی‌ترین مفاهیم کتاب است که برای شما که به Clean Code علاقه دارید، بسیار جذاب خواهد بود.
ما دو روش برای کوچک کردن کارها داریم:

**الف) Split (تقسیم کردن):**
مثل شکستن یک سنگ به دو سنگ کوچکتر.
- مثال: "جستجوی محصول" را می‌شکنیم به "جستجو با نام" و "جستجو با دسته‌بندی".
- هر دو قسمت لازم هستند، فقط جداگانه ساخته می‌شوند.

**ب) Thin (نازک کردن):**
مثل تراشیدن چربی‌های اضافه از روی گوشت.
- مثال: در "جستجوی محصول"، شاید "Auto-complete" یا "غلط‌گیر املایی" فعلاً لازم نباشد. آن‌ها را می‌تراشیم و به آینده موکول می‌کنیم.
- نتیجه یک نسخه لاغرتر (Thinner) اما کارآمد است.

**نکته منتورینگ (ارتباط با OOP):**
وقتی استوری‌ها را درست **Split** می‌کنید، رعایت اصل **Single Responsibility (SRP)** در کد راحت‌تر می‌شود. هر استوری دقیقاً یک کار مشخص انجام می‌دهد و کلاس‌ها و متدهای شما هم متمرکزتر می‌شوند. استوری‌های بزرگ و مبهم، منجر به کلاس‌های God Object و کدهای کثیف می‌شوند.

### فصل ۱۷: داستان‌ها در واقع مثل سیارک هستند (Stories Are Actually Like Asteroids)

پاتون در اینجا یک استعاره جالب دیگر می‌زند تا دیدگاه ما را نسبت به اندازه کارها اصلاح کند.

#### ۱. سنگ‌های شکسته را دوباره کنار هم بگذارید (Reassembling Broken Rocks)

یادتان هست گفتیم داستان‌ها سنگ هستند و باید شکسته شوند؟
وقتی یک سنگ بزرگ (Feature) را به سنگ‌ریزه‌ها (User Stories) تبدیل می‌کنید و آن‌ها را در بک‌لاگ می‌ریزید، یک مشکل بزرگ پیش می‌آید: **تصویر کلی از دست می‌رود.**
شما یک مشت سنگ‌ریزه دارید و یادتان می‌رود که این‌ها قرار بود مجسمه یک "اسب" باشند.

اینجاست که **Story Map** دوباره وارد می‌شود.
- مپ مثل **عکس روی جعبه پازل** است.
- وقتی دولوپر دارد روی قطعه کوچک (یک استوری) کار می‌کند، باید بتواند به مپ نگاه کند و ببیند این قطعه در کجای تصویر بزرگ (Big Picture) قرار می‌گیرد.
- بدون مپ، دولوپرها کدهای عالی می‌نویسند که به هم وصل نمی‌شوند (Integration Hell).

#### ۲. استعاره سیارک (Asteroid)

چرا سیارک؟
- وقتی از روی زمین (دید مدیران) به سیارک نگاه می‌کنید، یک نقطه نورانی کوچک است. ("آره، یه صفحه لاگین ساده می‌خوایم").
- وقتی فضاپیما (تیم توسعه) به سیارک نزدیک می‌شود، می‌بیند که آن نقطه کوچک، یک کوه عظیم پر از چاله و سنگ و غبار است!

**درس اخلاقی:**
هرگز پیچیدگی یک استوری را تا زمانی که واقعاً بازش نکرده‌اید (Conversation)، قضاوت نکنید. چیزی که روی کارت ۳x۵ اینچی جا می‌شود، ممکن است دو هفته کدنویسی سنگین داشته باشد.
مپ به ما کمک می‌کند این "سیارک‌ها" را در کنار هم ببینیم و غافلگیر نشویم.

**خلاصه فصل ۱۶ و ۱۷:**
1. قبل از اسپرینت، جلسات **Workshop** داشته باشید تا استوری‌ها را آماده کنید.
2. از تکنیک **Split** (خرد کردن) و **Thin** (حذف زوائد) استفاده کنید تا به سایز مناسب برسید.
3. استوری‌ها از دور کوچک (نقطه نورانی) و از نزدیک بزرگ (سیارک) هستند; مراقب این خطای دید باشید.
4. همیشه Story Map را جلوی چشم داشته باشید تا در میان انبوه تسک‌های کوچک، هدف اصلی گم نشود.

---

### چگونه Story Map بسازیم (How to Build a Story Map)

#### **گام ۱: داستان را قدم به قدم بنویسید (Write Out Your Story a Step at a Time)**

استراتژی ساده و عملی پاتون:
1. **Sticky notes یا کارت‌های کاغذی بردارید.**
2. **کار کنید بر روی تکالیفی که کاربر انجام می‌دهد** (Tasks).
   - مثال از Gary: کاربر ایمیل را می‌بیند → روی لینک کلیک می‌کند → حالا یک طرفدار است.
3. **هر تکلیف را با یک فعل شروع کنید** (Action-oriented).
   - ❌ "ایمیل" (اسم)
   - ✅ "درخواست ایمیل" یا "برای دریافت ایمیل ثبت شوید" (فعل)

**نکته منتورینگ:**
اگر تمام task‌هایت شروع با فعل نباشند، هنوز به‌اندازه کافی مشخص نیستند. کاربر **چطور** از ماژول استفاده می‌کند؟ نه **چی** می‌خواهد.

#### **گام ۲: داستان را سازمان‌دهی کنید (Organize Your Story)**

**ترتیب چپ به راست (Left to Right Narrative Flow):**
- **چپ:** اولین کار کاربر
- **راست:** آخرین کار کاربر
- وسط: همه چیز در ترتیب منطقی

**مثال Gary (Mad Mimi):**
```
[Band manager می‌خواهد یک موسیقار پیدا کند] 
  → [موسیقار را برای کار دعوت می‌کند] 
    → [راه‌حل را بررسی می‌کند] 
      → [پول پرداخت می‌کند] 
        → [پروژه تمام می‌شود]
```

#### **گام ۳: جزئیات را بر روی هم بگذارید (Stack Details Vertically)**

هر task بزرگ می‌تواند **subtasks** داشته باشد. اینها **عمودی** روی task اصلی می‌روند.

**مثال:**
```
[ایجاد پوسترِ تبلیغاتی]  ← Task اصلی
    ↓
[قالب را انتخاب کنید]     ← Subtask
[متن را اضافه کنید]       ← Subtask
[عکس را آپلود کنید]       ← Subtask
[تصویر نهایی را دانلود کنید] ← Subtask
```

#### **گام ۴: کمرِ مپ را شناسایی کنید (Distill Your Map to Make a Backbone)**

**Backbone** اصلی‌ترین tasks هستند که **باید** انجام شوند.
- اینها **بالاترین ردیف** مپ هستند.
- بقیه تکالیف زیر آن‌ها قرار می‌گیرند.

**مثال:**
```
[Login] → [جستجو کنید] → [محصول را انتخاب کنید] → [پرداخت کنید] → [تشکر صفحه]
  ↓         ↓               ↓                    ↓              ↓
filters   sorting      reviews            address        email
rating    favorites    photos            shipping       receipt
...       ...          ...               ...            ...
```

**اینجاست که Clean Architecture درخشد:** 
Backbone، **Main Flow** است که بدون آن کاربر نمی‌تواند کار را تمام کند.
جزئیات عمودی، **Happy Paths و Edge Cases** هستند.

#### **گام ۵: برای یک خاص Outcome، قسمتی از مپ را برش دهید (Slice Out Tasks)**

بسیاری از تیم‌ها یک **MVP** نیاز دارند. چطور می‌دانیم چه کاری برای MVP ضروری است؟
**Slice کردن** پاسخ است.

**مثال:** برای اینکه "یک Band Manager بتواند یک پست تبلیغاتی درست کند" چه تکالیفی لازم است؟

```
[ایجاد موضوع] → [انتخاب تصویر] → [نوشتن متن] → [انتشار]
```

این **slice** اصلی است. موارد دیگر (زیبایی تصویر، Scheduling، Analytics) برای بعد می‌تواند باشد.

### **ساختِ فیزیکی Story Map (نمونه)**

پاتون توضیح می‌دهد که Map معمولاً اینطور ظاهر می‌شود:

```
┌─────────────────────────────────────────────────────┐ ← BACKBONE
│ Step1  │ Step2  │ Step3  │ Step4  │ Step5         │
├─────────────────────────────────────────────────────┤
│ Detail │ Detail │ Detail │ Detail │ Detail         │
│ Detail │ Detail │ Detail │ Detail │ Detail         │ ← DETAILS (Depth)
│ Detail │ Detail │ Detail │ Detail │ Detail         │
└─────────────────────────────────────────────────────┘
        ↑
      FLOW (Left to Right)
```

**چپ → راست:** تسلسل زمانی
**بالا → پایین:** جزئیات

### **اولویت‌های عملی (Practical Tips)**

1. **از کاغذ و Sticky Notes استفاده کنید نه Jira:**
   - بسیار راحت‌تر می‌تونید تکالیف را جابه‌جا کنید.
   - تیم سریع‌تر درک می‌کند.
   - اگر دیجیتال می‌خواهید: Miro، Mural، یا حتی Figma امکان دارد.

2. **"Think mile wide, inch deep":**
   - ابتدا کل flow را بسازید.
   - بعداً جزئیات را اضافه کنید.

3. **عکس بگیرید:**
   - بعد از جلسه، عکسی از Map را ذخیره کنید.
   - این **Vacation Photo** است که بعداً یادآوری‌ها را بر می‌گرداند.

---

### فصل ۱۸: یادگیری از هر چیزی که می‌سازید (Learn from Everything You Build)

به ایستگاه پایانی رسیدیم. در این فصل، پاتون حلقه را کامل می‌کند. همانطور که در فصول ابتدایی گفتیم "داستان‌ها برای یادگیری هستند"، حالا باید ببینیم وقتی کد زده شد، چطور یاد بگیریم.

#### ۱. مرور تیمی (Review as a Team)

بعد از اینکه یک چرخه توسعه تمام شد (مثلاً پایان اسپرینت)، وقت جشن گرفتن است. اما بعد از جشن، تیم باید دور هم جمع شود و یک نگاه **صادقانه** به کارش بیندازد.

این جلسه با "دمو به مدیران" فرق دارد. این یک جلسه امن و داخلی برای کسانی است که دستشان به کد آلوده شده است (Developers, QA, PO).
پاتون پیشنهاد می‌کند کیفیت را در سه سطح بررسی کنید:

1.  **کیفیت تجربه کاربری (User Experience Quality):**
    - آیا استفاده از آن حس خوبی دارد؟ (Look & Feel).
    - به خودتان نمره ۱ تا ۵ بدهید.
2.  **کیفیت عملکردی (Functional Quality):**
    - آیا باگ دارد؟ آیا تسترها نگران باگ‌های مخفی هستند؟
    - نمره ۱ تا ۵.
3.  **کیفیت کد (Code Quality):**
    - آیا کدی که نوشتیم **Clean Code** است یا یک توده کد کثیف (Legacy Code) جدید خلق کردیم؟
    - آیا قابل نگهداری است؟
    - **نکته برای تو (توسعه‌دهنده ارشد):** اینجا جایی است که باید بی‌رحمانه صادق باشی. اگر کد کار می‌کند اما "کثیف" است، باید برایش استوری‌های Refactoring بنویسید.

#### ۲. مرور با دیگران در سازمان (Review with Others)

بعد از اینکه خودتان کار را بررسی کردید، حالا نوبت نشان دادن آن به ذینفعان (Stakeholders) است.
- به آن‌ها نشان دهید که چطور به سمت اهداف (Outcomes) حرکت کرده‌اید.
- بازخورد بگیرید، اما مراقب باشید: اگر کسی که در جریان جزئیات نبوده پیشنهادی می‌دهد، با احترام به او یادآوری کنید که "هدف این Release چیست". هر پیشنهادی لزوماً نباید اجرا شود.

#### ۳. کافی (Enough)

چقدر نرم‌افزار باید بسازیم تا بتوانیم آن را تست کنیم؟
پاتون از استعاره **ترازو** استفاده می‌کند.
- در یک کفه ترازو، قطعات کوچک نرم‌افزار (User Stories) را می‌ریزیم (مثل آجرهای لگو).
- در کفه دیگر، سنگ وزنه "ارزش" قرار دارد.
- وقتی مقدار نرم‌افزار آنقدر شد که کفه ترازو پایین رفت (یعنی کاربر می‌تواند **یک کار معنادار** را کامل انجام دهد)، آن وقت "کافی" است.
- لازم نیست کل سیستم کامل باشد. کافی است کاربر بتواند به **یکی** از اهدافش برسد.

#### ۴. یادگیری از کاربران (Learn from Users)

نشان دادن دمو به کاربر (Show and Tell) کافی نیست. مثل این است که ماشین را در نمایشگاه ببینید ولی سوارش نشوید.
- باید محصول را به دست کاربر بدهید و **مشاهده کنید** (Observe) که با آن کار می‌کند.
- آیا جایی که فکر می‌کردید کلیک می‌کند، کلیک کرد؟
- آیا گیج شد؟
- اینجاست که فرضیات ما (Assumptions) تایید یا رد می‌شوند.

#### ۵. استفاده از مپ برای ارزیابی آمادگی انتشار (Use a Map to Evaluate Release Readiness)

آخرین کاربرد Story Map: **داشبورد وضعیت پروژه.**
- وقتی به پایان پروژه نزدیک می‌شوید، روی مپ نگاه کنید.
- استوری‌هایی که تمام شده‌اند را سبز کنید.
- استوری‌هایی که باگ دارند را قرمز کنید.
- با یک نگاه به مپ، می‌فهمید که آیا "کمر محصول" (Backbone) سالم است یا نه. آیا می‌توانیم ریلیز کنیم؟

### پایان‌بندی: این پایان نیست (The End, or Is It?)

کتاب تمام می‌شود، اما یادگیری نه.
پاتون کتاب را با این پیام تمام می‌کند:
> **"Your job isn’t to build more software faster: it’s to maximize the outcome and impact you get from what you choose to build."**
> (شغل شما ساختن نرم‌افزار بیشتر با سرعت بیشتر نیست؛ شغل شما ماکزیمم کردن اثرگذاری و نتیجه است.)

به عنوان یک توسعه‌دهنده ارشد و کسی که دغدغه کیفیت دارد، این بهترین نصیحتی است که می‌توانیم بگیریم. کد تمیز و دیزاین پترن‌ها ابزار هستند، نه هدف. هدف، خلق ارزش برای انسان‌هاست.

**جمع‌بندی نهایی ما:**
1.  **Big Picture:** مپ به ما کمک می‌کند جنگل را ببینیم، نه فقط درخت‌ها را.
2.  **Shared Understanding:** هدف مستندسازی نیست، درک مشترک است.
3.  **Discovery vs Delivery:** قبل از ساختن، مطمئن شویم که چیز درستی می‌سازیم (Valuable, Usable, Feasible).
4.  **Slice & Thin:** داستان‌ها را به روش درست بشکنیم (مثل کاپ‌کیک، نه لایه لایه).
5.  **Build to Learn:** هر ریلیز فرصتی برای یادگیری است.

---